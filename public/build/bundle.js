
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() {}

    const identity$2 = x => x;

    function assign(tar, src) {
      // @ts-ignore
      for (const k in src) tar[k] = src[k];

      return tar;
    }

    function is_promise(value) {
      return value && typeof value === 'object' && typeof value.then === 'function';
    }

    function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
        loc: {
          file,
          line,
          column,
          char
        }
      };
    }

    function run(fn) {
      return fn();
    }

    function blank_object() {
      return Object.create(null);
    }

    function run_all(fns) {
      fns.forEach(run);
    }

    function is_function(thing) {
      return typeof thing === 'function';
    }

    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
    }

    let src_url_equal_anchor;

    function src_url_equal(element_src, url) {
      if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
      }

      src_url_equal_anchor.href = url;
      return element_src === src_url_equal_anchor.href;
    }

    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }

    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }

    function subscribe(store, ...callbacks) {
      if (store == null) {
        return noop;
      }

      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    function get_store_value(store) {
      let value;
      subscribe(store, _ => value = _)();
      return value;
    }

    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe(store, callback));
    }

    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }

    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }

    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));

        if ($$scope.dirty === undefined) {
          return lets;
        }

        if (typeof lets === 'object') {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);

          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }

          return merged;
        }

        return $$scope.dirty | lets;
      }

      return $$scope.dirty;
    }

    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }

    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
      update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
    }

    function get_all_dirty_from_scope($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;

        for (let i = 0; i < length; i++) {
          dirty[i] = -1;
        }

        return dirty;
      }

      return -1;
    }

    function exclude_internal_props(props) {
      const result = {};

      for (const k in props) if (k[0] !== '$') result[k] = props[k];

      return result;
    }

    function compute_rest_props(props, keys) {
      const rest = {};
      keys = new Set(keys);

      for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];

      return rest;
    }

    function set_store_value(store, ret, value) {
      store.set(value);
      return ret;
    }

    function action_destroyer(action_result) {
      return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now$1 = is_client ? () => window.performance.now() : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop; // used internally for testing

    const tasks = new Set();

    function run_tasks(now) {
      tasks.forEach(task => {
        if (!task.c(now)) {
          tasks.delete(task);
          task.f();
        }
      });
      if (tasks.size !== 0) raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */


    function loop$1(callback) {
      let task;
      if (tasks.size === 0) raf(run_tasks);
      return {
        promise: new Promise(fulfill => {
          tasks.add(task = {
            c: callback,
            f: fulfill
          });
        }),

        abort() {
          tasks.delete(task);
        }

      };
    } // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM

    function append$1(target, node) {
      target.appendChild(node);
    }

    function get_root_for_style(node) {
      if (!node) return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;

      if (root.host) {
        return root;
      }

      return document;
    }

    function append_empty_stylesheet(node) {
      const style_element = element('style');
      append_stylesheet(get_root_for_style(node), style_element);
      return style_element;
    }

    function append_stylesheet(node, style) {
      append$1(node.head || node, style);
    }

    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }

    function detach(node) {
      node.parentNode.removeChild(node);
    }

    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i]) iterations[i].d(detaching);
      }
    }

    function element(name) {
      return document.createElement(name);
    }

    function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
    }

    function text$1(data) {
      return document.createTextNode(data);
    }

    function space() {
      return text$1(' ');
    }

    function empty() {
      return text$1('');
    }

    function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }

    function prevent_default(fn) {
      return function (event) {
        event.preventDefault(); // @ts-ignore

        return fn.call(this, event);
      };
    }

    function attr$1(node, attribute, value) {
      if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
    }

    function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === 'style') {
          node.style.cssText = attributes[key];
        } else if (key === '__value') {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr$1(node, key, attributes[key]);
        }
      }
    }

    function set_custom_element_data(node, prop, value) {
      if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
      } else {
        attr$1(node, prop, value);
      }
    }

    function children$1(element) {
      return Array.from(element.childNodes);
    }

    function set_input_value(input, value) {
      input.value = value == null ? '' : value;
    }

    function set_style(node, key, value, important) {
      node.style.setProperty(key, value, important ? 'important' : '');
    }

    function select_option(select, value) {
      for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];

        if (option.__value === value) {
          option.selected = true;
          return;
        }
      }
    }

    function select_value(select) {
      const selected_option = select.querySelector(':checked') || select.options[0];
      return selected_option && selected_option.__value;
    }
    // so we cache the result instead


    let crossorigin;

    function is_crossorigin() {
      if (crossorigin === undefined) {
        crossorigin = false;

        try {
          if (typeof window !== 'undefined' && window.parent) {
            void window.parent.document;
          }
        } catch (error) {
          crossorigin = true;
        }
      }

      return crossorigin;
    }

    function add_resize_listener(node, fn) {
      const computed_style = getComputedStyle(node);

      if (computed_style.position === 'static') {
        node.style.position = 'relative';
      }

      const iframe = element('iframe');
      iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
      iframe.setAttribute('aria-hidden', 'true');
      iframe.tabIndex = -1;
      const crossorigin = is_crossorigin();
      let unsubscribe;

      if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', event => {
          if (event.source === iframe.contentWindow) fn();
        });
      } else {
        iframe.src = 'about:blank';

        iframe.onload = () => {
          unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
      }

      append$1(node, iframe);
      return () => {
        if (crossorigin) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }

        detach(iframe);
      };
    }

    function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
    }

    function custom_event(type, detail, bubbles = false) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, bubbles, false, detail);
      return e;
    }

    class HtmlTag {
      constructor() {
        this.e = this.n = null;
      }

      c(html) {
        this.h(html);
      }

      m(html, target, anchor = null) {
        if (!this.e) {
          this.e = element(target.nodeName);
          this.t = target;
          this.c(html);
        }

        this.i(anchor);
      }

      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }

      i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
          insert(this.t, this.n[i], anchor);
        }
      }

      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }

      d() {
        this.n.forEach(detach);
      }

    }

    const active_docs = new Set();
    let active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

    function hash(str) {
      let hash = 5381;
      let i = str.length;

      while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);

      return hash >>> 0;
    }

    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = '{\n';

      for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
      }

      const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
      const name = `__svelte_${hash(rule)}_${uid}`;
      const doc = get_root_for_style(node);
      active_docs.add(doc);
      const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
      const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});

      if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }

      const animation = node.style.animation || '';
      node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }

    function delete_rule(node, name) {
      const previous = (node.style.animation || '').split(', ');
      const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation
      : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
      );
      const deleted = previous.length - next.length;

      if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active) clear_rules();
      }
    }

    function clear_rules() {
      raf(() => {
        if (active) return;
        active_docs.forEach(doc => {
          const stylesheet = doc.__svelte_stylesheet;
          let i = stylesheet.cssRules.length;

          while (i--) stylesheet.deleteRule(i);

          doc.__svelte_rules = {};
        });
        active_docs.clear();
      });
    }

    let current_component;

    function set_current_component(component) {
      current_component = component;
    }

    function get_current_component() {
      if (!current_component) throw new Error('Function called outside component initialization');
      return current_component;
    }

    function beforeUpdate(fn) {
      get_current_component().$$.before_update.push(fn);
    }

    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }

    function afterUpdate(fn) {
      get_current_component().$$.after_update.push(fn);
    }

    function onDestroy(fn) {
      get_current_component().$$.on_destroy.push(fn);
    }

    function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
        const callbacks = component.$$.callbacks[type];

        if (callbacks) {
          // TODO are there situations where events could be dispatched
          // in a server (non-DOM) environment?
          const event = custom_event(type, detail);
          callbacks.slice().forEach(fn => {
            fn.call(component, event);
          });
        }
      };
    }

    function setContext(key, context) {
      get_current_component().$$.context.set(key, context);
    }

    function getContext(key) {
      return get_current_component().$$.context.get(key);
    }
    // shorthand events, or if we want to implement
    // a real bubbling mechanism


    function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];

      if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
      }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;

    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }

    function tick() {
      schedule_update();
      return resolved_promise;
    }

    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }

    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }

    let flushing = false;
    const seen_callbacks = new Set();

    function flush() {
      if (flushing) return;
      flushing = true;

      do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
          const component = dirty_components[i];
          set_current_component(component);
          update$1(component.$$);
        }

        set_current_component(null);
        dirty_components.length = 0;

        while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...


        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];

          if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);
            callback();
          }
        }

        render_callbacks.length = 0;
      } while (dirty_components.length);

      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }

      update_scheduled = false;
      flushing = false;
      seen_callbacks.clear();
    }

    function update$1($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }

    let promise;

    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }

      return promise;
    }

    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }

    const outroing = new Set();
    let outros;

    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros // parent group

      };
    }

    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }

      outros = outros.p;
    }

    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }

    function transition_out(block, local, detach, callback) {
      if (block && block.o) {
        if (outroing.has(block)) return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);

          if (callback) {
            if (detach) block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }

    const null_transition = {
      duration: 0
    };

    function create_bidirectional_transition(node, fn, params, intro) {
      let config = fn(node, params);
      let t = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;

      function clear_animation() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
          a: t,
          b: program.b,
          d,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }

      function go(b) {
        const {
          delay = 0,
          duration = 300,
          easing = identity$2,
          tick = noop,
          css
        } = config || null_transition;
        const program = {
          start: now$1() + delay,
          b
        };

        if (!b) {
          // @ts-ignore todo: improve typings
          program.group = outros;
          outros.r += 1;
        }

        if (running_program || pending_program) {
          pending_program = program;
        } else {
          // if this is an intro, and there's a delay, we need to do
          // an initial tick and/or apply CSS animation immediately
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, b, duration, delay, easing, css);
          }

          if (b) tick(0, 1);
          running_program = init(program, duration);
          add_render_callback(() => dispatch(node, b, 'start'));
          loop$1(now => {
            if (pending_program && now > pending_program.start) {
              running_program = init(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, 'start');

              if (css) {
                clear_animation();
                animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }

            if (running_program) {
              if (now >= running_program.end) {
                tick(t = running_program.b, 1 - t);
                dispatch(node, running_program.b, 'end');

                if (!pending_program) {
                  // we're done
                  if (running_program.b) {
                    // intro — we can tidy up immediately
                    clear_animation();
                  } else {
                    // outro — needs to be coordinated
                    if (! --running_program.group.r) run_all(running_program.group.c);
                  }
                }

                running_program = null;
              } else if (now >= running_program.start) {
                const p = now - running_program.start;
                t = running_program.a + running_program.d * easing(p / running_program.duration);
                tick(t, 1 - t);
              }
            }

            return !!(running_program || pending_program);
          });
        }
      }

      return {
        run(b) {
          if (is_function(config)) {
            wait().then(() => {
              // @ts-ignore
              config = config();
              go(b);
            });
          } else {
            go(b);
          }
        },

        end() {
          clear_animation();
          running_program = pending_program = null;
        }

      };
    }

    function handle_promise(promise, info) {
      const token = info.token = {};

      function update(type, index, key, value) {
        if (info.token !== token) return;
        info.resolved = value;
        let child_ctx = info.ctx;

        if (key !== undefined) {
          child_ctx = child_ctx.slice();
          child_ctx[key] = value;
        }

        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;

        if (info.block) {
          if (info.blocks) {
            info.blocks.forEach((block, i) => {
              if (i !== index && block) {
                group_outros();
                transition_out(block, 1, 1, () => {
                  if (info.blocks[i] === block) {
                    info.blocks[i] = null;
                  }
                });
                check_outros();
              }
            });
          } else {
            info.block.d(1);
          }

          block.c();
          transition_in(block, 1);
          block.m(info.mount(), info.anchor);
          needs_flush = true;
        }

        info.block = block;
        if (info.blocks) info.blocks[index] = block;

        if (needs_flush) {
          flush();
        }
      }

      if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
          set_current_component(current_component);
          update(info.then, 1, info.value, value);
          set_current_component(null);
        }, error => {
          set_current_component(current_component);
          update(info.catch, 2, info.error, error);
          set_current_component(null);

          if (!info.hasCatch) {
            throw error;
          }
        }); // if we previously had a then/catch block, destroy it

        if (info.current !== info.pending) {
          update(info.pending, 0);
          return true;
        }
      } else {
        if (info.current !== info.then) {
          update(info.then, 1, info.value, promise);
          return true;
        }

        info.resolved = promise;
      }
    }

    function update_await_block_branch(info, ctx, dirty) {
      const child_ctx = ctx.slice();
      const {
        resolved
      } = info;

      if (info.current === info.then) {
        child_ctx[info.value] = resolved;
      }

      if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
      }

      info.block.p(child_ctx, dirty);
    }

    const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }

    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};

      while (i--) old_indexes[old_blocks[i].key] = i;

      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;

      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);

        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }

        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
      }

      const will_move = new Set();
      const did_move = new Set();

      function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }

      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;

        if (new_block === old_block) {
          // do nothing
          next = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          // remove old block
          destroy(old_block, lookup);
          o--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }

      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
      }

      while (n) insert(new_blocks[n - 1]);

      return new_blocks;
    }

    function validate_each_keys(ctx, list, get_context, get_key) {
      const keys = new Set();

      for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));

        if (keys.has(key)) {
          throw new Error('Cannot have duplicate keys in a keyed each');
        }

        keys.add(key);
      }
    }

    function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = {
        $$scope: 1
      };
      let i = levels.length;

      while (i--) {
        const o = levels[i];
        const n = updates[i];

        if (n) {
          for (const key in o) {
            if (!(key in n)) to_null_out[key] = 1;
          }

          for (const key in n) {
            if (!accounted_for[key]) {
              update[key] = n[key];
              accounted_for[key] = 1;
            }
          }

          levels[i] = n;
        } else {
          for (const key in o) {
            accounted_for[key] = 1;
          }
        }
      }

      for (const key in to_null_out) {
        if (!(key in update)) update[key] = undefined;
      }

      return update;
    }

    function get_spread_object(spread_props) {
      return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    } // source: https://html.spec.whatwg.org/multipage/indices.html

    function each$1(items, fn) {
      let str = '';

      for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
      }

      return str;
    }

    function bind(component, name, callback) {
      const index = component.$$.props[name];

      if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }

    function create_component(block) {
      block && block.c();
    }

    function mount_component(component, target, anchor, customElement) {
      const {
        fragment,
        on_mount,
        on_destroy,
        after_update
      } = component.$$;
      fragment && fragment.m(target, anchor);

      if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
          const new_on_destroy = on_mount.map(run).filter(is_function);

          if (on_destroy) {
            on_destroy.push(...new_on_destroy);
          } else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
          }

          component.$$.on_mount = [];
        });
      }

      after_update.forEach(add_render_callback);
    }

    function destroy_component(component, detaching) {
      const $$ = component.$$;

      if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)

        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }

    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }

      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }

    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles && append_styles($$.root);
      let ready = false;
      $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;

        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }

        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update); // `false` as a special case of no DOM component

      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

      if (options.target) {
        if (options.hydrate) {
          const nodes = children$1(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.c();
        }

        if (options.intro) transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
      }

      set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */


    class SvelteComponent {
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }

      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1) callbacks.splice(index, 1);
        };
      }

      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }

    }

    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({
        version: '3.41.0'
      }, detail), true));
    }

    function append_dev(target, node) {
      dispatch_dev('SvelteDOMInsert', {
        target,
        node
      });
      append$1(target, node);
    }

    function insert_dev(target, node, anchor) {
      dispatch_dev('SvelteDOMInsert', {
        target,
        node,
        anchor
      });
      insert(target, node, anchor);
    }

    function detach_dev(node) {
      dispatch_dev('SvelteDOMRemove', {
        node
      });
      detach(node);
    }

    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default) modifiers.push('preventDefault');
      if (has_stop_propagation) modifiers.push('stopPropagation');
      dispatch_dev('SvelteDOMAddEventListener', {
        node,
        event,
        handler,
        modifiers
      });
      const dispose = listen(node, event, handler, options);
      return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', {
          node,
          event,
          handler,
          modifiers
        });
        dispose();
      };
    }

    function attr_dev(node, attribute, value) {
      attr$1(node, attribute, value);
      if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
        node,
        attribute
      });else dispatch_dev('SvelteDOMSetAttribute', {
        node,
        attribute,
        value
      });
    }

    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev('SvelteDOMSetProperty', {
        node,
        property,
        value
      });
    }

    function set_data_dev(text, data) {
      data = '' + data;
      if (text.wholeText === data) return;
      dispatch_dev('SvelteDOMSetData', {
        node: text,
        data
      });
      text.data = data;
    }

    function validate_each_argument(arg) {
      if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';

        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
          msg += ' You can use a spread to convert this iterable into an array.';
        }

        throw new Error(msg);
      }
    }

    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */


    class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error("'target' is a required option");
        }

        super();
      }

      $destroy() {
        super.$destroy();

        this.$destroy = () => {
          console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
      }

      $capture_state() {}

      $inject_state() {}

    }

    function styleInject(css, ref) {
      if (ref === void 0) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') {
        return;
      }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z$3 = "";
    styleInject(css_248z$3);

    function links(node, {
      history
    }) {
      function onClick(e) {
        e.stopPropagation();
        let current = e.target;

        while (current && current.tagName !== 'A') {
          current = current.parentElement;
        }

        if (current && !['_self', '_blank', '_top', '_parent'].includes(current.getAttribute('target'))) {
          const action = current.getAttribute('replace') ? 'replace' : 'push';
          const href = current.getAttribute('href');

          if (!['//', 'http'].find(rule => href.startsWith(rule))) {
            e.preventDefault();
            history[action](href);
          }
        }
      }

      node.addEventListener('click', onClick);
      return {
        destroy() {
          node.removeEventListener('click', onClick);
        }

      };
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */

    function readable(value, start) {
      return {
        subscribe: writable(value, start).subscribe
      };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */


    function writable(value, start = noop) {
      let stop;
      const subscribers = new Set();

      function set(new_value) {
        if (safe_not_equal(value, new_value)) {
          value = new_value;

          if (stop) {
            // store is ready
            const run_queue = !subscriber_queue.length;

            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue.push(subscriber, value);
            }

            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }

              subscriber_queue.length = 0;
            }
          }
        }
      }

      function update(fn) {
        set(fn(value));
      }

      function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);

        if (subscribers.size === 1) {
          stop = start(set) || noop;
        }

        run(value);
        return () => {
          subscribers.delete(subscriber);

          if (subscribers.size === 0) {
            stop();
            stop = null;
          }
        };
      }

      return {
        set,
        update,
        subscribe
      };
    }

    function derived(stores, fn, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      const auto = fn.length < 2;
      return readable(initial_value, set => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;

        const sync = () => {
          if (pending) {
            return;
          }

          cleanup();
          const result = fn(single ? values[0] : values, set);

          if (auto) {
            set(result);
          } else {
            cleanup = is_function(result) ? result : noop;
          }
        };

        const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {
          values[i] = value;
          pending &= ~(1 << i);

          if (inited) {
            sync();
          }
        }, () => {
          pending |= 1 << i;
        }));
        inited = true;
        sync();
        return function stop() {
          run_all(unsubscribers);
          cleanup();
        };
      });
    }

    const CONTEXT_KEY$1 = '_protection';
    function createProtection() {
      setContext(CONTEXT_KEY$1, []);
    }
    function createLocalProtection(initial) {
      const localProtection = writable(initial);
      setContext(CONTEXT_KEY$1, [...getContext(CONTEXT_KEY$1), localProtection]);
      return localProtection;
    }
    function getProtected() {
      return derived(getContext(CONTEXT_KEY$1), protections => protections.reduce((acc, next) => acc && next, true));
    }

    function createBaseHistory(initialPath) {
      let _isBlocked = false;
      let _isLeaving = false;
      let _leaveListeners = [];
      let currentPath = writable(initialPath);

      function setPath(path) {
        currentPath.set(path);
      }

      function block() {
        _isBlocked = true;
      }

      function unblock() {
        _isBlocked = false;
        _isLeaving = false;
      }

      function isBlocked() {
        return _isBlocked;
      }

      function wasTriedToLeave() {
        if (!_isLeaving) {
          _isLeaving = true;

          _leaveListeners.forEach(listener => listener(_isLeaving));
        }
      }

      function acceptLeave() {
        unblock();
      }

      function cancelLeave() {
        _isLeaving = false;

        _leaveListeners.forEach(listener => listener(_isLeaving));
      }

      function onLeave(callback) {
        _leaveListeners.push(callback);
      }

      function offLeave(callback) {
        _leaveListeners = _leaveListeners.filter(listener => listener !== callback);
      }

      return {
        setPath,
        block,
        unblock,
        isBlocked,
        acceptLeave,
        cancelLeave,
        onLeave,
        offLeave,
        wasTriedToLeave,
        currentPath: {
          subscribe: currentPath.subscribe
        }
      };
    }

    const globalHistory = window.history;
    function createBrowserHistory$1() {
      const {
        currentPath,
        setPath,
        block,
        unblock,
        isBlocked,
        acceptLeave,
        cancelLeave,
        onLeave,
        offLeave,
        wasTriedToLeave
      } = createBaseHistory(getCurrentPath());
      let isStateChangedFromUI = false;
      let pendingAction = null;
      let currentState = globalHistory.state || 0;
      globalHistory.replaceState(currentState, '', getCurrentPath());

      function push(to) {
        if (isBlocked()) return [push, [to]];
        globalHistory.pushState(++currentState, null, to);
        setCurrentPath();
      }

      function back() {
        if (isBlocked()) return [back, []];
        isStateChangedFromUI = true;
        globalHistory.back();
        currentState--;
      }

      function forward() {
        if (isBlocked()) return [forward, []];
        isStateChangedFromUI = true;
        globalHistory.forward();
        currentState++;
      }

      function replace(to) {
        if (isBlocked()) return [replace, [to]];
        globalHistory.replaceState(currentState, null, to);
        setCurrentPath();
      }

      function onStateChange(e) {
        if (isStateChangedFromUI) {
          setCurrentPath();
          isStateChangedFromUI = false;
          return;
        }

        if (isBlocked()) {
          globalHistory[e.state < currentState ? 'forward' : 'back']();
          isStateChangedFromUI = true;
          return [e.state < currentState ? back : forward, []];
        }

        currentState = e.state;
        setCurrentPath();
      }

      function wrapAfterAction(action) {
        return (...args) => {
          const presentedPendingAction = action(...args);

          if (presentedPendingAction) {
            pendingAction = presentedPendingAction;
            wasTriedToLeave();
          }
        };
      }

      function onAcceptLeave() {
        acceptLeave();
        const [fn, args] = pendingAction;
        fn(...args);
      }

      function onPageUnload(e) {
        if (isBlocked()) {
          e.returnValue = '';
          return 'Are you sure?';
        }
      }

      function getCurrentPath() {
        return `${location.pathname}${location.search}${location.hash}`;
      }

      function setCurrentPath() {
        setPath(getCurrentPath());
      }

      const wrappedOnStateChange = wrapAfterAction(onStateChange);
      window.addEventListener('popstate', wrappedOnStateChange);
      window.addEventListener('beforeunload', onPageUnload);
      onDestroy(() => {
        pendingAction = null;
        window.removeEventListener('popstate', wrappedOnStateChange);
        window.removeEventListener('beforeunload', onPageUnload);
      });
      return {
        currentPath,
        push: wrapAfterAction(push),
        back: wrapAfterAction(back),
        forward: wrapAfterAction(forward),
        replace: wrapAfterAction(replace),
        block,
        unblock,
        acceptLeave: onAcceptLeave,
        cancelLeave,
        onLeave,
        offLeave
      };
    }

    const HISTORY_KEY = '__history';

    function createHistory(baseHistory) {
      setContext(HISTORY_KEY, baseHistory);
      return baseHistory;
    }

    function getHistory() {
      return getContext(HISTORY_KEY);
    }
    function createBrowserHistory() {
      return createHistory(createBrowserHistory$1());
    }

    /**
     * Expose `pathToRegexp`.
     */
    var pathToRegexp_1 = pathToRegexp;
    var match_1 = match;
    var regexpToFunction_1 = regexpToFunction;
    var parse_1 = parse$1;
    var compile_1 = compile;
    var tokensToFunction_1 = tokensToFunction;
    var tokensToRegExp_1 = tokensToRegExp;
    /**
     * Default configs.
     */

    var DEFAULT_DELIMITER = '/';
    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */

    var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
    // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
    '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'].join('|'), 'g');
    /**
     * Parse a string for the raw tokens.
     *
     * @param  {string}  str
     * @param  {Object=} options
     * @return {!Array}
     */

    function parse$1(str, options) {
      var tokens = [];
      var key = 0;
      var index = 0;
      var path = '';
      var defaultDelimiter = options && options.delimiter || DEFAULT_DELIMITER;
      var whitelist = options && options.whitelist || undefined;
      var pathEscaped = false;
      var res;

      while ((res = PATH_REGEXP.exec(str)) !== null) {
        var m = res[0];
        var escaped = res[1];
        var offset = res.index;
        path += str.slice(index, offset);
        index = offset + m.length; // Ignore already escaped sequences.

        if (escaped) {
          path += escaped[1];
          pathEscaped = true;
          continue;
        }

        var prev = '';
        var name = res[2];
        var capture = res[3];
        var group = res[4];
        var modifier = res[5];

        if (!pathEscaped && path.length) {
          var k = path.length - 1;
          var c = path[k];
          var matches = whitelist ? whitelist.indexOf(c) > -1 : true;

          if (matches) {
            prev = c;
            path = path.slice(0, k);
          }
        } // Push the current path onto the tokens.


        if (path) {
          tokens.push(path);
          path = '';
          pathEscaped = false;
        }

        var repeat = modifier === '+' || modifier === '*';
        var optional = modifier === '?' || modifier === '*';
        var pattern = capture || group;
        var delimiter = prev || defaultDelimiter;
        tokens.push({
          name: name || key++,
          prefix: prev,
          delimiter: delimiter,
          optional: optional,
          repeat: repeat,
          pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : delimiter + defaultDelimiter) + ']+?'
        });
      } // Push any remaining characters.


      if (path || index < str.length) {
        tokens.push(path + str.substr(index));
      }

      return tokens;
    }
    /**
     * Compile a string to a template function for the path.
     *
     * @param  {string}             str
     * @param  {Object=}            options
     * @return {!function(Object=, Object=)}
     */


    function compile(str, options) {
      return tokensToFunction(parse$1(str, options), options);
    }
    /**
     * Create path match function from `path-to-regexp` spec.
     */


    function match(str, options) {
      var keys = [];
      var re = pathToRegexp(str, keys, options);
      return regexpToFunction(re, keys);
    }
    /**
     * Create a path match function from `path-to-regexp` output.
     */


    function regexpToFunction(re, keys) {
      return function (pathname, options) {
        var m = re.exec(pathname);
        if (!m) return false;
        var path = m[0];
        var index = m.index;
        var params = {};
        var decode = options && options.decode || decodeURIComponent;

        for (var i = 1; i < m.length; i++) {
          if (m[i] === undefined) continue;
          var key = keys[i - 1];

          if (key.repeat) {
            params[key.name] = m[i].split(key.delimiter).map(function (value) {
              return decode(value, key);
            });
          } else {
            params[key.name] = decode(m[i], key);
          }
        }

        return {
          path: path,
          index: index,
          params: params
        };
      };
    }
    /**
     * Expose a method for transforming tokens into the path function.
     */


    function tokensToFunction(tokens, options) {
      // Compile all the tokens into regexps.
      var matches = new Array(tokens.length); // Compile all the patterns before compilation.

      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] === 'object') {
          matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
        }
      }

      return function (data, options) {
        var path = '';
        var encode = options && options.encode || encodeURIComponent;
        var validate = options ? options.validate !== false : true;

        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];

          if (typeof token === 'string') {
            path += token;
            continue;
          }

          var value = data ? data[token.name] : undefined;
          var segment;

          if (Array.isArray(value)) {
            if (!token.repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
            }

            if (value.length === 0) {
              if (token.optional) continue;
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }

            for (var j = 0; j < value.length; j++) {
              segment = encode(value[j], token);

              if (validate && !matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
              }

              path += (j === 0 ? token.prefix : token.delimiter) + segment;
            }

            continue;
          }

          if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            segment = encode(String(value), token);

            if (validate && !matches[i].test(segment)) {
              throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
            }

            path += token.prefix + segment;
            continue;
          }

          if (token.optional) continue;
          throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'));
        }

        return path;
      };
    }
    /**
     * Escape a regular expression string.
     *
     * @param  {string} str
     * @return {string}
     */


    function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
    }
    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {string} group
     * @return {string}
     */


    function escapeGroup(group) {
      return group.replace(/([=!:$/()])/g, '\\$1');
    }
    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {string}
     */


    function flags(options) {
      return options && options.sensitive ? '' : 'i';
    }
    /**
     * Pull out keys from a regexp.
     *
     * @param  {!RegExp} path
     * @param  {Array=}  keys
     * @return {!RegExp}
     */


    function regexpToRegexp(path, keys) {
      if (!keys) return path; // Use a negative lookahead to match only capturing groups.

      var groups = path.source.match(/\((?!\?)/g);

      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            pattern: null
          });
        }
      }

      return path;
    }
    /**
     * Transform an array into a regexp.
     *
     * @param  {!Array}  path
     * @param  {Array=}  keys
     * @param  {Object=} options
     * @return {!RegExp}
     */


    function arrayToRegexp(path, keys, options) {
      var parts = [];

      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options).source);
      }

      return new RegExp('(?:' + parts.join('|') + ')', flags(options));
    }
    /**
     * Create a path regexp from string input.
     *
     * @param  {string}  path
     * @param  {Array=}  keys
     * @param  {Object=} options
     * @return {!RegExp}
     */


    function stringToRegexp(path, keys, options) {
      return tokensToRegExp(parse$1(path, options), keys, options);
    }
    /**
     * Expose a function for taking tokens and returning a RegExp.
     *
     * @param  {!Array}  tokens
     * @param  {Array=}  keys
     * @param  {Object=} options
     * @return {!RegExp}
     */


    function tokensToRegExp(tokens, keys, options) {
      options = options || {};
      var strict = options.strict;
      var start = options.start !== false;
      var end = options.end !== false;
      var delimiter = options.delimiter || DEFAULT_DELIMITER;
      var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
      var route = start ? '^' : ''; // Iterate over the tokens and create our regexp string.

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          route += escapeString(token);
        } else {
          var capture = token.repeat ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*' : token.pattern;
          if (keys) keys.push(token);

          if (token.optional) {
            if (!token.prefix) {
              route += '(' + capture + ')?';
            } else {
              route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?';
            }
          } else {
            route += escapeString(token.prefix) + '(' + capture + ')';
          }
        }
      }

      if (end) {
        if (!strict) route += '(?:' + escapeString(delimiter) + ')?';
        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
      } else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === 'string' ? endToken[endToken.length - 1] === delimiter : endToken === undefined;
        if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?';
        if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')';
      }

      return new RegExp(route, flags(options));
    }
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(string|RegExp|Array)} path
     * @param  {Array=}                keys
     * @param  {Object=}               options
     * @return {!RegExp}
     */


    function pathToRegexp(path, keys, options) {
      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys);
      }

      if (Array.isArray(path)) {
        return arrayToRegexp(path, keys, options);
      }

      return stringToRegexp(path, keys, options);
    }
    pathToRegexp_1.match = match_1;
    pathToRegexp_1.regexpToFunction = regexpToFunction_1;
    pathToRegexp_1.parse = parse_1;
    pathToRegexp_1.compile = compile_1;
    pathToRegexp_1.tokensToFunction = tokensToFunction_1;
    pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

    const patternCache = {};
    const cacheLimit = 10000;
    let cacheCount = 0;

    function compilePath(pattern, options) {
      const cacheKey = `${options.end}${options.strict}${options.sensitive}`;
      const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

      if (cache[pattern]) {
        return cache[pattern];
      }

      const keys = [];
      const re = pathToRegexp_1(pattern, keys, options);
      const compiledPattern = {
        re,
        keys
      };

      if (cacheCount < cacheLimit) {
        cache[pattern] = compiledPattern;
        cacheCount++;
      }

      return compiledPattern;
    }

    function matchPath(pathname, options = {}) {
      if (typeof options === 'string') {
        options = {
          path: options
        };
      }

      if (options.path === '*') {
        return true;
      }

      pathname = pathname.split('#')[0];
      const {
        path = '/',
        exact = false,
        strict = false,
        sensitive = false
      } = options;
      const {
        re,
        keys
      } = compilePath(path, {
        end: exact,
        strict,
        sensitive
      });
      const match = re.exec(pathname);

      if (!match) {
        return null;
      }

      const [url, ...values] = match;
      const isExact = pathname === url;

      if (exact && !isExact) {
        return null;
      }

      return {
        path,
        url: path === '/' && url === '' ? '/' : url,
        isExact,
        params: keys.reduce((memo, key, index) => {
          memo[key.name] = values[index];
          return memo;
        }, {})
      };
    }

    const CONTEXT_KEY = '_base_path';
    function createBasePath(basePath) {
      setContext(CONTEXT_KEY, basePath);
    }
    function getBasePath() {
      return (getContext(CONTEXT_KEY) || '').replace(/\/$/, '');
    }

    function dynamicDerived(callback) {
      let subjects = new Map();
      let listeners = [];

      function subscribe(listener) {
        listeners.push(listener);
        listener(getDerivedValue());
        return () => {
          listeners = listeners.filter(_listener => _listener !== listener);
        };
      }

      function getDerivedValue() {
        let values = [];

        for (const [_, {
          value
        }] of subjects) {
          values.push(value);
        }

        return callback(values);
      }

      async function notify() {
        await tick();
        const value = getDerivedValue();

        for (const listener of listeners) {
          listener(value);
        }
      }

      function push(subject) {
        const value = get_store_value(subject);
        const sub = subject.subscribe(nextValue => {
          if (subjects.has(subject)) {
            subjects.get(subject).value = nextValue;
            notify();
          }
        });
        subjects.set(subject, {
          sub,
          value
        });
        notify();
      }

      function remove(subject) {
        subjects.get(subject).sub();
        subjects.delete(subject);
        notify();
      }

      return {
        subscribe,
        push,
        remove
      };
    }

    const identity$1 = _ => _;

    const CONTEXT_ROUTER_KEY = '__router';
    const CONTEXT_DEPTH_KEY = '__router_depth';
    const CONTEXT_RENDER_UNLOCKED = '__render_unlocked';
    function createRouter(basePath = '/') {
      let routes = [];
      createBasePath(basePath);
      setContext(CONTEXT_DEPTH_KEY, 0);
      setContext(CONTEXT_ROUTER_KEY, {
        getRoutes: () => routes,

        add(route) {
          routes = [...routes, route];
        },

        remove(route) {
          routes = routes.filter(({
            path
          }) => path !== route.path);
        }

      });
      setContext(CONTEXT_RENDER_UNLOCKED, readable(true));
    }
    function createLayout() {
      const parentContext = getContext(CONTEXT_ROUTER_KEY);
      let isAnyMatch = writable(false);
      const dynamicSubjects = dynamicDerived($subjects => $subjects.reduce((acc, next) => acc || !!next, false));
      const unsubscribe = dynamicSubjects.subscribe(_isAnyMatch => {
        isAnyMatch.set(_isAnyMatch);
      });
      setContext(CONTEXT_ROUTER_KEY, {
        getRoutes: parentContext.getRoutes,

        add(route) {
          parentContext.add(route);
          dynamicSubjects.push(route.subject);
        },

        remove(route) {
          parentContext.remove(route);
          dynamicSubjects.remove(route.subject);
        }

      });
      setContext(CONTEXT_RENDER_UNLOCKED, isAnyMatch);
      onDestroy(() => unsubscribe());
      return isAnyMatch;
    }
    function getDepth() {
      const currentDepth = getContext(CONTEXT_DEPTH_KEY) + 1;
      setContext(CONTEXT_DEPTH_KEY, currentDepth);
      return currentDepth;
    }
    function createRoute({
      path,
      exact,
      depth
    }) {
      const isProtected = getProtected();
      const isRenderUnlocked = getContext(CONTEXT_RENDER_UNLOCKED);
      const context = getContext(CONTEXT_ROUTER_KEY);
      const {
        currentPath
      } = getHistory();
      const subject = derived([isProtected, currentPath], ([$isProtected, $currentPath]) => $isProtected && matchPath($currentPath, {
        path,
        exact
      }));
      const routeData = {
        path,
        exact,
        isProtected,
        depth,
        subject
      };
      context.add(routeData);
      onDestroy(() => context.remove(routeData));
      return [subject, isRenderUnlocked];
    }
    function createRedirect({
      from,
      to,
      exact,
      depth
    }) {
      const isProtected = getProtected();
      const context = getContext(CONTEXT_ROUTER_KEY);
      const {
        push,
        replace,
        currentPath
      } = getHistory();
      const unsubscribe = derived([isProtected, currentPath], identity$1).subscribe(async ([$isProtected, $currentPath]) => {
        await tick();
        const routes = context.getRoutes();
        const isFromMatch = matchPath($currentPath, {
          path: from,
          exact
        });
        const isSomeMatch = routes.some(route => {
          return get_store_value(route.isProtected) && matchPath($currentPath, route) && route.depth === depth;
        });

        if ($isProtected && !isSomeMatch && isFromMatch) {
          (from !== '*' ? replace : push)(to);
        }
      });
      onDestroy(unsubscribe);
    }
    function createFallback() {
      const context = getContext(CONTEXT_ROUTER_KEY);
      const isFallback = writable(false);
      const {
        currentPath
      } = getHistory();
      const unsubscribe = currentPath.subscribe(async $history => {
        await tick();
        const routes = context.getRoutes();
        const nextFallback = !routes.some(route => get_store_value(route.isProtected) && matchPath($history, route));
        isFallback.set(nextFallback);
      });
      onDestroy(unsubscribe);
      return isFallback;
    }

    function fragment(node) {
      node.parentElement.appendChild(node.content);
      node.setAttribute('style', 'display: none;');
      return {
        destroy() {
          if (node && node.parentElement) {
            node.parentElement.removeChild(node.content);
          }
        }

      };
    }

    /* node_modules/swheel/src/Router/BaseRouter.svelte generated by Svelte v3.41.0 */
    const file$19 = "node_modules/swheel/src/Router/BaseRouter.svelte";

    function create_fragment$1q(ctx) {
    	let object;
    	let links_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			object = element("object");
    			if (default_slot) default_slot.c();
    			attr_dev(object, "aria-label", "__links_" + /*mId*/ ctx[1]);
    			add_location(object, file$19, 29, 0, 616);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, object, anchor);

    			if (default_slot) {
    				default_slot.m(object, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(links_action = links.call(null, object, { history: /*history*/ ctx[0] }));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (links_action && is_function(links_action.update) && dirty & /*history*/ 1) links_action.update.call(null, { history: /*history*/ ctx[0] });
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(object);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let id = 0;
    const cachedHistory = new Map();

    function getHistoryById(historyId) {
    	return cachedHistory.get(historyId);
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BaseRouter', slots, ['default']);
    	let { history } = $$props;
    	createRouter();
    	createProtection();
    	const mId = id++;
    	cachedHistory.set(mId, history);

    	onDestroy(() => {
    		cachedHistory.delete(mId);
    	});

    	const writable_props = ['history'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BaseRouter> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('history' in $$props) $$invalidate(0, history = $$props.history);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		id,
    		cachedHistory,
    		getHistoryById,
    		onDestroy,
    		links,
    		createProtection,
    		createRouter,
    		fragment,
    		history,
    		mId
    	});

    	$$self.$inject_state = $$props => {
    		if ('history' in $$props) $$invalidate(0, history = $$props.history);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [history, mId, $$scope, slots];
    }

    class BaseRouter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1q, safe_not_equal, { history: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BaseRouter",
    			options,
    			id: create_fragment$1q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*history*/ ctx[0] === undefined && !('history' in props)) {
    			console.warn("<BaseRouter> was created without expected prop 'history'");
    		}
    	}

    	get history() {
    		throw new Error("<BaseRouter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set history(value) {
    		throw new Error("<BaseRouter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/swheel/src/Router/BrowserRouter.svelte generated by Svelte v3.41.0 */

    // (7:0) <BaseRouter {history}>
    function create_default_slot$a(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(7:0) <BaseRouter {history}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1p(ctx) {
    	let baserouter;
    	let current;

    	baserouter = new BaseRouter({
    			props: {
    				history: /*history*/ ctx[0],
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(baserouter.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(baserouter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const baserouter_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				baserouter_changes.$$scope = { dirty, ctx };
    			}

    			baserouter.$set(baserouter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(baserouter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(baserouter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(baserouter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BrowserRouter', slots, ['default']);
    	const history = createBrowserHistory();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BrowserRouter> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		BaseRouter,
    		createBrowserHistory,
    		history
    	});

    	return [history, slots, $$scope];
    }

    class BrowserRouter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BrowserRouter",
    			options,
    			id: create_fragment$1p.name
    		});
    	}
    }

    const cache = new Map();

    function createThrottling(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function getPromiseFromCache(component, throttle) {
      if (!cache.has(component)) {
        const promise = Promise.all([component(), createThrottling(throttle)]).then(([loadedComponent]) => loadedComponent);
        cache.set(component, promise);
      }

      return cache.get(component);
    }

    /* node_modules/swheel/src/Router/Lazy.svelte generated by Svelte v3.41.0 */
    const get_catch_slot_changes$2 = dirty => ({});
    const get_catch_slot_context$2 = ctx => ({});
    const get_pending_slot_changes$2 = dirty => ({});
    const get_pending_slot_context$2 = ctx => ({});

    // (15:0) {:catch}
    function create_catch_block(ctx) {
    	let current;
    	const catch_slot_template = /*#slots*/ ctx[5].catch;
    	const catch_slot = create_slot(catch_slot_template, ctx, /*$$scope*/ ctx[4], get_catch_slot_context$2);

    	const block = {
    		c: function create() {
    			if (catch_slot) catch_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (catch_slot) {
    				catch_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (catch_slot) {
    				if (catch_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						catch_slot,
    						catch_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(catch_slot_template, /*$$scope*/ ctx[4], dirty, get_catch_slot_changes$2),
    						get_catch_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(catch_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(catch_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (catch_slot) catch_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(15:0) {:catch}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {:then loadedComponent}
    function create_then_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*data*/ ctx[0]];
    	var switch_value = /*loadedComponent*/ ctx[6].default;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*data*/ 1)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*data*/ ctx[0])])
    			: {};

    			if (switch_value !== (switch_value = /*loadedComponent*/ ctx[6].default)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(13:0) {:then loadedComponent}",
    		ctx
    	});

    	return block;
    }

    // (11:16)    <slot name="pending" /> {:then loadedComponent}
    function create_pending_block(ctx) {
    	let current;
    	const pending_slot_template = /*#slots*/ ctx[5].pending;
    	const pending_slot = create_slot(pending_slot_template, ctx, /*$$scope*/ ctx[4], get_pending_slot_context$2);

    	const block = {
    		c: function create() {
    			if (pending_slot) pending_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (pending_slot) {
    				pending_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (pending_slot) {
    				if (pending_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						pending_slot,
    						pending_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(pending_slot_template, /*$$scope*/ ctx[4], dirty, get_pending_slot_changes$2),
    						get_pending_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pending_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pending_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (pending_slot) pending_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(11:16)    <slot name=\\\"pending\\\" /> {:then loadedComponent}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1o(ctx) {
    	let await_block_anchor;
    	let promise_1;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 6,
    		blocks: [,,,]
    	};

    	handle_promise(promise_1 = /*promise*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*promise*/ 2 && promise_1 !== (promise_1 = /*promise*/ ctx[1]) && handle_promise(promise_1, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let promise;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lazy', slots, ['pending','catch']);
    	let { component } = $$props;
    	let { throttle } = $$props;
    	let { data = {} } = $$props;
    	const writable_props = ['component', 'throttle', 'data'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lazy> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('component' in $$props) $$invalidate(2, component = $$props.component);
    		if ('throttle' in $$props) $$invalidate(3, throttle = $$props.throttle);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getPromiseFromCache,
    		component,
    		throttle,
    		data,
    		promise
    	});

    	$$self.$inject_state = $$props => {
    		if ('component' in $$props) $$invalidate(2, component = $$props.component);
    		if ('throttle' in $$props) $$invalidate(3, throttle = $$props.throttle);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('promise' in $$props) $$invalidate(1, promise = $$props.promise);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*component, throttle*/ 12) {
    			$$invalidate(1, promise = getPromiseFromCache(component, throttle));
    		}
    	};

    	return [data, promise, component, throttle, $$scope, slots];
    }

    class Lazy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1o, safe_not_equal, { component: 2, throttle: 3, data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lazy",
    			options,
    			id: create_fragment$1o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*component*/ ctx[2] === undefined && !('component' in props)) {
    			console.warn("<Lazy> was created without expected prop 'component'");
    		}

    		if (/*throttle*/ ctx[3] === undefined && !('throttle' in props)) {
    			console.warn("<Lazy> was created without expected prop 'throttle'");
    		}
    	}

    	get component() {
    		throw new Error("<Lazy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Lazy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get throttle() {
    		throw new Error("<Lazy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set throttle(value) {
    		throw new Error("<Lazy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Lazy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Lazy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/swheel/src/Router/Route.svelte generated by Svelte v3.41.0 */
    const file$18 = "node_modules/swheel/src/Router/Route.svelte";
    const get_default_slot_changes$3 = dirty => ({ params: dirty & /*$match*/ 16 });
    const get_default_slot_context$3 = ctx => ({ params: /*$match*/ ctx[4].params });
    const get_pending_slot_changes$1 = dirty => ({ params: dirty & /*$match*/ 16 });
    const get_pending_slot_context$1 = ctx => ({ params: /*$match*/ ctx[4].params });
    const get_catch_slot_changes$1 = dirty => ({ params: dirty & /*$match*/ 16 });
    const get_catch_slot_context$1 = ctx => ({ params: /*$match*/ ctx[4].params });

    // (27:0) {#if $match && when && $isRenderUnlocked}
    function create_if_block$B(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$h, create_if_block_2$d, create_else_block$j];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (typeof /*lazy*/ ctx[0] === 'function') return 0;
    		if (!!/*component*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(27:0) {#if $match && when && $isRenderUnlocked}",
    		ctx
    	});

    	return block;
    }

    // (39:2) {:else}
    function create_else_block$j(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], get_default_slot_context$3);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, $match*/ 2064)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, get_default_slot_changes$3),
    						get_default_slot_context$3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(39:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:24) 
    function create_if_block_2$d(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*$match*/ ctx[4].params];
    	var switch_value = /*component*/ ctx[1];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$match*/ 16)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$match*/ ctx[4].params)])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(37:24) ",
    		ctx
    	});

    	return block;
    }

    // (28:2) {#if typeof lazy === 'function'}
    function create_if_block_1$h(ctx) {
    	let lazy_1;
    	let current;

    	lazy_1 = new Lazy({
    			props: {
    				component: /*lazy*/ ctx[0],
    				throttle: /*throttle*/ ctx[2],
    				data: /*$match*/ ctx[4].params,
    				$$slots: {
    					catch: [create_catch_slot$1],
    					pending: [create_pending_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lazy_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lazy_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lazy_1_changes = {};
    			if (dirty & /*lazy*/ 1) lazy_1_changes.component = /*lazy*/ ctx[0];
    			if (dirty & /*throttle*/ 4) lazy_1_changes.throttle = /*throttle*/ ctx[2];
    			if (dirty & /*$match*/ 16) lazy_1_changes.data = /*$match*/ ctx[4].params;

    			if (dirty & /*$$scope, $match*/ 2064) {
    				lazy_1_changes.$$scope = { dirty, ctx };
    			}

    			lazy_1.$set(lazy_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lazy_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lazy_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lazy_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(28:2) {#if typeof lazy === 'function'}",
    		ctx
    	});

    	return block;
    }

    // (30:6) 
    function create_pending_slot$1(ctx) {
    	let template;
    	let current;
    	let mounted;
    	let dispose;
    	const pending_slot_template = /*#slots*/ ctx[10].pending;
    	const pending_slot = create_slot(pending_slot_template, ctx, /*$$scope*/ ctx[11], get_pending_slot_context$1);

    	const block = {
    		c: function create() {
    			template = element("template");
    			if (pending_slot) pending_slot.c();
    			attr_dev(template, "slot", "pending");
    			add_location(template, file$18, 29, 6, 796);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, template, anchor);

    			if (pending_slot) {
    				pending_slot.m(template.content, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(fragment.call(null, template));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (pending_slot) {
    				if (pending_slot.p && (!current || dirty & /*$$scope, $match*/ 2064)) {
    					update_slot_base(
    						pending_slot,
    						pending_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(pending_slot_template, /*$$scope*/ ctx[11], dirty, get_pending_slot_changes$1),
    						get_pending_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pending_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pending_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(template);
    			if (pending_slot) pending_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_slot$1.name,
    		type: "slot",
    		source: "(30:6) ",
    		ctx
    	});

    	return block;
    }

    // (33:6) 
    function create_catch_slot$1(ctx) {
    	let template;
    	let current;
    	let mounted;
    	let dispose;
    	const catch_slot_template = /*#slots*/ ctx[10].catch;
    	const catch_slot = create_slot(catch_slot_template, ctx, /*$$scope*/ ctx[11], get_catch_slot_context$1);

    	const block = {
    		c: function create() {
    			template = element("template");
    			if (catch_slot) catch_slot.c();
    			attr_dev(template, "slot", "catch");
    			add_location(template, file$18, 32, 6, 891);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, template, anchor);

    			if (catch_slot) {
    				catch_slot.m(template.content, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(fragment.call(null, template));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (catch_slot) {
    				if (catch_slot.p && (!current || dirty & /*$$scope, $match*/ 2064)) {
    					update_slot_base(
    						catch_slot,
    						catch_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(catch_slot_template, /*$$scope*/ ctx[11], dirty, get_catch_slot_changes$1),
    						get_catch_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(catch_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(catch_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(template);
    			if (catch_slot) catch_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_slot$1.name,
    		type: "slot",
    		source: "(33:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$match*/ ctx[4] && /*when*/ ctx[3] && /*$isRenderUnlocked*/ ctx[5] && create_if_block$B(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$match*/ ctx[4] && /*when*/ ctx[3] && /*$isRenderUnlocked*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$match, when, $isRenderUnlocked*/ 56) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$B(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let $match;
    	let $isRenderUnlocked;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Route', slots, ['catch','pending','default']);
    	let { path } = $$props;
    	let { lazy = null } = $$props;
    	let { component = null } = $$props;
    	let { throttle = 0 } = $$props;
    	let { exact = false } = $$props;
    	let { when = true } = $$props;
    	const depth = getDepth();
    	const routePath = getBasePath() + path;
    	createBasePath(routePath);
    	const [match, isRenderUnlocked] = createRoute({ path: routePath, exact, depth });
    	validate_store(match, 'match');
    	component_subscribe($$self, match, value => $$invalidate(4, $match = value));
    	validate_store(isRenderUnlocked, 'isRenderUnlocked');
    	component_subscribe($$self, isRenderUnlocked, value => $$invalidate(5, $isRenderUnlocked = value));
    	const writable_props = ['path', 'lazy', 'component', 'throttle', 'exact', 'when'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Route> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('path' in $$props) $$invalidate(8, path = $$props.path);
    		if ('lazy' in $$props) $$invalidate(0, lazy = $$props.lazy);
    		if ('component' in $$props) $$invalidate(1, component = $$props.component);
    		if ('throttle' in $$props) $$invalidate(2, throttle = $$props.throttle);
    		if ('exact' in $$props) $$invalidate(9, exact = $$props.exact);
    		if ('when' in $$props) $$invalidate(3, when = $$props.when);
    		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getProtected,
    		createRoute,
    		getDepth,
    		createBasePath,
    		getBasePath,
    		fragment,
    		Lazy,
    		path,
    		lazy,
    		component,
    		throttle,
    		exact,
    		when,
    		depth,
    		routePath,
    		match,
    		isRenderUnlocked,
    		$match,
    		$isRenderUnlocked
    	});

    	$$self.$inject_state = $$props => {
    		if ('path' in $$props) $$invalidate(8, path = $$props.path);
    		if ('lazy' in $$props) $$invalidate(0, lazy = $$props.lazy);
    		if ('component' in $$props) $$invalidate(1, component = $$props.component);
    		if ('throttle' in $$props) $$invalidate(2, throttle = $$props.throttle);
    		if ('exact' in $$props) $$invalidate(9, exact = $$props.exact);
    		if ('when' in $$props) $$invalidate(3, when = $$props.when);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		lazy,
    		component,
    		throttle,
    		when,
    		$match,
    		$isRenderUnlocked,
    		match,
    		isRenderUnlocked,
    		path,
    		exact,
    		slots,
    		$$scope
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1q, create_fragment$1n, safe_not_equal, {
    			path: 8,
    			lazy: 0,
    			component: 1,
    			throttle: 2,
    			exact: 9,
    			when: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$1n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*path*/ ctx[8] === undefined && !('path' in props)) {
    			console.warn("<Route> was created without expected prop 'path'");
    		}
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lazy() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lazy(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get throttle() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set throttle(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exact() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exact(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get when() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set when(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/swheel/src/Router/Redirect.svelte generated by Svelte v3.41.0 */

    function create_fragment$1m(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Redirect', slots, []);
    	let { exact = false } = $$props;
    	let { from = '*' } = $$props;
    	let { to } = $$props;
    	const basePath = getBasePath();
    	const depth = getDepth();

    	if (basePath && from === '*') {
    		from = basePath;
    	} else if (from === '*') {
    		from = '*';
    	}

    	createRedirect({
    		from,
    		to: getBasePath() + to,
    		exact,
    		depth
    	});

    	const writable_props = ['exact', 'from', 'to'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Redirect> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('exact' in $$props) $$invalidate(1, exact = $$props.exact);
    		if ('from' in $$props) $$invalidate(0, from = $$props.from);
    		if ('to' in $$props) $$invalidate(2, to = $$props.to);
    	};

    	$$self.$capture_state = () => ({
    		createRedirect,
    		getDepth,
    		getBasePath,
    		exact,
    		from,
    		to,
    		basePath,
    		depth
    	});

    	$$self.$inject_state = $$props => {
    		if ('exact' in $$props) $$invalidate(1, exact = $$props.exact);
    		if ('from' in $$props) $$invalidate(0, from = $$props.from);
    		if ('to' in $$props) $$invalidate(2, to = $$props.to);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [from, exact, to];
    }

    class Redirect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1m, safe_not_equal, { exact: 1, from: 0, to: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Redirect",
    			options,
    			id: create_fragment$1m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*to*/ ctx[2] === undefined && !('to' in props)) {
    			console.warn("<Redirect> was created without expected prop 'to'");
    		}
    	}

    	get exact() {
    		throw new Error("<Redirect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exact(value) {
    		throw new Error("<Redirect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get from() {
    		throw new Error("<Redirect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set from(value) {
    		throw new Error("<Redirect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get to() {
    		throw new Error("<Redirect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Redirect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/swheel/src/Router/Protected.svelte generated by Svelte v3.41.0 */

    function create_fragment$1l(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let $isProtected;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Protected', slots, ['default']);
    	let { when } = $$props;
    	const isProtected = createLocalProtection(when);
    	validate_store(isProtected, 'isProtected');
    	component_subscribe($$self, isProtected, value => $$invalidate(4, $isProtected = value));

    	afterUpdate(() => {
    		set_store_value(isProtected, $isProtected = when, $isProtected);
    	});

    	const writable_props = ['when'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Protected> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('when' in $$props) $$invalidate(1, when = $$props.when);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		createLocalProtection,
    		when,
    		isProtected,
    		$isProtected
    	});

    	$$self.$inject_state = $$props => {
    		if ('when' in $$props) $$invalidate(1, when = $$props.when);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isProtected, when, $$scope, slots];
    }

    class Protected extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1l, safe_not_equal, { when: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Protected",
    			options,
    			id: create_fragment$1l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*when*/ ctx[1] === undefined && !('when' in props)) {
    			console.warn("<Protected> was created without expected prop 'when'");
    		}
    	}

    	get when() {
    		throw new Error("<Protected>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set when(value) {
    		throw new Error("<Protected>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/swheel/src/Router/Fallback.svelte generated by Svelte v3.41.0 */
    const file$17 = "node_modules/swheel/src/Router/Fallback.svelte";
    const get_pending_slot_changes = dirty => ({});
    const get_pending_slot_context = ctx => ({});
    const get_catch_slot_changes = dirty => ({});
    const get_catch_slot_context = ctx => ({});

    // (14:0) {#if $isFallback}
    function create_if_block$A(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$g, create_if_block_2$c, create_else_block$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*lazy*/ ctx[0]) return 0;
    		if (!!/*component*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(14:0) {#if $isFallback}",
    		ctx
    	});

    	return block;
    }

    // (26:2) {:else}
    function create_else_block$i(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(26:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (24:24) 
    function create_if_block_2$c(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[1];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*component*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(24:24) ",
    		ctx
    	});

    	return block;
    }

    // (15:2) {#if lazy}
    function create_if_block_1$g(ctx) {
    	let lazy_1;
    	let current;

    	lazy_1 = new Lazy({
    			props: {
    				component: /*lazy*/ ctx[0],
    				throttle: /*throttle*/ ctx[2],
    				$$slots: {
    					catch: [create_catch_slot],
    					pending: [create_pending_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(lazy_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lazy_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lazy_1_changes = {};
    			if (dirty & /*lazy*/ 1) lazy_1_changes.component = /*lazy*/ ctx[0];
    			if (dirty & /*throttle*/ 4) lazy_1_changes.throttle = /*throttle*/ ctx[2];

    			if (dirty & /*$$scope*/ 64) {
    				lazy_1_changes.$$scope = { dirty, ctx };
    			}

    			lazy_1.$set(lazy_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lazy_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lazy_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lazy_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(15:2) {#if lazy}",
    		ctx
    	});

    	return block;
    }

    // (17:6) 
    function create_pending_slot(ctx) {
    	let template;
    	let current;
    	let mounted;
    	let dispose;
    	const pending_slot_template = /*#slots*/ ctx[5].pending;
    	const pending_slot = create_slot(pending_slot_template, ctx, /*$$scope*/ ctx[6], get_pending_slot_context);

    	const block = {
    		c: function create() {
    			template = element("template");
    			if (pending_slot) pending_slot.c();
    			attr_dev(template, "slot", "pending");
    			add_location(template, file$17, 16, 6, 401);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, template, anchor);

    			if (pending_slot) {
    				pending_slot.m(template.content, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(fragment.call(null, template));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (pending_slot) {
    				if (pending_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						pending_slot,
    						pending_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(pending_slot_template, /*$$scope*/ ctx[6], dirty, get_pending_slot_changes),
    						get_pending_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pending_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pending_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(template);
    			if (pending_slot) pending_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_slot.name,
    		type: "slot",
    		source: "(17:6) ",
    		ctx
    	});

    	return block;
    }

    // (20:6) 
    function create_catch_slot(ctx) {
    	let template;
    	let current;
    	let mounted;
    	let dispose;
    	const catch_slot_template = /*#slots*/ ctx[5].catch;
    	const catch_slot = create_slot(catch_slot_template, ctx, /*$$scope*/ ctx[6], get_catch_slot_context);

    	const block = {
    		c: function create() {
    			template = element("template");
    			if (catch_slot) catch_slot.c();
    			attr_dev(template, "slot", "catch");
    			add_location(template, file$17, 19, 6, 496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, template, anchor);

    			if (catch_slot) {
    				catch_slot.m(template.content, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(fragment.call(null, template));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (catch_slot) {
    				if (catch_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						catch_slot,
    						catch_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(catch_slot_template, /*$$scope*/ ctx[6], dirty, get_catch_slot_changes),
    						get_catch_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(catch_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(catch_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(template);
    			if (catch_slot) catch_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_slot.name,
    		type: "slot",
    		source: "(20:6) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$isFallback*/ ctx[3] && create_if_block$A(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$isFallback*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isFallback*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$A(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let $isFallback;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fallback', slots, ['catch','pending','default']);
    	let { lazy = null } = $$props;
    	let { component = null } = $$props;
    	let { throttle = 0 } = $$props;
    	const isFallback = createFallback();
    	validate_store(isFallback, 'isFallback');
    	component_subscribe($$self, isFallback, value => $$invalidate(3, $isFallback = value));
    	const writable_props = ['lazy', 'component', 'throttle'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Fallback> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lazy' in $$props) $$invalidate(0, lazy = $$props.lazy);
    		if ('component' in $$props) $$invalidate(1, component = $$props.component);
    		if ('throttle' in $$props) $$invalidate(2, throttle = $$props.throttle);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Route,
    		Lazy,
    		createFallback,
    		fragment,
    		lazy,
    		component,
    		throttle,
    		isFallback,
    		$isFallback
    	});

    	$$self.$inject_state = $$props => {
    		if ('lazy' in $$props) $$invalidate(0, lazy = $$props.lazy);
    		if ('component' in $$props) $$invalidate(1, component = $$props.component);
    		if ('throttle' in $$props) $$invalidate(2, throttle = $$props.throttle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [lazy, component, throttle, $isFallback, isFallback, slots, $$scope];
    }

    class Fallback extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1k, safe_not_equal, { lazy: 0, component: 1, throttle: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fallback",
    			options,
    			id: create_fragment$1k.name
    		});
    	}

    	get lazy() {
    		throw new Error("<Fallback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lazy(value) {
    		throw new Error("<Fallback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Fallback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Fallback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get throttle() {
    		throw new Error("<Fallback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set throttle(value) {
    		throw new Error("<Fallback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/swheel/src/Router/Layout.svelte generated by Svelte v3.41.0 */

    // (18:2) {:else}
    function create_else_block$h(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(18:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:2) {#if $isAnyMatch}
    function create_if_block$z(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(14:2) {#if $isAnyMatch}",
    		ctx
    	});

    	return block;
    }

    // (15:4) <svelte:component this={component}>
    function create_default_slot_1$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(15:4) <svelte:component this={component}>",
    		ctx
    	});

    	return block;
    }

    // (13:0) <Protected {when}>
    function create_default_slot$9(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$z, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$isAnyMatch*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(13:0) <Protected {when}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let protected_1;
    	let current;

    	protected_1 = new Protected({
    			props: {
    				when: /*when*/ ctx[1],
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(protected_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(protected_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const protected_1_changes = {};
    			if (dirty & /*when*/ 2) protected_1_changes.when = /*when*/ ctx[1];

    			if (dirty & /*$$scope, component, $isAnyMatch*/ 37) {
    				protected_1_changes.$$scope = { dirty, ctx };
    			}

    			protected_1.$set(protected_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(protected_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(protected_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(protected_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let $isAnyMatch;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Layout', slots, ['default']);
    	let { component } = $$props;
    	let { when = true } = $$props;
    	const isAnyMatch = createLayout();
    	validate_store(isAnyMatch, 'isAnyMatch');
    	component_subscribe($$self, isAnyMatch, value => $$invalidate(2, $isAnyMatch = value));
    	const writable_props = ['component', 'when'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('when' in $$props) $$invalidate(1, when = $$props.when);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		createLayout,
    		fragment,
    		Protected,
    		component,
    		when,
    		isAnyMatch,
    		$isAnyMatch
    	});

    	$$self.$inject_state = $$props => {
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('when' in $$props) $$invalidate(1, when = $$props.when);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [component, when, $isAnyMatch, isAnyMatch, slots, $$scope];
    }

    class Layout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1j, safe_not_equal, { component: 0, when: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$1j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*component*/ ctx[0] === undefined && !('component' in props)) {
    			console.warn("<Layout> was created without expected prop 'component'");
    		}
    	}

    	get component() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get when() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set when(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign$1 = function () {
      __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return __assign$1.apply(this, arguments);
    };

    var NotyfNotification = function () {
      function NotyfNotification(options) {
        this.options = options;
        this.listeners = {};
      }

      NotyfNotification.prototype.on = function (eventType, cb) {
        var callbacks = this.listeners[eventType] || [];
        this.listeners[eventType] = callbacks.concat([cb]);
      };

      NotyfNotification.prototype.triggerEvent = function (eventType, event) {
        var _this = this;

        var callbacks = this.listeners[eventType] || [];
        callbacks.forEach(function (cb) {
          return cb({
            target: _this,
            event: event
          });
        });
      };

      return NotyfNotification;
    }();

    var NotyfArrayEvent;

    (function (NotyfArrayEvent) {
      NotyfArrayEvent[NotyfArrayEvent["Add"] = 0] = "Add";
      NotyfArrayEvent[NotyfArrayEvent["Remove"] = 1] = "Remove";
    })(NotyfArrayEvent || (NotyfArrayEvent = {}));

    var NotyfArray = function () {
      function NotyfArray() {
        this.notifications = [];
      }

      NotyfArray.prototype.push = function (elem) {
        this.notifications.push(elem);
        this.updateFn(elem, NotyfArrayEvent.Add, this.notifications);
      };

      NotyfArray.prototype.splice = function (index, num) {
        var elem = this.notifications.splice(index, num)[0];
        this.updateFn(elem, NotyfArrayEvent.Remove, this.notifications);
        return elem;
      };

      NotyfArray.prototype.indexOf = function (elem) {
        return this.notifications.indexOf(elem);
      };

      NotyfArray.prototype.onUpdate = function (fn) {
        this.updateFn = fn;
      };

      return NotyfArray;
    }();

    var NotyfEvent;

    (function (NotyfEvent) {
      NotyfEvent["Dismiss"] = "dismiss";
      NotyfEvent["Click"] = "click";
    })(NotyfEvent || (NotyfEvent = {}));

    var DEFAULT_OPTIONS = {
      types: [{
        type: 'success',
        className: 'notyf__toast--success',
        backgroundColor: '#3dc763',
        icon: {
          className: 'notyf__icon--success',
          tagName: 'i'
        }
      }, {
        type: 'error',
        className: 'notyf__toast--error',
        backgroundColor: '#ed3d3d',
        icon: {
          className: 'notyf__icon--error',
          tagName: 'i'
        }
      }],
      duration: 2000,
      ripple: true,
      position: {
        x: 'right',
        y: 'bottom'
      },
      dismissible: false
    };

    var NotyfView = function () {
      function NotyfView() {
        this.notifications = [];
        this.events = {};
        this.X_POSITION_FLEX_MAP = {
          left: 'flex-start',
          center: 'center',
          right: 'flex-end'
        };
        this.Y_POSITION_FLEX_MAP = {
          top: 'flex-start',
          center: 'center',
          bottom: 'flex-end'
        }; // Creates the main notifications container

        var docFrag = document.createDocumentFragment();

        var notyfContainer = this._createHTMLElement({
          tagName: 'div',
          className: 'notyf'
        });

        docFrag.appendChild(notyfContainer);
        document.body.appendChild(docFrag);
        this.container = notyfContainer; // Identifies the main animation end event

        this.animationEndEventName = this._getAnimationEndEventName();

        this._createA11yContainer();
      }

      NotyfView.prototype.on = function (event, cb) {
        var _a;

        this.events = __assign$1(__assign$1({}, this.events), (_a = {}, _a[event] = cb, _a));
      };

      NotyfView.prototype.update = function (notification, type) {
        if (type === NotyfArrayEvent.Add) {
          this.addNotification(notification);
        } else if (type === NotyfArrayEvent.Remove) {
          this.removeNotification(notification);
        }
      };

      NotyfView.prototype.removeNotification = function (notification) {
        var _this = this;

        var renderedNotification = this._popRenderedNotification(notification);

        var node;

        if (!renderedNotification) {
          return;
        }

        node = renderedNotification.node;
        node.classList.add('notyf__toast--disappear');
        var handleEvent;
        node.addEventListener(this.animationEndEventName, handleEvent = function (event) {
          if (event.target === node) {
            node.removeEventListener(_this.animationEndEventName, handleEvent);

            _this.container.removeChild(node);
          }
        });
      };

      NotyfView.prototype.addNotification = function (notification) {
        var node = this._renderNotification(notification);

        this.notifications.push({
          notification: notification,
          node: node
        }); // For a11y purposes, we still want to announce that there's a notification in the screen
        // even if it comes with no message.

        this._announce(notification.options.message || 'Notification');
      };

      NotyfView.prototype._renderNotification = function (notification) {
        var _a;

        var card = this._buildNotificationCard(notification);

        var className = notification.options.className;

        if (className) {
          (_a = card.classList).add.apply(_a, className.split(' '));
        }

        this.container.appendChild(card);
        return card;
      };

      NotyfView.prototype._popRenderedNotification = function (notification) {
        var idx = -1;

        for (var i = 0; i < this.notifications.length && idx < 0; i++) {
          if (this.notifications[i].notification === notification) {
            idx = i;
          }
        }

        if (idx !== -1) {
          return this.notifications.splice(idx, 1)[0];
        }

        return;
      };

      NotyfView.prototype.getXPosition = function (options) {
        var _a;

        return ((_a = options === null || options === void 0 ? void 0 : options.position) === null || _a === void 0 ? void 0 : _a.x) || 'right';
      };

      NotyfView.prototype.getYPosition = function (options) {
        var _a;

        return ((_a = options === null || options === void 0 ? void 0 : options.position) === null || _a === void 0 ? void 0 : _a.y) || 'bottom';
      };

      NotyfView.prototype.adjustContainerAlignment = function (options) {
        var align = this.X_POSITION_FLEX_MAP[this.getXPosition(options)];
        var justify = this.Y_POSITION_FLEX_MAP[this.getYPosition(options)];
        var style = this.container.style;
        style.setProperty('justify-content', justify);
        style.setProperty('align-items', align);
      };

      NotyfView.prototype._buildNotificationCard = function (notification) {
        var _this = this;

        var options = notification.options;
        var iconOpts = options.icon; // Adjust container according to position (e.g. top-left, bottom-center, etc)

        this.adjustContainerAlignment(options); // Create elements

        var notificationElem = this._createHTMLElement({
          tagName: 'div',
          className: 'notyf__toast'
        });

        var ripple = this._createHTMLElement({
          tagName: 'div',
          className: 'notyf__ripple'
        });

        var wrapper = this._createHTMLElement({
          tagName: 'div',
          className: 'notyf__wrapper'
        });

        var message = this._createHTMLElement({
          tagName: 'div',
          className: 'notyf__message'
        });

        message.innerHTML = options.message || '';
        var mainColor = options.background || options.backgroundColor; // Build the icon and append it to the card

        if (iconOpts) {
          var iconContainer = this._createHTMLElement({
            tagName: 'div',
            className: 'notyf__icon'
          });

          if (typeof iconOpts === 'string' || iconOpts instanceof String) iconContainer.innerHTML = new String(iconOpts).valueOf();

          if (typeof iconOpts === 'object') {
            var _a = iconOpts.tagName,
                tagName = _a === void 0 ? 'i' : _a,
                className_1 = iconOpts.className,
                text = iconOpts.text,
                _b = iconOpts.color,
                color = _b === void 0 ? mainColor : _b;

            var iconElement = this._createHTMLElement({
              tagName: tagName,
              className: className_1,
              text: text
            });

            if (color) iconElement.style.color = color;
            iconContainer.appendChild(iconElement);
          }

          wrapper.appendChild(iconContainer);
        }

        wrapper.appendChild(message);
        notificationElem.appendChild(wrapper); // Add ripple if applicable, else just paint the full toast

        if (mainColor) {
          if (options.ripple) {
            ripple.style.background = mainColor;
            notificationElem.appendChild(ripple);
          } else {
            notificationElem.style.background = mainColor;
          }
        } // Add dismiss button


        if (options.dismissible) {
          var dismissWrapper = this._createHTMLElement({
            tagName: 'div',
            className: 'notyf__dismiss'
          });

          var dismissButton = this._createHTMLElement({
            tagName: 'button',
            className: 'notyf__dismiss-btn'
          });

          dismissWrapper.appendChild(dismissButton);
          wrapper.appendChild(dismissWrapper);
          notificationElem.classList.add("notyf__toast--dismissible");
          dismissButton.addEventListener('click', function (event) {
            var _a, _b;

            (_b = (_a = _this.events)[NotyfEvent.Dismiss]) === null || _b === void 0 ? void 0 : _b.call(_a, {
              target: notification,
              event: event
            });
            event.stopPropagation();
          });
        }

        notificationElem.addEventListener('click', function (event) {
          var _a, _b;

          return (_b = (_a = _this.events)[NotyfEvent.Click]) === null || _b === void 0 ? void 0 : _b.call(_a, {
            target: notification,
            event: event
          });
        }); // Adjust margins depending on whether its an upper or lower notification

        var className = this.getYPosition(options) === 'top' ? 'upper' : 'lower';
        notificationElem.classList.add("notyf__toast--" + className);
        return notificationElem;
      };

      NotyfView.prototype._createHTMLElement = function (_a) {
        var tagName = _a.tagName,
            className = _a.className,
            text = _a.text;
        var elem = document.createElement(tagName);

        if (className) {
          elem.className = className;
        }

        elem.textContent = text || null;
        return elem;
      };
      /**
       * Creates an invisible container which will announce the notyfs to
       * screen readers
       */


      NotyfView.prototype._createA11yContainer = function () {
        var a11yContainer = this._createHTMLElement({
          tagName: 'div',
          className: 'notyf-announcer'
        });

        a11yContainer.setAttribute('aria-atomic', 'true');
        a11yContainer.setAttribute('aria-live', 'polite'); // Set the a11y container to be visible hidden. Can't use display: none as
        // screen readers won't read it.

        a11yContainer.style.border = '0';
        a11yContainer.style.clip = 'rect(0 0 0 0)';
        a11yContainer.style.height = '1px';
        a11yContainer.style.margin = '-1px';
        a11yContainer.style.overflow = 'hidden';
        a11yContainer.style.padding = '0';
        a11yContainer.style.position = 'absolute';
        a11yContainer.style.width = '1px';
        a11yContainer.style.outline = '0';
        document.body.appendChild(a11yContainer);
        this.a11yContainer = a11yContainer;
      };
      /**
       * Announces a message to screenreaders.
       */


      NotyfView.prototype._announce = function (message) {
        var _this = this;

        this.a11yContainer.textContent = ''; // This 100ms timeout is necessary for some browser + screen-reader combinations:
        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
        //   second time without clearing and then using a non-zero delay.
        // (using JAWS 17 at time of this writing).
        // https://github.com/angular/material2/blob/master/src/cdk/a11y/live-announcer/live-announcer.ts

        setTimeout(function () {
          _this.a11yContainer.textContent = message;
        }, 100);
      };
      /**
       * Determine which animationend event is supported
       */


      NotyfView.prototype._getAnimationEndEventName = function () {
        var el = document.createElement('_fake');
        var transitions = {
          MozTransition: 'animationend',
          OTransition: 'oAnimationEnd',
          WebkitTransition: 'webkitAnimationEnd',
          transition: 'animationend'
        };
        var t;

        for (t in transitions) {
          if (el.style[t] !== undefined) {
            return transitions[t];
          }
        } // No supported animation end event. Using "animationend" as a fallback


        return 'animationend';
      };

      return NotyfView;
    }();
    /**
     * Main controller class. Defines the main Notyf API.
     */


    var Notyf = function () {
      function Notyf(opts) {
        var _this = this;

        this.dismiss = this._removeNotification;
        this.notifications = new NotyfArray();
        this.view = new NotyfView();
        var types = this.registerTypes(opts);
        this.options = __assign$1(__assign$1({}, DEFAULT_OPTIONS), opts);
        this.options.types = types;
        this.notifications.onUpdate(function (elem, type) {
          return _this.view.update(elem, type);
        });
        this.view.on(NotyfEvent.Dismiss, function (_a) {
          var target = _a.target,
              event = _a.event;

          _this._removeNotification(target); // tslint:disable-next-line: no-string-literal


          target['triggerEvent'](NotyfEvent.Dismiss, event);
        }); // tslint:disable-next-line: no-string-literal

        this.view.on(NotyfEvent.Click, function (_a) {
          var target = _a.target,
              event = _a.event;
          return target['triggerEvent'](NotyfEvent.Click, event);
        });
      }

      Notyf.prototype.error = function (payload) {
        var options = this.normalizeOptions('error', payload);
        return this.open(options);
      };

      Notyf.prototype.success = function (payload) {
        var options = this.normalizeOptions('success', payload);
        return this.open(options);
      };

      Notyf.prototype.open = function (options) {
        var defaultOpts = this.options.types.find(function (_a) {
          var type = _a.type;
          return type === options.type;
        }) || {};

        var config = __assign$1(__assign$1({}, defaultOpts), options);

        this.assignProps(['ripple', 'position', 'dismissible'], config);
        var notification = new NotyfNotification(config);

        this._pushNotification(notification);

        return notification;
      };

      Notyf.prototype.dismissAll = function () {
        while (this.notifications.splice(0, 1));
      };
      /**
       * Assigns properties to a config object based on two rules:
       * 1. If the config object already sets that prop, leave it as so
       * 2. Otherwise, use the default prop from the global options
       *
       * It's intended to build the final config object to open a notification. e.g. if
       * 'dismissible' is not set, then use the value from the global config.
       *
       * @param props - properties to be assigned to the config object
       * @param config - object whose properties need to be set
       */


      Notyf.prototype.assignProps = function (props, config) {
        var _this = this;

        props.forEach(function (prop) {
          // intentional double equality to check for both null and undefined
          config[prop] = config[prop] == null ? _this.options[prop] : config[prop];
        });
      };

      Notyf.prototype._pushNotification = function (notification) {
        var _this = this;

        this.notifications.push(notification);
        var duration = notification.options.duration !== undefined ? notification.options.duration : this.options.duration;

        if (duration) {
          setTimeout(function () {
            return _this._removeNotification(notification);
          }, duration);
        }
      };

      Notyf.prototype._removeNotification = function (notification) {
        var index = this.notifications.indexOf(notification);

        if (index !== -1) {
          this.notifications.splice(index, 1);
        }
      };

      Notyf.prototype.normalizeOptions = function (type, payload) {
        var options = {
          type: type
        };

        if (typeof payload === 'string') {
          options.message = payload;
        } else if (typeof payload === 'object') {
          options = __assign$1(__assign$1({}, options), payload);
        }

        return options;
      };

      Notyf.prototype.registerTypes = function (opts) {
        var incomingTypes = (opts && opts.types || []).slice();
        var finalDefaultTypes = DEFAULT_OPTIONS.types.map(function (defaultType) {
          // find if there's a default type within the user input's types, if so, it means the user
          // wants to change some of the default settings
          var userTypeIdx = -1;
          incomingTypes.forEach(function (t, idx) {
            if (t.type === defaultType.type) userTypeIdx = idx;
          });
          var userType = userTypeIdx !== -1 ? incomingTypes.splice(userTypeIdx, 1)[0] : {};
          return __assign$1(__assign$1({}, defaultType), userType);
        });
        return finalDefaultTypes.concat(incomingTypes);
      };

      return Notyf;
    }();

    const notyf = new Notyf({
      position: {
        x: 'center',
        y: 'top'
      }
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    createCommonjsModule(function (module) {
      /* FileSaver.js
       * A saveAs() FileSaver implementation.
       * 1.3.2
       * 2016-06-16 18:25:19
       *
       * By Eli Grey, http://eligrey.com
       * License: MIT
       *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
       */

      /*global self */

      /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

      /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
      var saveAs = saveAs || function (view) {

        if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
          return;
        }

        var doc = view.document // only get URL when necessary in case Blob.js hasn't overridden it yet
        ,
            get_URL = function () {
          return view.URL || view.webkitURL || view;
        },
            save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
            can_use_save_link = ("download" in save_link),
            click = function (node) {
          var event = new MouseEvent("click");
          node.dispatchEvent(event);
        },
            is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
            is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
            throw_outside = function (ex) {
          (view.setImmediate || view.setTimeout)(function () {
            throw ex;
          }, 0);
        },
            force_saveable_type = "application/octet-stream" // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
        ,
            arbitrary_revoke_timeout = 1000 * 40 // in ms
        ,
            revoke = function (file) {
          var revoker = function () {
            if (typeof file === "string") {
              // file is an object URL
              get_URL().revokeObjectURL(file);
            } else {
              // file is a File
              file.remove();
            }
          };

          setTimeout(revoker, arbitrary_revoke_timeout);
        },
            dispatch = function (filesaver, event_types, event) {
          event_types = [].concat(event_types);
          var i = event_types.length;

          while (i--) {
            var listener = filesaver["on" + event_types[i]];

            if (typeof listener === "function") {
              try {
                listener.call(filesaver, event || filesaver);
              } catch (ex) {
                throw_outside(ex);
              }
            }
          }
        },
            auto_bom = function (blob) {
          // prepend BOM for UTF-8 XML and text/* types (including HTML)
          // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
          if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
            return new Blob([String.fromCharCode(0xFEFF), blob], {
              type: blob.type
            });
          }

          return blob;
        },
            FileSaver = function (blob, name, no_auto_bom) {
          if (!no_auto_bom) {
            blob = auto_bom(blob);
          } // First try a.download, then web filesystem, then object URLs


          var filesaver = this,
              type = blob.type,
              force = type === force_saveable_type,
              object_url,
              dispatch_all = function () {
            dispatch(filesaver, "writestart progress write writeend".split(" "));
          } // on any filesys errors revert to saving with object URLs
          ,
              fs_error = function () {
            if ((is_chrome_ios || force && is_safari) && view.FileReader) {
              // Safari doesn't allow downloading of blob urls
              var reader = new FileReader();

              reader.onloadend = function () {
                var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                var popup = view.open(url, '_blank');
                if (!popup) view.location.href = url;
                url = undefined; // release reference before dispatching

                filesaver.readyState = filesaver.DONE;
                dispatch_all();
              };

              reader.readAsDataURL(blob);
              filesaver.readyState = filesaver.INIT;
              return;
            } // don't create more object URLs than needed


            if (!object_url) {
              object_url = get_URL().createObjectURL(blob);
            }

            if (force) {
              view.location.href = object_url;
            } else {
              var opened = view.open(object_url, "_blank");

              if (!opened) {
                // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                view.location.href = object_url;
              }
            }

            filesaver.readyState = filesaver.DONE;
            dispatch_all();
            revoke(object_url);
          };

          filesaver.readyState = filesaver.INIT;

          if (can_use_save_link) {
            object_url = get_URL().createObjectURL(blob);
            setTimeout(function () {
              save_link.href = object_url;
              save_link.download = name;
              click(save_link);
              dispatch_all();
              revoke(object_url);
              filesaver.readyState = filesaver.DONE;
            });
            return;
          }

          fs_error();
        },
            FS_proto = FileSaver.prototype,
            saveAs = function (blob, name, no_auto_bom) {
          return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
        }; // IE 10+ (native saveAs)


        if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
          return function (blob, name, no_auto_bom) {
            name = name || blob.name || "download";

            if (!no_auto_bom) {
              blob = auto_bom(blob);
            }

            return navigator.msSaveOrOpenBlob(blob, name);
          };
        }

        FS_proto.abort = function () {};

        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;
        FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
        return saveAs;
      }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || commonjsGlobal.content); // `self` is undefined in Firefox for Android content script context
      // while `this` is nsIContentFrameMessageManager
      // with an attribute `content` that corresponds to the window


      if (module.exports) {
        module.exports.saveAs = saveAs;
      }
    });

    var moment = createCommonjsModule(function (module, exports) {

      (function (global, factory) {
        module.exports = factory() ;
      })(commonjsGlobal, function () {

        var hookCallback;

        function hooks() {
          return hookCallback.apply(null, arguments);
        } // This is done to register the method called with moment()
        // without creating circular dependencies.


        function setHookCallback(callback) {
          hookCallback = callback;
        }

        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
        }

        function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
        }

        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;

            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }

            return true;
          }
        }

        function isUndefined(input) {
          return input === void 0;
        }

        function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
        }

        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }

        function map(arr, fn) {
          var res = [],
              i;

          for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
          }

          return res;
        }

        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }

          if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
          }

          return a;
        }

        function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }

        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }

          return m._pf;
        }

        var some;

        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }

            return false;
          };
        }

        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
              return i != null;
            }),
                isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }

          return m._isValid;
        }

        function createInvalid(flags) {
          var m = createUTC(NaN);

          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }

          return m;
        } // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.


        var momentProperties = hooks.momentProperties = [],
            updateInProgress = false;

        function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
          }

          if (!isUndefined(from._i)) {
            to._i = from._i;
          }

          if (!isUndefined(from._f)) {
            to._f = from._f;
          }

          if (!isUndefined(from._l)) {
            to._l = from._l;
          }

          if (!isUndefined(from._strict)) {
            to._strict = from._strict;
          }

          if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
          }

          if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
          }

          if (!isUndefined(from._offset)) {
            to._offset = from._offset;
          }

          if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
          }

          if (!isUndefined(from._locale)) {
            to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from[prop];

              if (!isUndefined(val)) {
                to[prop] = val;
              }
            }
          }

          return to;
        } // Moment prototype object


        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);

          if (!this.isValid()) {
            this._d = new Date(NaN);
          } // Prevent infinite loop in case updateOffset creates new moment
          // objects.


          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }

        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }

        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
          }
        }

        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function () {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }

            if (firstTime) {
              var args = [],
                  arg,
                  i,
                  key;

              for (i = 0; i < arguments.length; i++) {
                arg = '';

                if (typeof arguments[i] === 'object') {
                  arg += '\n[' + i + '] ';

                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ': ' + arguments[0][key] + ', ';
                    }
                  }

                  arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                  arg = arguments[i];
                }

                args.push(arg);
              }

              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
              firstTime = false;
            }

            return fn.apply(this, arguments);
          }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }

          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
          return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
        }

        function set(config) {
          var prop, i;

          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];

              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this['_' + i] = prop;
              }
            }
          }

          this._config = config; // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.

          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
        }

        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
              prop;

          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }

          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
            }
          }

          return res;
        }

        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }

        var keys;

        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function (obj) {
            var i,
                res = [];

            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }

            return res;
          };
        }

        var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        };

        function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {}; // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }

        function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;

          if (typeof callback === 'string') {
            func = function () {
              return this[callback]();
            };
          }

          if (token) {
            formatTokenFunctions[token] = func;
          }

          if (padded) {
            formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }

          if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
            };
          }
        }

        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
          }

          return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
              i,
              length;

          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }

          return function (mom) {
            var output = '',
                i;

            for (i = 0; i < length; i++) {
              output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }

            return output;
          };
        } // format date using native date object


        function formatMoment(m, format) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
          return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;

          while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }

          return format;
        }

        var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        };

        function longDateFormat(key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
            return format;
          }

          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
            if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
              return tok.slice(1);
            }

            return tok;
          }).join('');
          return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
          return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
          return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }

        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);

              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }

          return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
          var units = [],
              u;

          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({
                unit: u,
                priority: priorities[u]
              });
            }
          }

          units.sort(function (a, b) {
            return a.priority - b.priority;
          });
          return units;
        }

        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }

        function absFloor(number) {
          if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }

        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }

          return value;
        }

        function makeGetSet(unit, keepTime) {
          return function (value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }

        function get(mom, unit) {
          return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
        }

        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);

              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
          }
        } // MOMENTS


        function stringGet(units) {
          units = normalizeUnits(units);

          if (isFunction(this[units])) {
            return this[units]();
          }

          return this;
        }

        function stringSet(units, value) {
          if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;

            for (i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);

            if (isFunction(this[units])) {
              return this[units](value);
            }
          }

          return this;
        }

        var match1 = /\d/,
            //       0 - 9
        match2 = /\d\d/,
            //      00 - 99
        match3 = /\d{3}/,
            //     000 - 999
        match4 = /\d{4}/,
            //    0000 - 9999
        match6 = /[+-]?\d{6}/,
            // -999999 - 999999
        match1to2 = /\d\d?/,
            //       0 - 99
        match3to4 = /\d\d\d\d?/,
            //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/,
            //   99999 - 999999
        match1to3 = /\d{1,3}/,
            //       0 - 999
        match1to4 = /\d{1,4}/,
            //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/,
            // -999999 - 999999
        matchUnsigned = /\d+/,
            //       0 - inf
        matchSigned = /[+-]?\d+/,
            //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi,
            // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
            // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
            // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;
        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }

        function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
        } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


        function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }

        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
          var i,
              func = callback;

          if (typeof token === 'string') {
            token = [token];
          }

          if (isNumber(callback)) {
            func = function (input, array) {
              array[callback] = toInt(input);
            };
          }

          for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
          }
        }

        function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
          });
        }

        function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
          }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
          return (n % x + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function (o) {
            // I know
            var i;

            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }

            return -1;
          };
        }

        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }

          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        } // FORMATTING


        addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
        });
        addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
        });
        addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
        }); // ALIASES

        addUnitAlias('month', 'M'); // PRIORITY

        addUnitPriority('month', 8); // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
        });
        addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        }); // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
            defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
          }

          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
        }

        function localeMonthsShort(m, format) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
          }

          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
          var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();

          if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];

            for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
          }

          if (strict) {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }

        function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          } // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse


          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);

            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }

            if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            } // test the regex


            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        } // MOMENTS


        function setMonth(mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
            // No op
            return mom;
          }

          if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

              if (!isNumber(value)) {
                return mom;
              }
            }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

          return mom;
        }

        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, 'Month');
          }
        }

        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }

            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }

            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }

        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }

            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
            }

            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }

        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }

          var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;

          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
          } // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.


          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }

          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        } // FORMATTING


        addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });
        addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
        });
        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

        addUnitAlias('year', 'y'); // PRIORITIES

        addUnitPriority('year', 1); // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
        }); // HELPERS

        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        } // HOOKS


        hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        }; // MOMENTS


        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
          return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date; // the date constructor remaps years 0-99 to 1900-1999

          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);

            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }

          return date;
        }

        function createUTCDate(y) {
          var date, args; // the Date.UTC function remaps years 0-99 to 1900-1999

          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));

            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }

          return date;
        } // start-of-first-week - start-of-year


        function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
          fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }

          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }

        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }

          return {
            week: resWeek,
            year: resYear
          };
        }

        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        } // FORMATTING


        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W'); // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5); // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
        }); // HELPERS
        // LOCALES

        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 6th is the first week of the year.

        };

        function localeFirstDayOfWeek() {
          return this._week.dow;
        }

        function localeFirstDayOfYear() {
          return this._week.doy;
        } // MOMENTS


        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
        } // FORMATTING


        addFormatToken('d', 0, 'do', 'day');
        addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
        });
        addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
        });
        addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
        });
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E'); // PRIORITY

        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11); // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
        });
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
        }); // HELPERS

        function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
            return input;
          }

          if (!isNaN(input)) {
            return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);

          if (typeof input === 'number') {
            return input;
          }

          return null;
        }

        function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
          }

          return isNaN(input) ? null : input;
        } // LOCALES


        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }

        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
          var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();

          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
          }

          if (strict) {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._shortWeekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._weekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._weekdaysParse, llc);

              if (ii !== -1) {
                return ii;
              }

              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);

            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }

            if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            } // test the regex


            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        } // MOMENTS


        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
          } else {
            return day;
          }
        }

        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          } // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.


          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }

        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }

            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }

            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }

        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }

            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }

            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }

        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }

            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }

            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }

        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }

          var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;

          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.


          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
        } // FORMATTING


        function hFormat() {
          return this.hours() % 12 || 12;
        }

        function kFormat() {
          return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);
        addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });

        function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }

        meridiem('a', true);
        meridiem('A', false); // ALIASES

        addUnitAlias('hour', 'h'); // PRIORITY

        addUnitPriority('hour', 13); // PARSING

        function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);
        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        }); // LOCALES

        function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'pm' : 'PM';
          } else {
            return isLower ? 'am' : 'AM';
          }
        }

        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        }; // internal storage for locale config files

        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
          var i,
              minl = Math.min(arr1.length, arr2.length);

          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }

          return minl;
        }

        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
        } // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


        function chooseLocale(names) {
          var i = 0,
              j,
              next,
              locale,
              split;

          while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;

            while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));

              if (locale) {
                return locale;
              }

              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
              }

              j--;
            }

            i++;
          }

          return globalLocale;
        }

        function loadLocale(name) {
          var oldLocale = null,
              aliasedRequire; // TODO: Find a better way to register and load all the locales in Node

          if (locales[name] === undefined && 'object' !== 'undefined' && module && module.exports) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = commonjsRequire;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              // mark as not found to avoid repeating expensive file require call causing high CPU
              // when trying to find en-US, en_US, en-us for every format call
              locales[name] = null; // null means not found
            }
          }

          return locales[name];
        } // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.


        function getSetGlobalLocale(key, values) {
          var data;

          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }

            if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
            } else {
              if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key + ' not found. Did you forget to load it?');
              }
            }
          }

          return globalLocale._abbr;
        }

        function defineLocale(name, config) {
          if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;

            if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale = loadLocale(config.parentLocale);

                if (locale != null) {
                  parentConfig = locale._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }

                  localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                  });
                  return null;
                }
              }
            }

            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
              });
            } // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.


            getSetGlobalLocale(name);
            return locales[name];
          } else {
            // useful for testing
            delete locales[name];
            return null;
          }
        }

        function updateLocale(name, config) {
          if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
              // Update existing child locale in-place to avoid memory-leaks
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              // MERGE
              tmpLocale = loadLocale(name);

              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }

              config = mergeConfigs(parentConfig, config);

              if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
              }

              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;
            } // backwards compat for now: also set the locale


            getSetGlobalLocale(name);
          } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;

                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }

          return locales[name];
        } // returns locale data


        function getLocale(key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }

          if (!key) {
            return globalLocale;
          }

          if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);

            if (locale) {
              return locale;
            }

            key = [key];
          }

          return chooseLocale(key);
        }

        function listLocales() {
          return keys(locales);
        }

        function checkOverflow(m) {
          var overflow,
              a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }

            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }

            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
          }

          return m;
        } // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
            // iso time formats and regexes
        isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        }; // date from iso format

        function configFromISO(config) {
          var i,
              l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat;

          if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }

            if (dateFormat == null) {
              config._isValid = false;
              return;
            }

            if (match[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  // match[2] should be 'T' or space
                  timeFormat = (match[2] || ' ') + isoTimes[i][0];
                  break;
                }
              }

              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }

            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }

            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
              } else {
                config._isValid = false;
                return;
              }
            }

            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }

        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }

          return result;
        }

        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);

          if (year <= 49) {
            return 2000 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }

          return year;
        }

        function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }

          return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
          } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
          }
        } // date and time from ref 2822 format


        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
              parsedArray;

          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);

            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        } // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict


        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }

          configFromISO(config);

          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }

          configFromRFC2822(config);

          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }

          if (config._strict) {
            config._isValid = false;
          } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
          }
        }

        hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }); // Pick the first defined of two or three arguments.

        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }

          if (b != null) {
            return b;
          }

          return c;
        }

        function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());

          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }

          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        } // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]


        function configFromArray(config) {
          var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

          if (config._d) {
            return;
          }

          currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          } //if the day of the year is set, figure out what it is


          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          } // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything


          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          } // Zero out whatever was not defaulted, including time


          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          } // Check for 24:00:00.000


          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.

          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
            config._a[HOUR] = 24;
          } // check for mismatching day of week


          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }

        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;

          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).

            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);

            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;

              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;

              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              // default to beginning of week
              weekday = dow;
            }
          }

          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        } // constant that refers to the ISO standard


        hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


        hooks.RFC_2822 = function () {}; // date from string and format string


        function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }

          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }

          config._a = [];
          getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

          var string = '' + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0,
              era;
          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];

            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));

              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }

              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            } // don't parse if it's not a known token


            if (formatTokenFunctions[token]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token);
              }

              addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
            }
          } // add remaining unparsed input length to the string


          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          } // clear _12h flag if hour is <= 12


          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era

          era = getParsingFlags(config).era;

          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }

          configFromArray(config);
          checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
            // nothing to do
            return hour;
          }

          if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);

            if (isPm && hour < 12) {
              hour += 12;
            }

            if (!isPm && hour === 12) {
              hour = 0;
            }

            return hour;
          } else {
            // this is not supposed to happen
            return hour;
          }
        } // date from string and array of format strings


        function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,
              scoreToBeat,
              i,
              currentScore,
              validFormatFound,
              bestFormatIsValid = false;

          if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }

          for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);

            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }

            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
              validFormatFound = true;
            } // if there is any input that was not parsed add a penalty for that format


            currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;

                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }

          extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
          if (config._d) {
            return;
          }

          var i = normalizeObjectUnits(config._i),
              dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }

        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));

          if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
          }

          return res;
        }

        function prepareConfig(config) {
          var input = config._i,
              format = config._f;
          config._locale = config._locale || getLocale(config._l);

          if (input === null || format === undefined && input === '') {
            return createInvalid({
              nullInput: true
            });
          }

          if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format)) {
            configFromStringAndArray(config);
          } else if (format) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }

          if (!isValid(config)) {
            config._d = null;
          }

          return config;
        }

        function configFromInput(config) {
          var input = config._i;

          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};

          if (format === true || format === false) {
            strict = format;
            format = undefined;
          }

          if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
          }

          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
          } // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423


          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;
          return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
          var other = createLocal.apply(null, arguments);

          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }),
            prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
          var other = createLocal.apply(null, arguments);

          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }); // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.

        function pickBy(fn, moments) {
          var res, i;

          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }

          if (!moments.length) {
            return createLocal();
          }

          res = moments[0];

          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }

          return res;
        } // TODO: Use [].sort instead?


        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isBefore', args);
        }

        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isAfter', args);
        }

        var now = function () {
          return Date.now ? Date.now() : +new Date();
        };

        var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

        function isDurationValid(m) {
          var key,
              unitHasDecimal = false,
              i;

          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }

          for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
              }

              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }

          return true;
        }

        function isValid$1() {
          return this._isValid;
        }

        function createInvalid$1() {
          return createDuration(NaN);
        }

        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

          this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
          minutes * 6e4 + // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately

          this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.

          this._months = +months + quarters * 3 + years * 12;
          this._data = {};
          this._locale = getLocale();

          this._bubble();
        }

        function isDuration(obj) {
          return obj instanceof Duration;
        }

        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        } // compare two arrays, return the number of differences


        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;

          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }

          return diffs + lengthDiff;
        } // FORMATTING


        function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';

            if (offset < 0) {
              offset = -offset;
              sign = '-';
            }

            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
          });
        }

        offset('Z', ':');
        offset('ZZ', ''); // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        }); // HELPERS
        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']

        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
              chunk,
              parts,
              minutes;

          if (matches === null) {
            return null;
          }

          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);
          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        } // Return a moment from input, that is local/utc/zone equivalent to model.


        function cloneWithOffset(input, model) {
          var res, diff;

          if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

            res._d.setTime(res._d.valueOf() + diff);

            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }

        function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
        } // HOOKS
        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.


        hooks.updateOffset = function () {}; // MOMENTS
        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.


        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;

          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          if (input != null) {
            if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);

              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }

            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }

            this._offset = input;
            this._isUTC = true;

            if (localAdjust != null) {
              this.add(localAdjust, 'm');
            }

            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }

            return this;
          } else {
            return this._isUTC ? offset : getDateOffset(this);
          }
        }

        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== 'string') {
              input = -input;
            }

            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }

        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
            }
          }

          return this;
        }

        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);

            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }

          return this;
        }

        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }

          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }

        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }

          var c = {},
              other;
          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }

          return this._isDSTShifted;
        }

        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        } // ASP.NET json date format regex


        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
          match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};

            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

            };
          } else if (match = isoRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign)
            };
          } else if (duration == null) {
            // checks for null or undefined
            duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
          }

          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
          }

          return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

          return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

          if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
          }

          res.milliseconds = +other - +base.clone().add(res.months, 'M');
          return res;
        }

        function momentsDifference(base, other) {
          var res;

          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }

          other = cloneWithOffset(other, base);

          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }

          return res;
        } // TODO: remove 'name' arg after deprecation is removed


        function createAdder(direction, name) {
          return function (val, period) {
            var dur, tmp; //invert the arguments, but complain about it

            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val;
              val = period;
              period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
            // No op
            return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
          }

          if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }

          if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }

          if (updateOffset) {
            hooks.updateOffset(mom, days || months);
          }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
          return typeof input === 'string' || input instanceof String;
        } // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined


        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
        }

        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
              dataTypeTest = false;

          if (arrayTest) {
            dataTypeTest = input.filter(function (item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }

          return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        }

        function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = undefined;
              formats = undefined;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = undefined;
            }
          } // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.


          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse',
              output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
        }

        function clone() {
          return new Moment(this);
        }

        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);

          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }

          units = normalizeUnits(units) || 'millisecond';

          if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }

        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);

          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }

          units = normalizeUnits(units) || 'millisecond';

          if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }

        function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);

          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }

          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }

        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;

          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }

          units = normalizeUnits(units) || 'millisecond';

          if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }

        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
          var that, zoneDelta, output;

          if (!this.isValid()) {
            return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
            return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);

          switch (units) {
            case 'year':
              output = monthDiff(this, that) / 12;
              break;

            case 'month':
              output = monthDiff(this, that);
              break;

            case 'quarter':
              output = monthDiff(this, that) / 3;
              break;

            case 'second':
              output = (this - that) / 1e3;
              break;
            // 1000

            case 'minute':
              output = (this - that) / 6e4;
              break;
            // 1000 * 60

            case 'hour':
              output = (this - that) / 36e5;
              break;
            // 1000 * 60 * 60

            case 'day':
              output = (this - that - zoneDelta) / 864e5;
              break;
            // 1000 * 60 * 60 * 24, negate dst

            case 'week':
              output = (this - that - zoneDelta) / 6048e5;
              break;
            // 1000 * 60 * 60 * 24 * 7, negate dst

            default:
              output = this - that;
          }

          return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
          } // difference in months


          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
          anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2,
              adjust;

          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

            adjust = (b - anchor) / (anchor2 - anchor);
          } //check for negative zero, return zero if negative zero


          return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }

          var utc = keepOffset !== true,
              m = utc ? this.clone().utc() : this;

          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }

          if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
          }

          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */


        function inspect() {
          if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
          }

          var func = 'moment',
              zone = '',
              prefix,
              year,
              datetime,
              suffix;

          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
          }

          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }

          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }

        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }

        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        } // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.


        function locale(key) {
          var newLocaleData;

          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);

            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }

            return this;
          }
        }

        var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });

        function localeData() {
          return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }

        function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }

        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);

          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
            case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;

            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;

            case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;

            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;

            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;

            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;

            case 'hour':
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;

            case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;

            case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }

          this._d.setTime(time);

          hooks.updateOffset(this, true);
          return this;
        }

        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);

          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
            case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;

            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;

            case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;

            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;

            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;

            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;

            case 'hour':
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;

            case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;

            case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }

          this._d.setTime(time);

          hooks.updateOffset(this, true);
          return this;
        }

        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
          return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
          return new Date(this.valueOf());
        }

        function toArray() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }

        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }

        function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
          return isValid(this);
        }

        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
          return getParsingFlags(this).overflow;
        }

        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');
        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);
        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
          var era = config._locale.erasParse(input, token, config._strict);

          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);
        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
          var match;

          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }

          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });

        function localeEras(m, format) {
          var i,
              l,
              date,
              eras = this._eras || getLocale('en')._eras;

          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case 'string':
                // truncate time
                date = hooks(eras[i].since).startOf('day');
                eras[i].since = date.valueOf();
                break;
            }

            switch (typeof eras[i].until) {
              case 'undefined':
                eras[i].until = +Infinity;
                break;

              case 'string':
                // truncate time
                date = hooks(eras[i].until).startOf('day').valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }

          return eras;
        }

        function localeErasParse(eraName, format, strict) {
          var i,
              l,
              eras = this.eras(),
              name,
              abbr,
              narrow;
          eraName = eraName.toUpperCase();

          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
              switch (format) {
                case 'N':
                case 'NN':
                case 'NNN':
                  if (abbr === eraName) {
                    return eras[i];
                  }

                  break;

                case 'NNNN':
                  if (name === eraName) {
                    return eras[i];
                  }

                  break;

                case 'NNNNN':
                  if (narrow === eraName) {
                    return eras[i];
                  }

                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }

        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;

          if (year === undefined) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }

        function getEraName() {
          var i,
              l,
              val,
              eras = this.localeData().eras();

          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }

            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }

          return '';
        }

        function getEraNarrow() {
          var i,
              l,
              val,
              eras = this.localeData().eras();

          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }

            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }

          return '';
        }

        function getEraAbbr() {
          var i,
              l,
              val,
              eras = this.localeData().eras();

          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }

            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }

          return '';
        }

        function getEraYear() {
          var i,
              l,
              dir,
              val,
              eras = this.localeData().eras();

          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1; // truncate time

            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }

          return this.year();
        }

        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
          }

          return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
          }

          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
          }

          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
          var abbrPieces = [],
              namePieces = [],
              narrowPieces = [],
              mixedPieces = [],
              i,
              l,
              eras = this.eras();

          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }

          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
        } // FORMATTING


        addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1); // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
        }); // MOMENTS

        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }

        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }

        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;

          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;

          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;

          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);

            if (week > weeksTarget) {
              week = weeksTarget;
            }

            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        } // FORMATTING


        addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

        addUnitAlias('quarter', 'Q'); // PRIORITY

        addUnitPriority('quarter', 7); // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        }); // MOMENTS

        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        } // FORMATTING


        addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

        addUnitAlias('date', 'D'); // PRIORITY

        addUnitPriority('date', 9); // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        }); // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

        addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

        addUnitPriority('dayOfYear', 4); // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
        }); // HELPERS
        // MOMENTS

        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        } // FORMATTING


        addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

        addUnitAlias('minute', 'm'); // PRIORITY

        addUnitPriority('minute', 14); // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE); // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

        addUnitAlias('second', 's'); // PRIORITY

        addUnitPriority('second', 15); // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND); // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

        addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
        }); // ALIASES

        addUnitAlias('millisecond', 'ms'); // PRIORITY

        addUnitPriority('millisecond', 16); // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);
        var token, getSetMillisecond;

        for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

        function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;

        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
          };
        }

        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
        proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

        function createUnix(input) {
          return createLocal(input * 1000);
        }

        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
          return string;
        }

        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
          var locale = getLocale(),
              utc = createUTC().set(setter, index);
          return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }

          format = format || '';

          if (index != null) {
            return get$1(format, index, field, 'month');
          }

          var i,
              out = [];

          for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
          }

          return out;
        } // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)


        function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }

            format = format || '';
          } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
              index = format;
              format = undefined;
            }

            format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0,
              i,
              out = [];

          if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
          }

          for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }

          return out;
        }

        function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
          eras: [{
            since: '0001-01-01',
            until: +Infinity,
            offset: 1,
            name: 'Anno Domini',
            narrow: 'AD',
            abbr: 'AD'
          }, {
            since: '0000-12-31',
            until: -Infinity,
            offset: 1,
            name: 'Before Christ',
            narrow: 'BC',
            abbr: 'BC'
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
            var b = number % 10,
                output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
          }
        }); // Side effect imports

        hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
        hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
        var mathAbs = Math.abs;

        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }

        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        } // supports only 2.0-style add(1, 's') or add(duration)


        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        } // supports only 2.0-style subtract(1, 's') or subtract(duration)


        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }

        function bubble() {
          var milliseconds = this._milliseconds,
              days = this._days,
              months = this._months,
              data = this._data,
              seconds,
              minutes,
              hours,
              years,
              monthsFromDays; // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166

          if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
          } // The following code bubbles up values, see the tests for
          // examples of what that means.


          data.milliseconds = milliseconds % 1000;
          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;
          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;
          hours = absFloor(minutes / 60);
          data.hours = hours % 24;
          days += absFloor(hours / 24); // convert days to months

          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

          years = absFloor(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
          return this;
        }

        function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
        }

        function monthsToDays(months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
        }

        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }

          var days,
              months,
              milliseconds = this._milliseconds;
          units = normalizeUnits(units);

          if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);

            switch (units) {
              case 'month':
                return months;

              case 'quarter':
                return months / 3;

              case 'year':
                return months / 12;
            }
          } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));

            switch (units) {
              case 'week':
                return days / 7 + milliseconds / 6048e5;

              case 'day':
                return days + milliseconds / 864e5;

              case 'hour':
                return days * 24 + milliseconds / 36e5;

              case 'minute':
                return days * 1440 + milliseconds / 6e4;

              case 'second':
                return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here

              case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error('Unknown unit ' + units);
            }
          }
        } // TODO: Use this.as('ms')?


        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }

          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }

        function makeAs(alias) {
          return function () {
            return this.as(alias);
          };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
          return createDuration(this);
        }

        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
          return function () {
            return this.isValid() ? this._data[name] : NaN;
          };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
          return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11 // months to year

        }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as('s')),
              minutes = round(duration.as('m')),
              hours = round(duration.as('h')),
              days = round(duration.as('d')),
              months = round(duration.as('M')),
              weeks = round(duration.as('w')),
              years = round(duration.as('y')),
              a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];

          if (thresholds.w != null) {
            a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
          }

          a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
        } // This function allows you to set the rounding function for relative time strings


        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
            return round;
          }

          if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
          }

          return false;
        } // This function allows you to set a threshold for relative time strings


        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
            return false;
          }

          if (limit === undefined) {
            return thresholds[threshold];
          }

          thresholds[threshold] = limit;

          if (threshold === 's') {
            thresholds.ss = limit - 1;
          }

          return true;
        }

        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }

          var withSuffix = false,
              th = thresholds,
              locale,
              output;

          if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }

          if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
          }

          if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);

            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }

          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);

          if (withSuffix) {
            output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000,
              days = abs$1(this._days),
              months = abs$1(this._months),
              minutes,
              hours,
              years,
              s,
              total = this.asSeconds(),
              totalSign,
              ymSign,
              daysSign,
              hmsSign;

          if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
          } // 3600 seconds -> 60 minutes -> 1 hour


          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60; // 12 months -> 1 year

          years = absFloor(months / 12);
          months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
          return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
        }

        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
        proto$2.lang = lang; // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf'); // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
        }); //! moment.js

        hooks.version = '2.29.1';
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

        hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
          // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',
          // <input type="date" />
          TIME: 'HH:mm',
          // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',
          // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',
          // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW',
          // <input type="week" />
          MONTH: 'YYYY-MM' // <input type="month" />

        };
        return hooks;
      });
    });

    //const baseURL = 'http://localhost:3000/';
    const baseURL = ''; // const baseURL = 'https://api.snapdragonconquest.com/';
    class RESTClient {
      async get(url) {
        let result = await fetch(baseURL + url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            ...this.auth()
          }
        });

        if (result.headers.get('content-type').indexOf('application/json') == 0) {
          result = await result.json();

          if (!result.error) {
            return result;
          } else {
            notyf.error(result.error);
          }
        }
      }

      async post(url, data) {
        let result = await fetch(baseURL + url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...this.auth()
          },
          body: JSON.stringify(data)
        });
        result = await result.json();

        if (!result.error) {
          return result;
        } else {
          if (Array.isArray(result.error)) return result;else notyf.error(result.error);
        }
      }

      async delete(url) {
        let result = await fetch(baseURL + url, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            ...this.auth()
          }
        });
        result = await result.json();

        if (!result.error) {
          return result;
        } else {
          if (Array.isArray(result.error)) return result;else notyf.error(result.error);
        }
      }

      auth() {
        if (window.localStorage.getItem('token')) {
          return {
            'Authorization': 'Bearer ' + window.localStorage.getItem('token')
          };
        } else if (this.authToken) {
          return {
            'Authorization': 'Bearer ' + this.authToken
          };
        } else return {};
      }

    }

    function createModalStore() {
      const {
        subscribe,
        update
      } = writable({});
      return {
        subscribe,
        open: (component, props = {}, cb) => {
          update(u => ({
            component,
            props,
            cb
          }));
        },
        close: () => {
          update(u => ({}));
        }
      };
    }

    var Modal = createModalStore();

    /* src/components/modal/FindTeamModal.svelte generated by Svelte v3.41.0 */
    const file$16 = "src/components/modal/FindTeamModal.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (43:1) {:else}
    function create_else_block$g(ctx) {
    	let each_1_anchor;
    	let each_value = /*teams*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_1$4(ctx);
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*teamModel, teams, toast, Modal, getHistory, RegExp, query*/ 7) {
    				each_value = /*teams*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;

    				if (each_value.length) {
    					if (each_1_else) {
    						each_1_else.d(1);
    						each_1_else = null;
    					}
    				} else if (!each_1_else) {
    					each_1_else = create_else_block_1$4(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(43:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:1) {#if query.length < 3}
    function create_if_block$y(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Start typing to search";
    			add_location(p, file$16, 41, 2, 1142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(41:1) {#if query.length < 3}",
    		ctx
    	});

    	return block;
    }

    // (75:2) {:else}
    function create_else_block_1$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No team or captain found.";
    			add_location(p, file$16, 75, 3, 2271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(75:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (44:2) {#each teams as team}
    function create_each_block$f(ctx) {
    	let div6;
    	let div4;
    	let div3;
    	let div0;
    	let raw0_value = /*team*/ ctx[8].name.replace(new RegExp(/*query*/ ctx[1], "gi"), func$2) + "";
    	let t0;
    	let div1;
    	let html_tag;
    	let raw1_value = /*team*/ ctx[8].leader.first_name.replace(new RegExp(/*query*/ ctx[1], "gi"), func_1$1) + "";
    	let t1;
    	let html_tag_1;
    	let raw2_value = /*team*/ ctx[8].leader.last_name.replace(new RegExp(/*query*/ ctx[1], "gi"), func_2$1) + "";
    	let t2;
    	let div2;
    	let t3;
    	let t4_value = /*team*/ ctx[8].leader.free_fire_id + "";
    	let t4;
    	let t5;
    	let div5;
    	let a;
    	let span;
    	let t7;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*team*/ ctx[8], ...args);
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			html_tag = new HtmlTag();
    			t1 = space();
    			html_tag_1 = new HtmlTag();
    			t2 = space();
    			div2 = element("div");
    			t3 = text$1("Free Fire ID: ");
    			t4 = text$1(t4_value);
    			t5 = space();
    			div5 = element("div");
    			a = element("a");
    			span = element("span");
    			span.textContent = "add_circle_outline";
    			t7 = space();
    			attr_dev(div0, "class", "requestie-name");
    			add_location(div0, file$16, 47, 6, 1306);
    			html_tag.a = t1;
    			html_tag_1.a = null;
    			attr_dev(div1, "class", "requestie-mail");
    			add_location(div1, file$16, 50, 6, 1448);
    			attr_dev(div2, "class", "requestie-mail requestie-phone");
    			add_location(div2, file$16, 53, 6, 1702);
    			attr_dev(div3, "class", "");
    			add_location(div3, file$16, 46, 5, 1285);
    			attr_dev(div4, "class", "col-10");
    			add_location(div4, file$16, 45, 4, 1259);
    			attr_dev(span, "class", "material-icons");
    			add_location(span, file$16, 68, 6, 2157);
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "add-btn");
    			add_location(a, file$16, 59, 5, 1871);
    			attr_dev(div5, "class", "col-2 text-right");
    			add_location(div5, file$16, 58, 4, 1835);
    			attr_dev(div6, "class", "row no-gutters requestie-details svelte-l9boxh");
    			add_location(div6, file$16, 44, 3, 1208);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			html_tag.m(raw1_value, div1);
    			append_dev(div1, t1);
    			html_tag_1.m(raw2_value, div1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, t3);
    			append_dev(div2, t4);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			append_dev(div5, a);
    			append_dev(a, span);
    			append_dev(div6, t7);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*teams, query*/ 3 && raw0_value !== (raw0_value = /*team*/ ctx[8].name.replace(new RegExp(/*query*/ ctx[1], "gi"), func$2) + "")) div0.innerHTML = raw0_value;			if (dirty & /*teams, query*/ 3 && raw1_value !== (raw1_value = /*team*/ ctx[8].leader.first_name.replace(new RegExp(/*query*/ ctx[1], "gi"), func_1$1) + "")) html_tag.p(raw1_value);
    			if (dirty & /*teams, query*/ 3 && raw2_value !== (raw2_value = /*team*/ ctx[8].leader.last_name.replace(new RegExp(/*query*/ ctx[1], "gi"), func_2$1) + "")) html_tag_1.p(raw2_value);
    			if (dirty & /*teams*/ 1 && t4_value !== (t4_value = /*team*/ ctx[8].leader.free_fire_id + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(44:2) {#each teams as team}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1i(ctx) {
    	let div0;
    	let h2;
    	let t1;
    	let small;
    	let t3;
    	let div1;
    	let span;
    	let t5;
    	let form;
    	let div2;
    	let input;
    	let t6;
    	let label;
    	let t8;
    	let div3;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*query*/ ctx[1].length < 3) return create_if_block$y;
    		return create_else_block$g;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Find a team";
    			t1 = space();
    			small = element("small");
    			small.textContent = "Search for a team who is looking for players. Search using Team captains Team Name / Captain Name";
    			t3 = space();
    			div1 = element("div");
    			span = element("span");
    			span.textContent = "star_border";
    			t5 = space();
    			form = element("form");
    			div2 = element("div");
    			input = element("input");
    			t6 = space();
    			label = element("label");
    			label.textContent = "Search Team Name / Captain Name";
    			t8 = space();
    			div3 = element("div");
    			if_block.c();
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$16, 18, 1, 482);
    			attr_dev(small, "class", "request-info-txt");
    			add_location(small, file$16, 21, 1, 529);
    			attr_dev(div0, "class", "svelte-modal-header");
    			add_location(div0, file$16, 17, 0, 447);
    			attr_dev(span, "class", "material-icons svelte-l9boxh");
    			add_location(span, file$16, 26, 1, 702);
    			attr_dev(div1, "class", "bg-icon svelte-l9boxh");
    			add_location(div1, file$16, 25, 0, 679);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "text-box svelte-l9boxh");
    			attr_dev(input, "name", "name");
    			attr_dev(input, "placeholder", " ");
    			attr_dev(input, "id", "name");
    			add_location(input, file$16, 32, 2, 828);
    			attr_dev(label, "class", "lbl-txt");
    			attr_dev(label, "for", "name");
    			add_location(label, file$16, 36, 2, 986);
    			attr_dev(div2, "class", "form-group position-relative");
    			add_location(div2, file$16, 31, 1, 783);
    			attr_dev(form, "class", "mt-4");
    			add_location(form, file$16, 30, 0, 762);
    			attr_dev(div3, "class", "svelte-modal-content mt-2 svelte-l9boxh");
    			add_location(div3, file$16, 39, 0, 1076);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(div0, t1);
    			append_dev(div0, small);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, div2);
    			append_dev(div2, input);
    			set_input_value(input, /*query*/ ctx[1]);
    			append_dev(div2, t6);
    			append_dev(div2, label);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div3, anchor);
    			if_block.m(div3, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
    					listen_dev(input, "keyup", /*keyup_handler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*query*/ 2 && input.value !== /*query*/ ctx[1]) {
    				set_input_value(input, /*query*/ ctx[1]);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(form);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div3);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$2 = match => `<mark>${match}</mark>`;
    const func_1$1 = match => `<mark>${match}</mark>`;
    const func_2$1 = match => `<mark>${match}</mark>`;

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FindTeamModal', slots, []);
    	let page = 0;
    	let teamModel = Team.getInstance();
    	let teams = [];
    	let query = '';

    	const getTeams = async (fresh = true) => {
    		let newTeams = await teamModel.getPendingTeams(query, page);
    		if (fresh) $$invalidate(0, teams = newTeams); else $$invalidate(0, teams = [...teams, ...newTeams]);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FindTeamModal> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		query = this.value;
    		$$invalidate(1, query);
    	}

    	const keyup_handler = () => {
    		if (query.length > 2) getTeams();
    	};

    	const click_handler = async (team, e) => {
    		e.preventDefault();
    		let res = await teamModel.requestToJoin(team.code);

    		if (!res.error) {
    			notyf.success('Request sent!');
    			Modal.close();
    			getHistory().push('/dashboard/team');
    		}
    	};

    	$$self.$capture_state = () => ({
    		Team,
    		Modal,
    		toast: notyf,
    		getHistory,
    		page,
    		teamModel,
    		teams,
    		query,
    		getTeams
    	});

    	$$self.$inject_state = $$props => {
    		if ('page' in $$props) page = $$props.page;
    		if ('teamModel' in $$props) $$invalidate(2, teamModel = $$props.teamModel);
    		if ('teams' in $$props) $$invalidate(0, teams = $$props.teams);
    		if ('query' in $$props) $$invalidate(1, query = $$props.query);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		teams,
    		query,
    		teamModel,
    		getTeams,
    		input_input_handler,
    		keyup_handler,
    		click_handler
    	];
    }

    class FindTeamModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FindTeamModal",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* src/components/modal/InviteModal.svelte generated by Svelte v3.41.0 */
    const file$15 = "src/components/modal/InviteModal.svelte";

    function create_fragment$1h(ctx) {
    	let div0;
    	let h2;
    	let t1;
    	let small0;
    	let t3;
    	let div1;
    	let span0;
    	let t5;
    	let div5;
    	let div4;
    	let form;
    	let div2;
    	let input;
    	let t6;
    	let div3;
    	let a0;
    	let t8;
    	let small1;
    	let t10;
    	let a1;
    	let t11;
    	let span1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Join a team with invite code";
    			t1 = space();
    			small0 = element("small");
    			small0.textContent = "Input or paste your invite code below to join an exisiting team.";
    			t3 = space();
    			div1 = element("div");
    			span0 = element("span");
    			span0.textContent = "star_border";
    			t5 = space();
    			div5 = element("div");
    			div4 = element("div");
    			form = element("form");
    			div2 = element("div");
    			input = element("input");
    			t6 = space();
    			div3 = element("div");
    			a0 = element("a");
    			a0.textContent = "Join team";
    			t8 = space();
    			small1 = element("small");
    			small1.textContent = "Alternatively, you can find a team to join from the list of teams accepting players.";
    			t10 = space();
    			a1 = element("a");
    			t11 = text$1("Find a team to join\n    ");
    			span1 = element("span");
    			span1.textContent = "keyboard_arrow_right";
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$15, 18, 4, 556);
    			attr_dev(small0, "class", "request-info-txt svelte-17yg6jh");
    			add_location(small0, file$15, 21, 4, 632);
    			attr_dev(div0, "class", "svelte-modal-header svelte-17yg6jh");
    			add_location(div0, file$15, 17, 0, 518);
    			attr_dev(span0, "class", "material-icons svelte-17yg6jh");
    			add_location(span0, file$15, 26, 1, 781);
    			attr_dev(div1, "class", "bg-icon svelte-17yg6jh");
    			add_location(div1, file$15, 25, 0, 758);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", "");
    			attr_dev(input, "class", "text-box-transparent svelte-17yg6jh");
    			add_location(input, file$15, 34, 16, 968);
    			attr_dev(div2, "class", "form-group");
    			add_location(div2, file$15, 33, 12, 927);
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "btn btn-primary");
    			add_location(a0, file$15, 37, 16, 1096);
    			add_location(div3, file$15, 36, 12, 1074);
    			add_location(form, file$15, 32, 8, 908);
    			attr_dev(div4, "class", "col-12 mt-4");
    			add_location(div4, file$15, 31, 4, 874);
    			attr_dev(div5, "class", "row no-gutters");
    			add_location(div5, file$15, 30, 0, 841);
    			attr_dev(small1, "class", "request-info-txt mt-40 mb-3 d-block svelte-17yg6jh");
    			add_location(small1, file$15, 44, 0, 1257);
    			attr_dev(span1, "class", "material-icons");
    			add_location(span1, file$15, 49, 4, 1523);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "survey-link no-margin");
    			add_location(a1, file$15, 47, 0, 1407);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(div0, t1);
    			append_dev(div0, small0);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span0);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, form);
    			append_dev(form, div2);
    			append_dev(div2, input);
    			set_input_value(input, /*code*/ ctx[0]);
    			append_dev(form, t6);
    			append_dev(form, div3);
    			append_dev(div3, a0);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, small1, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, t11);
    			append_dev(a1, span1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[2]),
    					listen_dev(a0, "click", /*joinTeam*/ ctx[1], false, false, false),
    					listen_dev(a1, "click", /*click_handler*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*code*/ 1 && input.value !== /*code*/ ctx[0]) {
    				set_input_value(input, /*code*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(small1);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(a1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InviteModal', slots, []);
    	let code = '';

    	if (window.localStorage.getItem('inviteCode')) {
    		code = window.localStorage.getItem('inviteCode').toUpperCase();
    		window.localStorage.removeItem('inviteCode');
    	}

    	const joinTeam = async e => {
    		e.preventDefault();
    		let res = await Team.getInstance().requestToJoin(code);

    		if (!res.error) {
    			window.location.href = '/dashboard/team';
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InviteModal> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		code = this.value;
    		$$invalidate(0, code);
    	}

    	const click_handler = () => Modal.open(FindTeamModal);

    	$$self.$capture_state = () => ({
    		Team,
    		Modal,
    		FindTeamModal,
    		code,
    		joinTeam
    	});

    	$$self.$inject_state = $$props => {
    		if ('code' in $$props) $$invalidate(0, code = $$props.code);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [code, joinTeam, input_input_handler, click_handler];
    }

    class InviteModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InviteModal",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    const TeamStore = writable({
      name: '',
      code: ''
    });
    let instance$1j;
    class Team extends RESTClient {
      async createTeam(team) {
        let teamItem = await this.post('team', team);

        if (teamItem && !teamItem.error) {
          TeamStore.update(u => ({ ...u,
            ...teamItem
          })); //this.getTeam();

          window.location.href = '/dashboard/team';
        }

        return teamItem;
      }

      async requestToJoin(code) {
        let team = await this.post('team/join-request', {
          code
        });
        TeamStore.update(u => ({ ...u,
          ...team
        }));
        return team;
      }

      async sendInvite(emails) {
        return this.post('team/invite', {
          emails
        });
      }

      async cancelRequest() {
        let res = await this.delete('team/request');
        await this.getTeam();
        return res;
      }

      async leaveTeam() {
        let res = await this.delete('team/leave');
        await this.getTeam();
        return res;
      }

      async kickPlayer(id) {
        let res = await this.delete('team/kick/' + id);
        await this.getTeam();
        return res;
      }

      async makeLeader(id) {
        let res = await this.post('team/make-leader/' + id);
        await this.getTeam();
        return res;
      }

      async deleteTeam() {
        let res = await this.delete('team');
        await this.getTeam();
        return res;
      }

      async showTeam() {
        let res = await this.post('team/public', {
          show: true
        });
        await this.getTeam();
        return res;
      }

      async hideTeam() {
        let res = await this.post('team/public', {
          show: false
        });
        await this.getTeam();
        return res;
      }

      async getRequests() {
        await this.getTeam();
        return this.get('team/requests');
      }

      async approveRequest(request) {
        return this.get(`team/request/${request.id}/approve`);
      }

      async rejectRequest(request) {
        return this.get(`team/request/${request.id}/reject`);
      }

      async getStats() {
        return this.get('team/stats');
      }

      async downloadMatch(match) {
        return this.get(`team/download-match/${match}`);
      }

      async export() {
        return this.get('team/export');
      }

      async getTeam() {
        let team = await this.get('my-team');
        if (team) TeamStore.update(u => ({ ...u,
          ...team
        }));
        TeamStore.update(t => ({ ...t,
          loaded: true
        }));
        return team;
      }

      async getPendingTeams(query = '', page = 0) {
        return this.get('teams?query=' + query + '&page=' + page);
      }

      static getInstance() {
        if (!instance$1j) {
          instance$1j = new Team();
          instance$1j.getTeam();
        }

        return instance$1j;
      }

      static restTeam() {
        TeamStore.update(u => ({
          name: '',
          code: ''
        }));
      }

    }

    const userInit = {
      first_name: "",
      last_name: "",
      dob: "",
      mobile: "",
      free_fire_id: "",
      loggedOut: true,
      role: ''
    };
    const teamStore = Team.getInstance();

    function createUserStore() {
      const {
        subscribe,
        update,
        set
      } = writable(window.localStorage.getItem('user') ? JSON.parse(atob(window.localStorage.getItem('user'))) : { ...userInit
      });
      return {
        subscribe,
        set,
        save: user => {
          if (user.token) window.localStorage.setItem('token', user.token);
          window.localStorage.setItem('user', btoa(JSON.stringify(user)));
          update(u => user);
        },
        logout: () => {
          window.localStorage.removeItem('user');
          window.localStorage.removeItem('token');
          update(u => ({ ...userInit
          }));
          Team.restTeam();
        }
      };
    }

    const UserStore = createUserStore();
    let instance$1i;
    class User extends RESTClient {
      async getOTP(email) {
        return this.post('otp', {
          email
        });
      }

      async getToken(email, otp) {
        let data = await this.post('token', {
          email,
          otp
        });

        if (data) {
          if (data.emailtoken) {
            super.authToken = data.emailtoken;
            return {
              register: true
            };
          } else {
            if (window.localStorage.getItem('referral')) window.localStorage.removeItem('referral');
            UserStore.save(data);

            if (window.localStorage.getItem('enterContest') && !data.contest) {
              let res = await User.getInstance().enterContest();

              if (!res.error) {
                window.localStorage.removeItem('enterContest');
                window.localStorage.setItem('firstLogin', true);
                UserStore.save(res);
              }
            } else {
              window.localStorage.removeItem('enterContest');
            }

            teamStore.getTeam(); //window.localStorage.setItem('token', data.token);
            //window.localStorage.setItem('user', btoa(JSON.stringify(data)));
          }
        }

        return data;
      }

      async register(user) {
        let usr = { ...user
        };

        if (window.localStorage.getItem('referral')) {
          usr.referral = parseInt(window.localStorage.getItem('referral'));
        }

        let result = await this.post('register', usr);

        if (result.token) {
          UserStore.save(result);
          window.localStorage.removeItem('referral'); //window.localStorage.setItem('token', result.token);
          //window.localStorage.setItem('user', btoa(JSON.stringify(result)));
        }

        return result;
      }

      async update(user) {
        let result = await this.post('user/update', user);

        if (!result.error) {
          UserStore.save(result); //window.localStorage.setItem('user', btoa(JSON.stringify(result)))
        }

        return result;
      }

      async enterContest() {
        let result = await this.post('user/contest');

        if (!result.error) {
          UserStore.save(result);
          return true;
        } else {
          console.log("Failed to update");
        }
      }

      static getInstance() {
        if (!instance$1i) {
          instance$1i = new User();
        }

        return instance$1i;
      }

      static getUser() {
        return UserStore;
      }

      static logout() {
        UserStore.logout();
      }

    }

    /* src/layouts/partials/header/UserMenu.svelte generated by Svelte v3.41.0 */
    const file$14 = "src/layouts/partials/header/UserMenu.svelte";

    // (27:4) {:else}
    function create_else_block$f(ctx) {
    	let ul;
    	let li0;
    	let a0;
    	let t1;
    	let li1;
    	let a1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Go to Dashboard";
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Logout";
    			attr_dev(a0, "href", "/dashboard");
    			attr_dev(a0, "class", "");
    			add_location(a0, file$14, 29, 16, 782);
    			add_location(li0, file$14, 28, 12, 761);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "");
    			add_location(a1, file$14, 32, 16, 883);
    			add_location(li1, file$14, 31, 12, 862);
    			add_location(ul, file$14, 27, 8, 744);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			append_dev(li1, a1);

    			if (!mounted) {
    				dispose = listen_dev(a1, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(27:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (13:4) {#if $user.loggedOut}
    function create_if_block$x(ctx) {
    	let ul;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			add_location(ul, file$14, 16, 8, 453);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(13:4) {#if $user.loggedOut}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1g(ctx) {
    	let t;
    	let div;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*$user*/ ctx[2].loggedOut) return create_if_block$x;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "menu-dropdown");
    			add_location(div, file$14, 11, 0, 265);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			/*div_binding*/ ctx[6](div);

    			if (!mounted) {
    				dispose = listen_dev(document.body, "mouseup", /*mouseup_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if_block.d();
    			/*div_binding*/ ctx[6](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let $user;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UserMenu', slots, []);
    	let { onClose } = $$props;
    	let dropdownMenu;
    	const user = User.getUser();
    	validate_store(user, 'user');
    	component_subscribe($$self, user, value => $$invalidate(2, $user = value));
    	const writable_props = ['onClose'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserMenu> was created with unknown prop '${key}'`);
    	});

    	const mouseup_handler = e => {
    		if (dropdownMenu != e.target && !dropdownMenu.contains(e.target)) onClose();
    	};

    	const click_handler = e => {
    		e.preventDefault();
    		User.logout();
    		window.location.href = '/';
    	};

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			dropdownMenu = $$value;
    			$$invalidate(1, dropdownMenu);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('onClose' in $$props) $$invalidate(0, onClose = $$props.onClose);
    	};

    	$$self.$capture_state = () => ({ User, onClose, dropdownMenu, user, $user });

    	$$self.$inject_state = $$props => {
    		if ('onClose' in $$props) $$invalidate(0, onClose = $$props.onClose);
    		if ('dropdownMenu' in $$props) $$invalidate(1, dropdownMenu = $$props.dropdownMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		onClose,
    		dropdownMenu,
    		$user,
    		user,
    		mouseup_handler,
    		click_handler,
    		div_binding
    	];
    }

    class UserMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1g, safe_not_equal, { onClose: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserMenu",
    			options,
    			id: create_fragment$1g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onClose*/ ctx[0] === undefined && !('onClose' in props)) {
    			console.warn("<UserMenu> was created without expected prop 'onClose'");
    		}
    	}

    	get onClose() {
    		throw new Error("<UserMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClose(value) {
    		throw new Error("<UserMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicInOut(t) {
      return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }

    function cubicOut(t) {
      const f = t - 1.0;
      return f * f * f + 1.0;
    }

    var _$1 = {
      $(selector) {
        if (typeof selector === "string") {
          return document.querySelector(selector);
        }

        return selector;
      },

      extend(...args) {
        return Object.assign(...args);
      },

      cumulativeOffset(element) {
        let top = 0;
        let left = 0;

        do {
          top += element.offsetTop || 0;
          left += element.offsetLeft || 0;
          element = element.offsetParent;
        } while (element);

        return {
          top: top,
          left: left
        };
      },

      directScroll(element) {
        return element && element !== document && element !== document.body;
      },

      scrollTop(element, value) {
        let inSetter = value !== undefined;

        if (this.directScroll(element)) {
          return inSetter ? element.scrollTop = value : element.scrollTop;
        } else {
          return inSetter ? document.documentElement.scrollTop = document.body.scrollTop = value : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        }
      },

      scrollLeft(element, value) {
        let inSetter = value !== undefined;

        if (this.directScroll(element)) {
          return inSetter ? element.scrollLeft = value : element.scrollLeft;
        } else {
          return inSetter ? document.documentElement.scrollLeft = document.body.scrollLeft = value : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
        }
      }

    };

    const defaultOptions = {
      container: "body",
      duration: 500,
      delay: 0,
      offset: 0,
      easing: cubicInOut,
      onStart: noop,
      onDone: noop,
      onAborting: noop,
      scrollX: false,
      scrollY: true
    };

    const _scrollTo = options => {
      let {
        offset,
        duration,
        delay,
        easing,
        x = 0,
        y = 0,
        scrollX,
        scrollY,
        onStart,
        onDone,
        container,
        onAborting,
        element
      } = options;

      if (typeof offset === "function") {
        offset = offset();
      }

      var cumulativeOffsetContainer = _$1.cumulativeOffset(container);

      var cumulativeOffsetTarget = element ? _$1.cumulativeOffset(element) : {
        top: y,
        left: x
      };

      var initialX = _$1.scrollLeft(container);

      var initialY = _$1.scrollTop(container);

      var targetX = cumulativeOffsetTarget.left - cumulativeOffsetContainer.left + offset;
      var targetY = cumulativeOffsetTarget.top - cumulativeOffsetContainer.top + offset;
      var diffX = targetX - initialX;
      var diffY = targetY - initialY;
      let scrolling = true;
      let started = false;
      let start_time = now$1() + delay;
      let end_time = start_time + duration;

      function scrollToTopLeft(element, top, left) {
        if (scrollX) _$1.scrollLeft(element, left);
        if (scrollY) _$1.scrollTop(element, top);
      }

      function start(delayStart) {
        if (!delayStart) {
          started = true;
          onStart(element, {
            x,
            y
          });
        }
      }

      function tick(progress) {
        scrollToTopLeft(container, initialY + diffY * progress, initialX + diffX * progress);
      }

      function stop() {
        scrolling = false;
      }

      loop$1(now => {
        if (!started && now >= start_time) {
          start(false);
        }

        if (started && now >= end_time) {
          tick(1);
          stop();
          onDone(element, {
            x,
            y
          });
        }

        if (!scrolling) {
          onAborting(element, {
            x,
            y
          });
          return false;
        }

        if (started) {
          const p = now - start_time;
          const t = 0 + 1 * easing(p / duration);
          tick(t);
        }

        return true;
      });
      start(delay);
      tick(0);
      return stop;
    };

    const proceedOptions = options => {
      let opts = _$1.extend({}, defaultOptions, options);

      opts.container = _$1.$(opts.container);
      opts.element = _$1.$(opts.element);
      return opts;
    };
    const scrollTo = options => {
      return _scrollTo(proceedOptions(options));
    };
    const makeScrollToAction = scrollToFunc => {
      return (node, options) => {
        let current = options;

        const handle = e => {
          e.preventDefault();
          scrollToFunc(typeof current === "string" ? {
            element: current
          } : current);
        };

        node.addEventListener("click", handle);
        node.addEventListener("touchstart", handle);
        return {
          update(options) {
            current = options;
          },

          destroy() {
            node.removeEventListener("click", handle);
            node.removeEventListener("touchstart", handle);
          }

        };
      };
    };
    const scrollto = makeScrollToAction(scrollTo);

    /* src/layouts/partials/Header.svelte generated by Svelte v3.41.0 */
    const file$13 = "src/layouts/partials/Header.svelte";

    // (11:1) {#if menuMobile}
    function create_if_block$w(ctx) {
    	let style;

    	const block = {
    		c: function create() {
    			style = element("style");
    			style.textContent = "body {\n\t\t\t\toverflow: hidden;\n\t\t\t}";
    			add_location(style, file$13, 11, 2, 285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, style, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(style);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(11:1) {#if menuMobile}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1f(ctx) {
    	let if_block_anchor;
    	let t0;
    	let header;
    	let div3;
    	let button;
    	let svg;
    	let line0;
    	let line1;
    	let line2;
    	let t1;
    	let div0;
    	let a0;
    	let img;
    	let img_src_value;
    	let t2;
    	let div2;
    	let div1;
    	let ul;
    	let li0;
    	let a1;
    	let t4;
    	let li1;
    	let a2;
    	let t6;
    	let li2;
    	let a3;
    	let t8;
    	let li3;
    	let a4;
    	let mounted;
    	let dispose;
    	let if_block = /*menuMobile*/ ctx[0] && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			t0 = space();
    			header = element("header");
    			div3 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			line2 = svg_element("line");
    			t1 = space();
    			div0 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t2 = space();
    			div2 = element("div");
    			div1 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			a1.textContent = "Home";
    			t4 = space();
    			li1 = element("li");
    			a2 = element("a");
    			a2.textContent = "Teams";
    			t6 = space();
    			li2 = element("li");
    			a3 = element("a");
    			a3.textContent = "Schedule";
    			t8 = space();
    			li3 = element("li");
    			a4 = element("a");
    			a4.textContent = "Videos";
    			attr_dev(line0, "id", "top");
    			attr_dev(line0, "x1", "0");
    			attr_dev(line0, "y1", "2");
    			attr_dev(line0, "x2", "32");
    			attr_dev(line0, "y2", "2");
    			add_location(line0, file$13, 22, 4, 563);
    			attr_dev(line1, "id", "middle");
    			attr_dev(line1, "x1", "0");
    			attr_dev(line1, "y1", "12");
    			attr_dev(line1, "x2", "32");
    			attr_dev(line1, "y2", "12");
    			add_location(line1, file$13, 23, 4, 606);
    			attr_dev(line2, "id", "bottom");
    			attr_dev(line2, "x1", "0");
    			attr_dev(line2, "y1", "22");
    			attr_dev(line2, "x2", "32");
    			attr_dev(line2, "y2", "22");
    			add_location(line2, file$13, 24, 4, 653);
    			attr_dev(svg, "width", "32");
    			attr_dev(svg, "height", "24");
    			add_location(svg, file$13, 21, 3, 534);
    			attr_dev(button, "class", "menu-btn");
    			toggle_class(button, "open", /*menuMobile*/ ctx[0]);
    			add_location(button, file$13, 20, 2, 420);
    			if (!src_url_equal(img.src, img_src_value = "/images/logo-conquest-small.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo");
    			add_location(img, file$13, 34, 4, 976);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "brand-logo");
    			add_location(a0, file$13, 33, 3, 940);
    			attr_dev(div0, "class", "col-lg-7 col-sm-12 col-xs-12 menu-sec");
    			add_location(div0, file$13, 32, 2, 885);
    			attr_dev(a1, "href", "/");
    			add_location(a1, file$13, 42, 6, 1193);
    			add_location(li0, file$13, 41, 5, 1182);
    			attr_dev(a2, "href", "/teamsandstandings");
    			add_location(a2, file$13, 47, 6, 1256);
    			add_location(li1, file$13, 46, 5, 1245);
    			attr_dev(a3, "href", "/schedule");
    			add_location(a3, file$13, 52, 6, 1337);
    			add_location(li2, file$13, 51, 5, 1326);
    			attr_dev(a4, "href", "/videos");
    			add_location(a4, file$13, 57, 6, 1412);
    			add_location(li3, file$13, 56, 5, 1401);
    			attr_dev(ul, "class", "menu");
    			add_location(ul, file$13, 40, 4, 1158);
    			attr_dev(div1, "class", "menu-block");
    			toggle_class(div1, "menuopen", /*menuMobile*/ ctx[0]);
    			add_location(div1, file$13, 39, 3, 1099);
    			attr_dev(div2, "class", "col-lg-5 col-sm-4 col-xs-12");
    			add_location(div2, file$13, 38, 2, 1054);
    			attr_dev(div3, "class", "row no-gutters main-navigation svelte-1ry3jub");
    			add_location(div3, file$13, 19, 1, 373);
    			add_location(header, file$13, 18, 0, 363);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(document.head, null);
    			append_dev(document.head, if_block_anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, header, anchor);
    			append_dev(header, div3);
    			append_dev(div3, button);
    			append_dev(button, svg);
    			append_dev(svg, line0);
    			append_dev(svg, line1);
    			append_dev(svg, line2);
    			append_dev(div3, t1);
    			append_dev(div3, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a1);
    			append_dev(ul, t4);
    			append_dev(ul, li1);
    			append_dev(li1, a2);
    			append_dev(ul, t6);
    			append_dev(ul, li2);
    			append_dev(li2, a3);
    			append_dev(ul, t8);
    			append_dev(ul, li3);
    			append_dev(li3, a4);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*menuMobile*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$w(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*menuMobile*/ 1) {
    				toggle_class(button, "open", /*menuMobile*/ ctx[0]);
    			}

    			if (dirty & /*menuMobile*/ 1) {
    				toggle_class(div1, "menuopen", /*menuMobile*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			detach_dev(if_block_anchor);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(header);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Header', slots, []);
    	let { menuMobile = false } = $$props;
    	let { menuDropdown = false } = $$props;
    	let user = User.getUser();
    	const writable_props = ['menuMobile', 'menuDropdown'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(0, menuMobile = !menuMobile);
    		return false;
    	};

    	$$self.$$set = $$props => {
    		if ('menuMobile' in $$props) $$invalidate(0, menuMobile = $$props.menuMobile);
    		if ('menuDropdown' in $$props) $$invalidate(1, menuDropdown = $$props.menuDropdown);
    	};

    	$$self.$capture_state = () => ({
    		menuMobile,
    		menuDropdown,
    		User,
    		UserMenu,
    		scrollto,
    		user
    	});

    	$$self.$inject_state = $$props => {
    		if ('menuMobile' in $$props) $$invalidate(0, menuMobile = $$props.menuMobile);
    		if ('menuDropdown' in $$props) $$invalidate(1, menuDropdown = $$props.menuDropdown);
    		if ('user' in $$props) user = $$props.user;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [menuMobile, menuDropdown, click_handler];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1f, safe_not_equal, { menuMobile: 0, menuDropdown: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$1f.name
    		});
    	}

    	get menuMobile() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuMobile(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get menuDropdown() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuDropdown(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/partials/Footer.svelte generated by Svelte v3.41.0 */

    const file$12 = "src/layouts/partials/Footer.svelte";

    function create_fragment$1e(ctx) {
    	let div14;
    	let div13;
    	let div3;
    	let div1;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div2;
    	let ul0;
    	let li0;
    	let a0;
    	let img1;
    	let img1_src_value;
    	let t1;
    	let li1;
    	let a1;
    	let img2;
    	let img2_src_value;
    	let t2;
    	let li2;
    	let a2;
    	let img3;
    	let img3_src_value;
    	let t3;
    	let li3;
    	let a3;
    	let img4;
    	let img4_src_value;
    	let t4;
    	let div6;
    	let div4;
    	let ul1;
    	let li4;
    	let a4;
    	let t6;
    	let li5;
    	let a5;
    	let t8;
    	let div5;
    	let ul2;
    	let li6;
    	let a6;
    	let t10;
    	let li7;
    	let a7;
    	let t12;
    	let li8;
    	let a8;
    	let t14;
    	let div9;
    	let div8;
    	let div7;
    	let p0;
    	let t16;
    	let p1;
    	let t18;
    	let p2;
    	let t20;
    	let p3;
    	let t22;
    	let p4;
    	let t24;
    	let p5;
    	let t26;
    	let div12;
    	let div11;
    	let div10;
    	let p6;
    	let a9;
    	let t27;
    	let img5;
    	let img5_src_value;

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div13 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			img0 = element("img");
    			t0 = space();
    			div2 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			img1 = element("img");
    			t1 = space();
    			li1 = element("li");
    			a1 = element("a");
    			img2 = element("img");
    			t2 = space();
    			li2 = element("li");
    			a2 = element("a");
    			img3 = element("img");
    			t3 = space();
    			li3 = element("li");
    			a3 = element("a");
    			img4 = element("img");
    			t4 = space();
    			div6 = element("div");
    			div4 = element("div");
    			ul1 = element("ul");
    			li4 = element("li");
    			a4 = element("a");
    			a4.textContent = "About Qualcomm";
    			t6 = space();
    			li5 = element("li");
    			a5 = element("a");
    			a5.textContent = "Rulebook";
    			t8 = space();
    			div5 = element("div");
    			ul2 = element("ul");
    			li6 = element("li");
    			a6 = element("a");
    			a6.textContent = "Terms of Use";
    			t10 = space();
    			li7 = element("li");
    			a7 = element("a");
    			a7.textContent = "Privacy";
    			t12 = space();
    			li8 = element("li");
    			a8 = element("a");
    			a8.textContent = "Cookies";
    			t14 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			p0 = element("p");
    			p0.textContent = "©2021 Qualcomm Technologies, Inc. and/or its affiliated companies.";
    			t16 = space();
    			p1 = element("p");
    			p1.textContent = "The Qualcomm Snapdragon Conquest tournament is sponsored by Qualcomm Technologies, Inc. and/or its subsidiaries. Qualcomm Snapdragon is a product of Qualcomm Technologies, Inc. and or its subsidiaries";
    			t18 = space();
    			p2 = element("p");
    			p2.textContent = "References to \"Qualcomm\" may mean Qualcomm Incorporated, or subsidiaries or business units within the Qualcomm corporate structure, as applicable.";
    			t20 = space();
    			p3 = element("p");
    			p3.textContent = "Qualcomm Incorporated includes Qualcomm's licensing business, QTL, and the vast majority of its patent portfolio. Qualcomm Technologies, Inc., a wholly-owned subsidiary of Qualcomm Incorporated, operates, along with its subsidiaries, substantially all of Qualcomm's engineering, research and development functions, and substantially all of its products and services businesses. Qualcomm products referenced on this page are products of Qualcomm Technologies, Inc. and/or its subsidiaries.";
    			t22 = space();
    			p4 = element("p");
    			p4.textContent = "Materials that are as of a specific date, including but not limited to press releases, presentations, blog posts and webcasts, may have been superseded by subsequent events or disclosures.";
    			t24 = space();
    			p5 = element("p");
    			p5.textContent = "Nothing in these materials is an offer to sell any of the components or devices referenced herein.";
    			t26 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			p6 = element("p");
    			a9 = element("a");
    			t27 = text$1("Executed by \n\t\t\t\t\t\t");
    			img5 = element("img");
    			if (!src_url_equal(img0.src, img0_src_value = "/images/logo-footer.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "Logo");
    			add_location(img0, file$12, 5, 5, 151);
    			attr_dev(div0, "class", "footer-logo");
    			add_location(div0, file$12, 4, 4, 120);
    			attr_dev(div1, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div1, file$12, 3, 3, 74);
    			if (!src_url_equal(img1.src, img1_src_value = "/images/facebook.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "facebook");
    			add_location(img1, file$12, 12, 6, 388);
    			attr_dev(a0, "href", "https://www.facebook.com/snapdragonconquest/");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$12, 11, 6, 310);
    			add_location(li0, file$12, 10, 5, 299);
    			if (!src_url_equal(img2.src, img2_src_value = "/images/instagram.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "instagram");
    			add_location(img2, file$12, 17, 7, 554);
    			attr_dev(a1, "href", "https://www.instagram.com/snapdragonconquest/");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$12, 16, 6, 474);
    			add_location(li1, file$12, 15, 5, 463);
    			if (!src_url_equal(img3.src, img3_src_value = "/images/ic-twitter.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "twitter");
    			add_location(img3, file$12, 22, 6, 718);
    			attr_dev(a2, "href", "https://mobile.twitter.com/_ConquestEsport");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$12, 21, 6, 642);
    			add_location(li2, file$12, 20, 5, 631);
    			if (!src_url_equal(img4.src, img4_src_value = "/images/youtube.png")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "alt", "youtube");
    			add_location(img4, file$12, 27, 6, 895);
    			attr_dev(a3, "href", "https://www.youtube.com/channel/UCqfsjVyKK2_ajIgG_HqR36w");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$12, 26, 6, 805);
    			add_location(li3, file$12, 25, 5, 794);
    			attr_dev(ul0, "class", "social-icons");
    			add_location(ul0, file$12, 9, 4, 268);
    			attr_dev(div2, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div2, file$12, 8, 3, 222);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$12, 2, 2, 53);
    			attr_dev(a4, "href", "https://www.qualcomm.com/company/about");
    			attr_dev(a4, "target", "_blank");
    			add_location(a4, file$12, 37, 6, 1102);
    			add_location(li4, file$12, 36, 5, 1091);
    			attr_dev(a5, "href", "/rulebook.pdf");
    			attr_dev(a5, "target", "_blank");
    			add_location(a5, file$12, 42, 6, 1228);
    			add_location(li5, file$12, 41, 5, 1217);
    			attr_dev(ul1, "class", "footer-menu");
    			add_location(ul1, file$12, 35, 4, 1061);
    			attr_dev(div4, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div4, file$12, 34, 3, 1015);
    			attr_dev(a6, "href", "https://www.qualcomm.com/site/terms-of-use");
    			attr_dev(a6, "target", "_blank");
    			add_location(a6, file$12, 66, 6, 1705);
    			add_location(li6, file$12, 65, 5, 1694);
    			attr_dev(a7, "href", "https://www.qualcomm.com/site/privacy");
    			attr_dev(a7, "target", "_blank");
    			add_location(a7, file$12, 71, 6, 1833);
    			add_location(li7, file$12, 70, 5, 1822);
    			attr_dev(a8, "href", "https://www.qualcomm.com/site/cookies");
    			attr_dev(a8, "target", "_blank");
    			add_location(a8, file$12, 76, 6, 1951);
    			add_location(li8, file$12, 75, 5, 1940);
    			attr_dev(ul2, "class", "footer-privacy");
    			add_location(ul2, file$12, 64, 4, 1661);
    			attr_dev(div5, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div5, file$12, 63, 3, 1615);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$12, 33, 2, 994);
    			add_location(p0, file$12, 86, 5, 2155);
    			add_location(p1, file$12, 87, 5, 2234);
    			add_location(p2, file$12, 90, 5, 2460);
    			add_location(p3, file$12, 91, 5, 2619);
    			add_location(p4, file$12, 92, 5, 3120);
    			add_location(p5, file$12, 93, 5, 3321);
    			attr_dev(div7, "class", "ref-text");
    			add_location(div7, file$12, 85, 4, 2127);
    			attr_dev(div8, "class", "col");
    			add_location(div8, file$12, 84, 3, 2105);
    			attr_dev(div9, "class", "row");
    			add_location(div9, file$12, 83, 2, 2084);
    			if (!src_url_equal(img5.src, img5_src_value = "images/logo-te.png")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "alt", "logo-tesseract");
    			add_location(img5, file$12, 101, 6, 3610);
    			attr_dev(a9, "href", "https://www.tesseractesports.com");
    			attr_dev(a9, "target", "_blank");
    			add_location(a9, file$12, 100, 8, 3532);
    			add_location(p6, file$12, 100, 5, 3529);
    			attr_dev(div10, "class", "logo-te");
    			add_location(div10, file$12, 99, 4, 3502);
    			attr_dev(div11, "class", "col");
    			add_location(div11, file$12, 98, 3, 3480);
    			attr_dev(div12, "class", "row");
    			add_location(div12, file$12, 97, 2, 3459);
    			attr_dev(div13, "class", "container");
    			add_location(div13, file$12, 1, 1, 27);
    			attr_dev(div14, "class", "footer-info");
    			add_location(div14, file$12, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, img0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a0);
    			append_dev(a0, img1);
    			append_dev(ul0, t1);
    			append_dev(ul0, li1);
    			append_dev(li1, a1);
    			append_dev(a1, img2);
    			append_dev(ul0, t2);
    			append_dev(ul0, li2);
    			append_dev(li2, a2);
    			append_dev(a2, img3);
    			append_dev(ul0, t3);
    			append_dev(ul0, li3);
    			append_dev(li3, a3);
    			append_dev(a3, img4);
    			append_dev(div13, t4);
    			append_dev(div13, div6);
    			append_dev(div6, div4);
    			append_dev(div4, ul1);
    			append_dev(ul1, li4);
    			append_dev(li4, a4);
    			append_dev(ul1, t6);
    			append_dev(ul1, li5);
    			append_dev(li5, a5);
    			append_dev(div6, t8);
    			append_dev(div6, div5);
    			append_dev(div5, ul2);
    			append_dev(ul2, li6);
    			append_dev(li6, a6);
    			append_dev(ul2, t10);
    			append_dev(ul2, li7);
    			append_dev(li7, a7);
    			append_dev(ul2, t12);
    			append_dev(ul2, li8);
    			append_dev(li8, a8);
    			append_dev(div13, t14);
    			append_dev(div13, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, p0);
    			append_dev(div7, t16);
    			append_dev(div7, p1);
    			append_dev(div7, t18);
    			append_dev(div7, p2);
    			append_dev(div7, t20);
    			append_dev(div7, p3);
    			append_dev(div7, t22);
    			append_dev(div7, p4);
    			append_dev(div7, t24);
    			append_dev(div7, p5);
    			append_dev(div13, t26);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, p6);
    			append_dev(p6, a9);
    			append_dev(a9, t27);
    			append_dev(a9, img5);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Footer', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    /* src/layouts/partials/Sidenav.svelte generated by Svelte v3.41.0 */

    function create_fragment$1d(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sidenav', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidenav> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Sidenav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sidenav",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    /* src/layouts/default.svelte generated by Svelte v3.41.0 */

    function create_fragment$1c(ctx) {
    	let header;
    	let t0;
    	let t1;
    	let footer;
    	let current;
    	header = new Header({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(header.$$.fragment);
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(header, target, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Default', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Default> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Header, Footer, Sidenav });
    	return [$$scope, slots];
    }

    class Default extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Default",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    }

    /* src/layouts/partials/Compete.svelte generated by Svelte v3.41.0 */

    const file$11 = "src/layouts/partials/Compete.svelte";

    function create_fragment$1b(ctx) {
    	let section;
    	let div24;
    	let div1;
    	let h10;
    	let t1;
    	let div0;
    	let h11;
    	let t3;
    	let div2;
    	let t4;
    	let div23;
    	let div3;
    	let h4;
    	let t6;
    	let div22;
    	let h12;
    	let span0;
    	let t8;
    	let div4;
    	let t10;
    	let div7;
    	let div5;
    	let t11;
    	let span1;
    	let t13;
    	let div6;
    	let t14;
    	let span2;
    	let t16;
    	let div13;
    	let div8;
    	let t17;
    	let span3;
    	let t19;
    	let div9;
    	let t20;
    	let span4;
    	let t22;
    	let div10;
    	let t23;
    	let span5;
    	let t25;
    	let div11;
    	let t26;
    	let span6;
    	let t28;
    	let div12;
    	let t29;
    	let span7;
    	let t31;
    	let div18;
    	let div14;
    	let t32;
    	let span8;
    	let t34;
    	let div15;
    	let t35;
    	let span9;
    	let t37;
    	let div16;
    	let t38;
    	let span10;
    	let t40;
    	let div17;
    	let t41;
    	let span11;
    	let t43;
    	let div21;
    	let div19;
    	let t44;
    	let span12;
    	let t46;
    	let div20;
    	let t47;
    	let span13;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div24 = element("div");
    			div1 = element("div");
    			h10 = element("h1");
    			h10.textContent = "prizes";
    			t1 = space();
    			div0 = element("div");
    			h11 = element("h1");
    			h11.textContent = "24 Teams, ₹30 Lakh in prizes";
    			t3 = space();
    			div2 = element("div");
    			t4 = space();
    			div23 = element("div");
    			div3 = element("div");
    			h4 = element("h4");
    			h4.textContent = "PRIZES IN INR";
    			t6 = space();
    			div22 = element("div");
    			h12 = element("h1");
    			span0 = element("span");
    			span0.textContent = "10,00,000";
    			t8 = space();
    			div4 = element("div");
    			div4.textContent = "First Place";
    			t10 = space();
    			div7 = element("div");
    			div5 = element("div");
    			t11 = text$1("5,00,000\n                        ");
    			span1 = element("span");
    			span1.textContent = "Second Place";
    			t13 = space();
    			div6 = element("div");
    			t14 = text$1("2,50,000\n                        ");
    			span2 = element("span");
    			span2.textContent = "Third Place";
    			t16 = space();
    			div13 = element("div");
    			div8 = element("div");
    			t17 = text$1("2,00,000\n                        ");
    			span3 = element("span");
    			span3.textContent = "Fourth Place";
    			t19 = space();
    			div9 = element("div");
    			t20 = text$1("1,80,000\n                        ");
    			span4 = element("span");
    			span4.textContent = "Fifth Place";
    			t22 = space();
    			div10 = element("div");
    			t23 = text$1("1,50,000\n                        ");
    			span5 = element("span");
    			span5.textContent = "Sixth Place";
    			t25 = space();
    			div11 = element("div");
    			t26 = text$1("1,20,000\n                        ");
    			span6 = element("span");
    			span6.textContent = "Seventh Place";
    			t28 = space();
    			div12 = element("div");
    			t29 = text$1("1,00,000\n                        ");
    			span7 = element("span");
    			span7.textContent = "Eighth Place";
    			t31 = space();
    			div18 = element("div");
    			div14 = element("div");
    			t32 = text$1("80,000\n                        ");
    			span8 = element("span");
    			span8.textContent = "Ninth Place";
    			t34 = space();
    			div15 = element("div");
    			t35 = text$1("70,000\n                        ");
    			span9 = element("span");
    			span9.textContent = "Tenth Place";
    			t37 = space();
    			div16 = element("div");
    			t38 = text$1("60,000\n                        ");
    			span10 = element("span");
    			span10.textContent = "Eleventh Place";
    			t40 = space();
    			div17 = element("div");
    			t41 = text$1("50,000\n                        ");
    			span11 = element("span");
    			span11.textContent = "Twelfth Place";
    			t43 = space();
    			div21 = element("div");
    			div19 = element("div");
    			t44 = text$1("25,000\n                        ");
    			span12 = element("span");
    			span12.textContent = "13th - 18th Place";
    			t46 = space();
    			div20 = element("div");
    			t47 = text$1("15,000\n                        ");
    			span13 = element("span");
    			span13.textContent = "19th - 24th Place";
    			attr_dev(h10, "class", "data-text svelte-16l0jvu");
    			add_location(h10, file$11, 3, 12, 99);
    			add_location(h11, file$11, 7, 16, 227);
    			attr_dev(div0, "class", "torunament-info-block");
    			add_location(div0, file$11, 6, 12, 175);
    			attr_dev(div1, "class", "prize-title");
    			add_location(div1, file$11, 2, 8, 61);
    			attr_dev(div2, "class", "torunament-text svelte-16l0jvu");
    			add_location(div2, file$11, 12, 8, 345);
    			add_location(h4, file$11, 47, 16, 2498);
    			attr_dev(div3, "class", "text-center");
    			add_location(div3, file$11, 46, 12, 2456);
    			add_location(span0, file$11, 50, 40, 2615);
    			attr_dev(h12, "class", "totle-price");
    			add_location(h12, file$11, 50, 16, 2591);
    			attr_dev(div4, "class", "prize-postion");
    			add_location(div4, file$11, 51, 16, 2659);
    			add_location(span1, file$11, 55, 24, 2910);
    			attr_dev(div5, "class", "prize-txt no-border lv-2 svelte-16l0jvu");
    			add_location(div5, file$11, 53, 20, 2814);
    			add_location(span2, file$11, 61, 24, 3123);
    			attr_dev(div6, "class", "prize-txt lv-2 svelte-16l0jvu");
    			add_location(div6, file$11, 59, 20, 3037);
    			attr_dev(div7, "class", "d-flex align-items-center justify-content-center first-row");
    			add_location(div7, file$11, 52, 16, 2720);
    			add_location(span3, file$11, 69, 24, 3459);
    			attr_dev(div8, "class", "prize-txt no-border");
    			add_location(div8, file$11, 67, 20, 3368);
    			add_location(span4, file$11, 75, 24, 3667);
    			attr_dev(div9, "class", "prize-txt");
    			add_location(div9, file$11, 73, 20, 3586);
    			add_location(span5, file$11, 81, 24, 3874);
    			attr_dev(div10, "class", "prize-txt");
    			add_location(div10, file$11, 79, 20, 3793);
    			add_location(span6, file$11, 87, 24, 4081);
    			attr_dev(div11, "class", "prize-txt");
    			add_location(div11, file$11, 85, 20, 4000);
    			add_location(span7, file$11, 93, 24, 4306);
    			attr_dev(div12, "class", "prize-txt last-prize-text");
    			add_location(div12, file$11, 91, 20, 4209);
    			attr_dev(div13, "class", "d-flex mt-40 align-items-center justify-content-center second-row");
    			add_location(div13, file$11, 66, 16, 3268);
    			add_location(span8, file$11, 101, 24, 4640);
    			attr_dev(div14, "class", "prize-txt no-border");
    			add_location(div14, file$11, 99, 20, 4551);
    			add_location(span9, file$11, 107, 24, 4845);
    			attr_dev(div15, "class", "prize-txt");
    			add_location(div15, file$11, 105, 20, 4766);
    			add_location(span10, file$11, 113, 24, 5050);
    			attr_dev(div16, "class", "prize-txt");
    			add_location(div16, file$11, 111, 20, 4971);
    			add_location(span11, file$11, 119, 24, 5258);
    			attr_dev(div17, "class", "prize-txt");
    			add_location(div17, file$11, 117, 20, 5179);
    			attr_dev(div18, "class", "d-flex mt-40 align-items-center justify-content-center third-row");
    			add_location(div18, file$11, 98, 16, 4452);
    			add_location(span12, file$11, 127, 24, 5600);
    			attr_dev(div19, "class", "prize-txt no-border");
    			add_location(div19, file$11, 125, 20, 5511);
    			add_location(span13, file$11, 133, 24, 5812);
    			attr_dev(div20, "class", "prize-txt ");
    			add_location(div20, file$11, 131, 20, 5732);
    			attr_dev(div21, "class", "d-flex mt-40 align-items-center justify-content-center bottom-prize-box");
    			add_location(div21, file$11, 124, 16, 5405);
    			attr_dev(div22, "class", "main-box");
    			add_location(div22, file$11, 49, 12, 2552);
    			attr_dev(div23, "class", "prize-inr-section");
    			add_location(div23, file$11, 45, 8, 2412);
    			attr_dev(div24, "class", "container");
    			add_location(div24, file$11, 1, 1, 29);
    			attr_dev(section, "class", "prize-box svelte-16l0jvu");
    			add_location(section, file$11, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div24);
    			append_dev(div24, div1);
    			append_dev(div1, h10);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, h11);
    			append_dev(div24, t3);
    			append_dev(div24, div2);
    			append_dev(div24, t4);
    			append_dev(div24, div23);
    			append_dev(div23, div3);
    			append_dev(div3, h4);
    			append_dev(div23, t6);
    			append_dev(div23, div22);
    			append_dev(div22, h12);
    			append_dev(h12, span0);
    			append_dev(div22, t8);
    			append_dev(div22, div4);
    			append_dev(div22, t10);
    			append_dev(div22, div7);
    			append_dev(div7, div5);
    			append_dev(div5, t11);
    			append_dev(div5, span1);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			append_dev(div6, t14);
    			append_dev(div6, span2);
    			append_dev(div22, t16);
    			append_dev(div22, div13);
    			append_dev(div13, div8);
    			append_dev(div8, t17);
    			append_dev(div8, span3);
    			append_dev(div13, t19);
    			append_dev(div13, div9);
    			append_dev(div9, t20);
    			append_dev(div9, span4);
    			append_dev(div13, t22);
    			append_dev(div13, div10);
    			append_dev(div10, t23);
    			append_dev(div10, span5);
    			append_dev(div13, t25);
    			append_dev(div13, div11);
    			append_dev(div11, t26);
    			append_dev(div11, span6);
    			append_dev(div13, t28);
    			append_dev(div13, div12);
    			append_dev(div12, t29);
    			append_dev(div12, span7);
    			append_dev(div22, t31);
    			append_dev(div22, div18);
    			append_dev(div18, div14);
    			append_dev(div14, t32);
    			append_dev(div14, span8);
    			append_dev(div18, t34);
    			append_dev(div18, div15);
    			append_dev(div15, t35);
    			append_dev(div15, span9);
    			append_dev(div18, t37);
    			append_dev(div18, div16);
    			append_dev(div16, t38);
    			append_dev(div16, span10);
    			append_dev(div18, t40);
    			append_dev(div18, div17);
    			append_dev(div17, t41);
    			append_dev(div17, span11);
    			append_dev(div22, t43);
    			append_dev(div22, div21);
    			append_dev(div21, div19);
    			append_dev(div19, t44);
    			append_dev(div19, span12);
    			append_dev(div21, t46);
    			append_dev(div21, div20);
    			append_dev(div20, t47);
    			append_dev(div20, span13);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Compete', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Compete> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Compete extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Compete",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    /* src/layouts/partials/Contest.svelte generated by Svelte v3.41.0 */

    const file$10 = "src/layouts/partials/Contest.svelte";

    function create_fragment$1a(ctx) {
    	let section;
    	let div6;
    	let div5;
    	let div4;
    	let div2;
    	let div1;
    	let h6;
    	let t1;
    	let h1;
    	let t3;
    	let p;
    	let t5;
    	let div0;
    	let button;
    	let t7;
    	let small;
    	let t9;
    	let div3;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			h6 = element("h6");
    			h6.textContent = "WHAT DO YOU WANT & WHAT WILL YOU PAY?";
    			t1 = space();
    			h1 = element("h1");
    			h1.textContent = "Configure your dream mobile & win";
    			t3 = space();
    			p = element("p");
    			p.textContent = "Show us what your dream mobile specs would be for a chance to win spectacular rewards!";
    			t5 = space();
    			div0 = element("div");
    			button = element("button");
    			button.textContent = "Start Contest";
    			t7 = space();
    			small = element("small");
    			small.textContent = "** Terms & Conditions apply. Read contest terms to know more.";
    			t9 = space();
    			div3 = element("div");
    			attr_dev(h6, "class", "footer-text");
    			add_location(h6, file$10, 6, 6, 182);
    			attr_dev(h1, "class", "footer-title-text");
    			add_location(h1, file$10, 7, 6, 255);
    			attr_dev(p, "class", "footer-sub-text");
    			add_location(p, file$10, 8, 6, 330);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary");
    			add_location(button, file$10, 10, 7, 487);
    			attr_dev(div0, "class", "btn-section");
    			add_location(div0, file$10, 9, 6, 454);
    			attr_dev(small, "class", "terms-note svelte-1gbybmw");
    			add_location(small, file$10, 12, 6, 575);
    			attr_dev(div1, "class", "contest-text");
    			add_location(div1, file$10, 5, 6, 149);
    			attr_dev(div2, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div2, file$10, 4, 4, 101);
    			attr_dev(div3, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div3, file$10, 15, 4, 699);
    			attr_dev(div4, "class", "row no-gutters");
    			add_location(div4, file$10, 3, 3, 68);
    			attr_dev(div5, "class", "container");
    			add_location(div5, file$10, 2, 2, 41);
    			attr_dev(div6, "class", "contest-group");
    			add_location(div6, file$10, 1, 1, 11);
    			add_location(section, file$10, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h6);
    			append_dev(div1, t1);
    			append_dev(div1, h1);
    			append_dev(div1, t3);
    			append_dev(div1, p);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			append_dev(div0, button);
    			append_dev(div1, t7);
    			append_dev(div1, small);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Contest', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Contest> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Contest extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Contest",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    /* src/components/modal/EnterContestModal.svelte generated by Svelte v3.41.0 */
    const file$$ = "src/components/modal/EnterContestModal.svelte";

    function create_fragment$19(ctx) {
    	let div0;
    	let h2;
    	let t1;
    	let small;
    	let t3;
    	let div1;
    	let span0;
    	let t5;
    	let div4;
    	let div3;
    	let div2;
    	let a0;
    	let t7;
    	let span1;
    	let t8;
    	let a1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Want to enter the contest?";
    			t1 = space();
    			small = element("small");
    			small.textContent = "You must be a registered user to participate.";
    			t3 = space();
    			div1 = element("div");
    			span0 = element("span");
    			span0.textContent = "star_border";
    			t5 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			a0 = element("a");
    			a0.textContent = "Register Now";
    			t7 = space();
    			span1 = element("span");
    			t8 = text$1("Already Registered? ");
    			a1 = element("a");
    			a1.textContent = "Login to your account";
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$$, 4, 1, 97);
    			attr_dev(small, "class", "request-info-txt");
    			add_location(small, file$$, 7, 1, 159);
    			attr_dev(div0, "class", "svelte-modal-header svelte-18pr24");
    			add_location(div0, file$$, 3, 0, 62);
    			attr_dev(span0, "class", "material-icons svelte-18pr24");
    			add_location(span0, file$$, 12, 1, 280);
    			attr_dev(div1, "class", "bg-icon svelte-18pr24");
    			add_location(div1, file$$, 11, 0, 257);
    			attr_dev(a0, "href", "/login");
    			attr_dev(a0, "class", "btn btn-primary min-w-300 svelte-18pr24");
    			add_location(a0, file$$, 19, 3, 470);
    			attr_dev(div2, "class", "d-flex justify-content-center align-items-center");
    			add_location(div2, file$$, 18, 2, 404);
    			attr_dev(div3, "class", "col-12 mt-4");
    			add_location(div3, file$$, 17, 1, 376);
    			attr_dev(div4, "class", "row no-gutters p-rel svelte-18pr24");
    			add_location(div4, file$$, 16, 0, 340);
    			attr_dev(a1, "href", "/login");
    			attr_dev(a1, "class", "login-txt svelte-18pr24");
    			add_location(a1, file$$, 26, 24, 637);
    			attr_dev(span1, "class", "mt-20 mb-3 login-txt p-rel svelte-18pr24");
    			add_location(span1, file$$, 25, 0, 571);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(div0, t1);
    			append_dev(div0, small);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span0);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, a0);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t8);
    			append_dev(span1, a1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EnterContestModal', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EnterContestModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Modal });
    	return [];
    }

    class EnterContestModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EnterContestModal",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    /* src/components/modal/SuccessfullyEnteredContestModal.svelte generated by Svelte v3.41.0 */
    const file$_ = "src/components/modal/SuccessfullyEnteredContestModal.svelte";

    function create_fragment$18(ctx) {
    	let div0;
    	let h2;
    	let t1;
    	let small;
    	let t3;
    	let div1;
    	let span;
    	let t5;
    	let div4;
    	let div3;
    	let div2;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Successfully entered contest!";
    			t1 = space();
    			small = element("small");
    			small.textContent = "You have successfully entered the contest to win 1060 diamonds. We will announce the winners once the registration phase of the tournament completes.";
    			t3 = space();
    			div1 = element("div");
    			span = element("span");
    			span.textContent = "star_border";
    			t5 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			a = element("a");
    			a.textContent = "Go to home page";
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$_, 4, 1, 97);
    			attr_dev(small, "class", "request-info-txt");
    			add_location(small, file$_, 7, 1, 162);
    			attr_dev(div0, "class", "svelte-modal-header svelte-1kf84xc");
    			add_location(div0, file$_, 3, 0, 62);
    			attr_dev(span, "class", "material-icons svelte-1kf84xc");
    			add_location(span, file$_, 12, 1, 387);
    			attr_dev(div1, "class", "bg-icon svelte-1kf84xc");
    			add_location(div1, file$_, 11, 0, 364);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "btn btn-primary min-w-300 svelte-1kf84xc");
    			add_location(a, file$_, 19, 3, 571);
    			attr_dev(div2, "class", "d-flex justify-content-center align-items-center");
    			add_location(div2, file$_, 18, 2, 505);
    			attr_dev(div3, "class", "col-12 mt-4");
    			add_location(div3, file$_, 17, 1, 477);
    			attr_dev(div4, "class", "row no-gutters");
    			add_location(div4, file$_, 16, 0, 447);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(div0, t1);
    			append_dev(div0, small);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", prevent_default(Modal.close), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SuccessfullyEnteredContestModal', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SuccessfullyEnteredContestModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Modal });
    	return [];
    }

    class SuccessfullyEnteredContestModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SuccessfullyEnteredContestModal",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    }

    /* src/layouts/partials/ContestDiamond.svelte generated by Svelte v3.41.0 */
    const file$Z = "src/layouts/partials/ContestDiamond.svelte";

    function create_fragment$17(ctx) {
    	let section;
    	let div6;
    	let div5;
    	let div4;
    	let div2;
    	let div1;
    	let h6;
    	let t1;
    	let h1;
    	let t3;
    	let p;
    	let t5;
    	let div0;
    	let t7;
    	let small;
    	let t9;
    	let div3;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			h6 = element("h6");
    			h6.textContent = "FREE FIRE DIAMONDS GIVEAWAY";
    			t1 = space();
    			h1 = element("h1");
    			h1.textContent = "1,60,000 Diamonds for 150 lucky winners";
    			t3 = space();
    			p = element("p");
    			p.textContent = "Register yourself to stand a chance to win Free Fire Diamonds. 150 lucky participants will win 1060 Diamonds each. The last day to enter is 20 December 2020, so hurry up!**";
    			t5 = space();
    			div0 = element("div");
    			div0.textContent = "Contest closed. We will notify the results soon.";
    			t7 = space();
    			small = element("small");
    			small.textContent = "**Winners will be announced after the registrations end. Winners will be picked randomly from the list of participants.";
    			t9 = space();
    			div3 = element("div");
    			img = element("img");
    			attr_dev(h6, "class", "footer-text");
    			add_location(h6, file$Z, 39, 6, 1247);
    			attr_dev(h1, "class", "footer-title-text svelte-1gspbce");
    			add_location(h1, file$Z, 40, 6, 1310);
    			attr_dev(p, "class", "footer-sub-text");
    			add_location(p, file$Z, 41, 6, 1391);
    			attr_dev(div0, "class", "btn-section");
    			add_location(div0, file$Z, 42, 6, 1601);
    			attr_dev(small, "class", "terms-note svelte-1gspbce");
    			add_location(small, file$Z, 45, 6, 1702);
    			attr_dev(div1, "class", "contest-text");
    			add_location(div1, file$Z, 38, 5, 1192);
    			attr_dev(div2, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div2, file$Z, 37, 4, 1145);
    			if (!src_url_equal(img.src, img_src_value = "images/diamond-contest.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "diamond-contest");
    			add_location(img, file$Z, 49, 5, 1943);
    			attr_dev(div3, "class", "col-lg-6 col-sm-6 col-xs-12 mobile-order");
    			add_location(div3, file$Z, 48, 4, 1883);
    			attr_dev(div4, "class", "row no-gutters");
    			add_location(div4, file$Z, 36, 3, 1112);
    			attr_dev(div5, "class", "container");
    			add_location(div5, file$Z, 35, 2, 1084);
    			attr_dev(div6, "class", "diamond-contest");
    			add_location(div6, file$Z, 34, 1, 1052);
    			add_location(section, file$Z, 33, 0, 1041);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h6);
    			append_dev(div1, t1);
    			append_dev(div1, h1);
    			append_dev(div1, t3);
    			append_dev(div1, p);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			append_dev(div1, t7);
    			append_dev(div1, small);
    			/*div1_binding*/ ctx[3](div1);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, img);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			/*div1_binding*/ ctx[3](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let $user;
    	let $path;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContestDiamond', slots, []);
    	const path = getHistory().currentPath;
    	validate_store(path, 'path');
    	component_subscribe($$self, path, value => $$invalidate(5, $path = value));
    	let contestEl;
    	let thisEl;

    	onMount(() => {
    		if ($path.indexOf('/contest') == 0) {
    			//setTimeout(() => {window.scrollTo(0, contestEl.offsetTop - window.innerHeight + 500)}, 500);
    			contestEl.scrollIntoView();
    		} //console.log(contestEl.offsetTop - window.innerHeight);
    	});

    	const user = User.getUser();
    	validate_store(user, 'user');
    	component_subscribe($$self, user, value => $$invalidate(4, $user = value));
    	const userRest = User.getInstance();

    	const enterContest = async () => {
    		if ($user.loggedOut) {
    			window.localStorage.setItem('enterContest', true);
    			Modal.open(EnterContestModal);
    		} else {
    			let contest = await userRest.enterContest();

    			if (contest) {
    				Modal.open(SuccessfullyEnteredContestModal);
    			}
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContestDiamond> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contestEl = $$value;
    			$$invalidate(0, contestEl);
    		});
    	}

    	$$self.$capture_state = () => ({
    		EnterContestModal,
    		Notify: notyf,
    		Modal,
    		User,
    		SuccessModal: SuccessfullyEnteredContestModal,
    		getHistory,
    		onMount,
    		path,
    		contestEl,
    		thisEl,
    		user,
    		userRest,
    		enterContest,
    		$user,
    		$path
    	});

    	$$self.$inject_state = $$props => {
    		if ('contestEl' in $$props) $$invalidate(0, contestEl = $$props.contestEl);
    		if ('thisEl' in $$props) thisEl = $$props.thisEl;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contestEl, path, user, div1_binding];
    }

    class ContestDiamond extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContestDiamond",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    /* src/components/tabs/Tabs.svelte generated by Svelte v3.41.0 */
    const file$Y = "src/components/tabs/Tabs.svelte";

    function create_fragment$16(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "tabs");
    			add_location(div, file$Y, 47, 0, 1105);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const TABS = {};

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, ['default']);
    	const tabs = [];
    	const panels = [];
    	const selectedTab = writable(null);
    	const selectedPanel = writable(null);

    	setContext(TABS, {
    		registerTab: tab => {
    			tabs.push(tab);
    			selectedTab.update(current => tab.active ? tab : current || tab);

    			onDestroy(() => {
    				const i = tabs.indexOf(tab);
    				tabs.splice(i, 1);

    				selectedTab.update(current => current === tab
    				? tabs[i] || tabs[tabs.length - 1]
    				: current);
    			});
    		},
    		registerPanel: panel => {
    			panels.push(panel);
    			selectedPanel.update(current => panel.active ? panel : current || panel);

    			onDestroy(() => {
    				const i = panels.indexOf(panel);
    				panels.splice(i, 1);

    				selectedPanel.update(current => current === panel
    				? panels[i] || panels[panels.length - 1]
    				: current);
    			});
    		},
    		selectTab: tab => {
    			const i = tabs.indexOf(tab);
    			selectedTab.set(tab);
    			selectedPanel.set(panels[i]);
    		},
    		selectedTab,
    		selectedPanel
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		TABS,
    		setContext,
    		onDestroy,
    		writable,
    		tabs,
    		panels,
    		selectedTab,
    		selectedPanel
    	});

    	return [$$scope, slots];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    /* src/components/tabs/TabList.svelte generated by Svelte v3.41.0 */

    const file$X = "src/components/tabs/TabList.svelte";

    function create_fragment$15(ctx) {
    	let div1;
    	let div0;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "nav");
    			add_location(div0, file$X, 1, 1, 36);
    			attr_dev(div1, "class", "tab-list nav-section");
    			add_location(div1, file$X, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabList', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class TabList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabList",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    /* src/components/tabs/TabPanel.svelte generated by Svelte v3.41.0 */

    // (13:0) {#if $selectedPanel === panel}
    function create_if_block$v(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(13:0) {#if $selectedPanel === panel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$14(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1] && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$selectedPanel*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let $selectedPanel;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabPanel', slots, ['default']);
    	let { active = false } = $$props;
    	const panel = { active };
    	const { registerPanel, selectedPanel } = getContext(TABS);
    	validate_store(selectedPanel, 'selectedPanel');
    	component_subscribe($$self, selectedPanel, value => $$invalidate(0, $selectedPanel = value));
    	registerPanel(panel);
    	const writable_props = ['active'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabPanel> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(3, active = $$props.active);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		TABS,
    		active,
    		panel,
    		registerPanel,
    		selectedPanel,
    		$selectedPanel
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(3, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$selectedPanel, panel, selectedPanel, active, $$scope, slots];
    }

    class TabPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$14, safe_not_equal, { active: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabPanel",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get active() {
    		throw new Error("<TabPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<TabPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/Tab.svelte generated by Svelte v3.41.0 */
    const file$W = "src/components/tabs/Tab.svelte";

    function create_fragment$13(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "tab-btn svelte-ppq6cf");
    			toggle_class(div, "selected", /*$selectedTab*/ ctx[0] === /*tab*/ ctx[1]);
    			add_location(div, file$W, 40, 0, 689);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (dirty & /*$selectedTab, tab*/ 3) {
    				toggle_class(div, "selected", /*$selectedTab*/ ctx[0] === /*tab*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let $selectedTab;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, ['default']);
    	let { active = false } = $$props;
    	const tab = { active };
    	const { registerTab, selectTab, selectedTab } = getContext(TABS);
    	validate_store(selectedTab, 'selectedTab');
    	component_subscribe($$self, selectedTab, value => $$invalidate(0, $selectedTab = value));
    	registerTab(tab);
    	const writable_props = ['active'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => selectTab(tab);

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(4, active = $$props.active);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		TABS,
    		active,
    		tab,
    		registerTab,
    		selectTab,
    		selectedTab,
    		$selectedTab
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(4, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$selectedTab,
    		tab,
    		selectTab,
    		selectedTab,
    		active,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$13, safe_not_equal, { active: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get active() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function slide$1(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut
    } = {}) {
      const style = getComputedStyle(node);
      const opacity = +style.opacity;
      const height = parseFloat(style.height);
      const padding_top = parseFloat(style.paddingTop);
      const padding_bottom = parseFloat(style.paddingBottom);
      const margin_top = parseFloat(style.marginTop);
      const margin_bottom = parseFloat(style.marginBottom);
      const border_top_width = parseFloat(style.borderTopWidth);
      const border_bottom_width = parseFloat(style.borderBottomWidth);
      return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' + `opacity: ${Math.min(t * 20, 1) * opacity};` + `height: ${t * height}px;` + `padding-top: ${t * padding_top}px;` + `padding-bottom: ${t * padding_bottom}px;` + `margin-top: ${t * margin_top}px;` + `margin-bottom: ${t * margin_bottom}px;` + `border-top-width: ${t * border_top_width}px;` + `border-bottom-width: ${t * border_bottom_width}px;`
      };
    }

    /* src/layouts/partials/Format.svelte generated by Svelte v3.41.0 */
    const file$V = "src/layouts/partials/Format.svelte";

    // (103:32) 
    function create_if_block_2$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("third tab...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(103:32) ",
    		ctx
    	});

    	return block;
    }

    // (101:33) 
    function create_if_block_1$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("second tab..");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(101:33) ",
    		ctx
    	});

    	return block;
    }

    // (96:9) {#if firstCircle}
    function create_if_block$u(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("The League Stage is spread over a 3-week period where the 24 invited teams will fight it out in a round robin format. \n\t\t\t\t\t\t\t\t\t\tThe top 6 teams will directly qualify for the Grand Finals of the Snapdragon Conquest Season 2 Free Fire Pro Series. \n\t\t\t\t\t\t\t\t\t\tThe bottom 6 teams will be eliminated from the tournament. \n\t\t\t\t\t\t\t\t\t\tThe remaining 12 teams will have a chance to get back into the tournament in the Wild Card stage.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(96:9) {#if firstCircle}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let section;
    	let div22;
    	let div21;
    	let div20;
    	let div19;
    	let div0;
    	let h1;
    	let t1;
    	let div1;
    	let t2;
    	let div14;
    	let div5;
    	let div3;
    	let div2;
    	let span0;
    	let t4;
    	let div4;
    	let h60;
    	let t6;
    	let p0;
    	let t7;
    	let br0;
    	let t8;
    	let t9;
    	let div9;
    	let div7;
    	let div6;
    	let span1;
    	let t11;
    	let div8;
    	let h61;
    	let t13;
    	let p1;
    	let t14;
    	let br1;
    	let t15;
    	let t16;
    	let div13;
    	let div11;
    	let div10;
    	let span2;
    	let t18;
    	let div12;
    	let h62;
    	let t20;
    	let p2;
    	let t21;
    	let br2;
    	let t22;
    	let t23;
    	let div18;
    	let div17;
    	let div16;
    	let div15;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*firstCircle*/ ctx[0]) return create_if_block$u;
    		if (/*secondCircle*/ ctx[1]) return create_if_block_1$f;
    		if (/*thirdCircle*/ ctx[2]) return create_if_block_2$b;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div22 = element("div");
    			div21 = element("div");
    			div20 = element("div");
    			div19 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Format";
    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div14 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "poll";
    			t4 = space();
    			div4 = element("div");
    			h60 = element("h6");
    			h60.textContent = "League Stage";
    			t6 = space();
    			p0 = element("p");
    			t7 = text$1("24 teams ");
    			br0 = element("br");
    			t8 = text$1("\n\t\t\t\t\t\t\t\t\t20 Aug – Sep 5");
    			t9 = space();
    			div9 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			span1 = element("span");
    			span1.textContent = "videogame_asset";
    			t11 = space();
    			div8 = element("div");
    			h61 = element("h6");
    			h61.textContent = "Wild Card";
    			t13 = space();
    			p1 = element("p");
    			t14 = text$1("12 Teams ");
    			br1 = element("br");
    			t15 = text$1("\n\t\t\t\t\t\t\t\t\t10 Sep – Sep 12");
    			t16 = space();
    			div13 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			span2 = element("span");
    			span2.textContent = "star";
    			t18 = space();
    			div12 = element("div");
    			h62 = element("h6");
    			h62.textContent = "Grand Finals";
    			t20 = space();
    			p2 = element("p");
    			t21 = text$1("12 Teams ");
    			br2 = element("br");
    			t22 = text$1("\n\t\t\t\t\t\t\t\t\t8 Oct – 9 Oct");
    			t23 = space();
    			div18 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			div15 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(h1, "class", "format-title");
    			add_location(h1, file$V, 14, 6, 382);
    			attr_dev(div0, "class", "text-center format-section");
    			add_location(div0, file$V, 13, 5, 335);
    			attr_dev(div1, "class", "spacer-box");
    			add_location(div1, file$V, 21, 5, 718);
    			attr_dev(span0, "class", "material-icons");
    			add_location(span0, file$V, 30, 9, 1045);
    			attr_dev(div2, "class", "inner-circle svelte-1kl5d7k");
    			add_location(div2, file$V, 29, 8, 1009);
    			attr_dev(div3, "class", "round");
    			add_location(div3, file$V, 28, 7, 981);
    			attr_dev(h60, "class", "svelte-1kl5d7k");
    			add_location(h60, file$V, 36, 8, 1179);
    			add_location(br0, file$V, 40, 18, 1250);
    			attr_dev(p0, "class", "svelte-1kl5d7k");
    			add_location(p0, file$V, 39, 8, 1228);
    			attr_dev(div4, "class", "progress-info");
    			add_location(div4, file$V, 35, 7, 1143);
    			attr_dev(div5, "class", "circle-step first-dot svelte-1kl5d7k");
    			toggle_class(div5, "active-state", /*firstCircle*/ ctx[0]);
    			add_location(div5, file$V, 23, 6, 779);
    			attr_dev(span1, "class", "material-icons");
    			add_location(span1, file$V, 52, 9, 1593);
    			attr_dev(div6, "class", "inner-circle svelte-1kl5d7k");
    			add_location(div6, file$V, 51, 8, 1557);
    			attr_dev(div7, "class", "round");
    			add_location(div7, file$V, 50, 7, 1529);
    			attr_dev(h61, "class", "svelte-1kl5d7k");
    			add_location(h61, file$V, 58, 8, 1738);
    			add_location(br1, file$V, 62, 18, 1806);
    			attr_dev(p1, "class", "svelte-1kl5d7k");
    			add_location(p1, file$V, 61, 8, 1784);
    			attr_dev(div8, "class", "progress-info");
    			add_location(div8, file$V, 57, 7, 1702);
    			attr_dev(div9, "class", "circle-step second-dot svelte-1kl5d7k");
    			toggle_class(div9, "active-state", /*secondCircle*/ ctx[1]);
    			add_location(div9, file$V, 45, 6, 1326);
    			attr_dev(span2, "class", "material-icons");
    			add_location(span2, file$V, 74, 9, 2148);
    			attr_dev(div10, "class", "inner-circle svelte-1kl5d7k");
    			add_location(div10, file$V, 73, 8, 2112);
    			attr_dev(div11, "class", "round");
    			add_location(div11, file$V, 72, 7, 2084);
    			attr_dev(h62, "class", "svelte-1kl5d7k");
    			add_location(h62, file$V, 80, 8, 2282);
    			add_location(br2, file$V, 84, 18, 2353);
    			attr_dev(p2, "class", "svelte-1kl5d7k");
    			add_location(p2, file$V, 83, 8, 2331);
    			attr_dev(div12, "class", "progress-info");
    			add_location(div12, file$V, 79, 7, 2246);
    			attr_dev(div13, "class", "circle-step sixth-dot svelte-1kl5d7k");
    			toggle_class(div13, "active-state", /*thirdCircle*/ ctx[2]);
    			add_location(div13, file$V, 67, 6, 1882);
    			attr_dev(div14, "class", "line");
    			add_location(div14, file$V, 22, 5, 754);
    			attr_dev(div15, "class", "text-center");
    			add_location(div15, file$V, 94, 8, 2572);
    			attr_dev(div16, "class", "col-md-8 col-xs-12");
    			add_location(div16, file$V, 93, 7, 2531);
    			attr_dev(div17, "class", "row justify-content-center");
    			add_location(div17, file$V, 92, 6, 2483);
    			attr_dev(div18, "class", "format-data mr-b-3 svelte-1kl5d7k");
    			add_location(div18, file$V, 91, 5, 2444);
    			attr_dev(div19, "class", "format s2-format");
    			add_location(div19, file$V, 12, 4, 299);
    			attr_dev(div20, "class", "col");
    			add_location(div20, file$V, 11, 3, 277);
    			attr_dev(div21, "class", "row");
    			add_location(div21, file$V, 10, 2, 256);
    			attr_dev(div22, "class", "container");
    			add_location(div22, file$V, 9, 1, 230);
    			add_location(section, file$V, 8, 0, 219);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div22);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div19);
    			append_dev(div19, div0);
    			append_dev(div0, h1);
    			append_dev(div19, t1);
    			append_dev(div19, div1);
    			append_dev(div19, t2);
    			append_dev(div19, div14);
    			append_dev(div14, div5);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, span0);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, h60);
    			append_dev(div4, t6);
    			append_dev(div4, p0);
    			append_dev(p0, t7);
    			append_dev(p0, br0);
    			append_dev(p0, t8);
    			append_dev(div14, t9);
    			append_dev(div14, div9);
    			append_dev(div9, div7);
    			append_dev(div7, div6);
    			append_dev(div6, span1);
    			append_dev(div9, t11);
    			append_dev(div9, div8);
    			append_dev(div8, h61);
    			append_dev(div8, t13);
    			append_dev(div8, p1);
    			append_dev(p1, t14);
    			append_dev(p1, br1);
    			append_dev(p1, t15);
    			append_dev(div14, t16);
    			append_dev(div14, div13);
    			append_dev(div13, div11);
    			append_dev(div11, div10);
    			append_dev(div10, span2);
    			append_dev(div13, t18);
    			append_dev(div13, div12);
    			append_dev(div12, h62);
    			append_dev(div12, t20);
    			append_dev(div12, p2);
    			append_dev(p2, t21);
    			append_dev(p2, br2);
    			append_dev(p2, t22);
    			append_dev(div19, t23);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, div15);
    			if (if_block) if_block.m(div15, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div5, "click", prevent_default(/*click_handler*/ ctx[3]), false, true, false),
    					listen_dev(div9, "click", prevent_default(/*click_handler_1*/ ctx[4]), false, true, false),
    					listen_dev(div13, "click", prevent_default(/*click_handler_2*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*firstCircle*/ 1) {
    				toggle_class(div5, "active-state", /*firstCircle*/ ctx[0]);
    			}

    			if (dirty & /*secondCircle*/ 2) {
    				toggle_class(div9, "active-state", /*secondCircle*/ ctx[1]);
    			}

    			if (dirty & /*thirdCircle*/ 4) {
    				toggle_class(div13, "active-state", /*thirdCircle*/ ctx[2]);
    			}

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div15, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);

    			if (if_block) {
    				if_block.d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Format', slots, []);
    	let firstCircle = true;
    	let secondCircle = false;
    	let thirdCircle = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Format> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(0, firstCircle = true);
    		$$invalidate(1, secondCircle = false);
    		$$invalidate(2, thirdCircle = false);
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, secondCircle = true);
    		$$invalidate(0, firstCircle = false);
    		$$invalidate(2, thirdCircle = false);
    	};

    	const click_handler_2 = () => {
    		$$invalidate(2, thirdCircle = true);
    		$$invalidate(1, secondCircle = false);
    		$$invalidate(0, firstCircle = false);
    	};

    	$$self.$capture_state = () => ({
    		Tabs,
    		TabList,
    		TabPanel,
    		Tab,
    		slide: slide$1,
    		firstCircle,
    		secondCircle,
    		thirdCircle
    	});

    	$$self.$inject_state = $$props => {
    		if ('firstCircle' in $$props) $$invalidate(0, firstCircle = $$props.firstCircle);
    		if ('secondCircle' in $$props) $$invalidate(1, secondCircle = $$props.secondCircle);
    		if ('thirdCircle' in $$props) $$invalidate(2, thirdCircle = $$props.thirdCircle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		firstCircle,
    		secondCircle,
    		thirdCircle,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Format extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Format",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    /* src/layouts/main.svelte generated by Svelte v3.41.0 */

    function create_fragment$11(ctx) {
    	let header;
    	let t0;
    	let t1;
    	let footer;
    	let current;
    	header = new Header({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(header.$$.fragment);
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(header, target, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Main', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Header,
    		Footer,
    		Compete,
    		Contest,
    		ContestDiamond,
    		Format
    	});

    	return [$$scope, slots];
    }

    class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$11, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment$11.name
    		});
    	}
    }

    /* src/layouts/inner.svelte generated by Svelte v3.41.0 */

    function create_fragment$10(ctx) {
    	let header;
    	let t0;
    	let t1;
    	let footer;
    	let current;
    	header = new Header({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(header.$$.fragment);
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(header, target, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Inner', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Inner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Header,
    		Footer,
    		Compete,
    		Contest,
    		ContestDiamond,
    		Format
    	});

    	return [$$scope, slots];
    }

    class Inner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$10, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Inner",
    			options,
    			id: create_fragment$10.name
    		});
    	}
    }

    /* src/layouts/blank.svelte generated by Svelte v3.41.0 */

    const file$U = "src/layouts/blank.svelte";

    function create_fragment$$(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "full-height");
    			add_location(div, file$U, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Blank', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Blank> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Blank extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Blank",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    /* src/layouts/homepage2.svelte generated by Svelte v3.41.0 */

    function create_fragment$_(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Homepage2', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Homepage2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class Homepage2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Homepage2",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    /* src/layouts/partials/Leftbanner.svelte generated by Svelte v3.41.0 */

    const file$T = "src/layouts/partials/Leftbanner.svelte";

    function create_fragment$Z(ctx) {
    	let div2;
    	let div0;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let ul;
    	let li0;
    	let a1;
    	let t2;
    	let li1;
    	let a2;
    	let t4;
    	let li2;
    	let a3;
    	let t6;
    	let li3;
    	let a4;
    	let t8;
    	let p;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			a1.textContent = "Terms of Use";
    			t2 = space();
    			li1 = element("li");
    			a2 = element("a");
    			a2.textContent = "Privacy";
    			t4 = space();
    			li2 = element("li");
    			a3 = element("a");
    			a3.textContent = "About Qualcomm";
    			t6 = space();
    			li3 = element("li");
    			a4 = element("a");
    			a4.textContent = "Rulebook";
    			t8 = space();
    			p = element("p");
    			p.textContent = "©2020 Qualcomm Technologies, Inc. and/or its affiliated companies.";
    			if (!src_url_equal(img.src, img_src_value = "images/home-logo.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo");
    			add_location(img, file$T, 3, 3, 67);
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$T, 2, 2, 51);
    			attr_dev(div0, "class", "logo-section");
    			add_location(div0, file$T, 1, 1, 22);
    			attr_dev(a1, "href", "https://www.qualcomm.com/site/terms-of-use");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$T, 9, 4, 175);
    			add_location(li0, file$T, 8, 3, 166);
    			attr_dev(a2, "href", "https://www.qualcomm.com/site/privacy");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$T, 14, 4, 293);
    			add_location(li1, file$T, 13, 3, 284);
    			attr_dev(a3, "href", "https://www.qualcomm.com/company/about");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$T, 19, 4, 401);
    			add_location(li2, file$T, 18, 3, 392);
    			attr_dev(a4, "href", "/rulebook.pdf");
    			attr_dev(a4, "target", "_blank");
    			add_location(a4, file$T, 24, 4, 517);
    			add_location(li3, file$T, 23, 3, 508);
    			add_location(ul, file$T, 7, 2, 158);
    			attr_dev(p, "class", "copyrights-txt");
    			add_location(p, file$T, 29, 2, 600);
    			attr_dev(div1, "class", "bottom-section");
    			add_location(div1, file$T, 6, 1, 127);
    			attr_dev(div2, "class", "bg-img");
    			add_location(div2, file$T, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a1);
    			append_dev(ul, t2);
    			append_dev(ul, li1);
    			append_dev(li1, a2);
    			append_dev(ul, t4);
    			append_dev(ul, li2);
    			append_dev(li2, a3);
    			append_dev(ul, t6);
    			append_dev(ul, li3);
    			append_dev(li3, a4);
    			append_dev(div1, t8);
    			append_dev(div1, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Leftbanner', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Leftbanner> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Leftbanner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Leftbanner",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    /* src/layouts/login.svelte generated by Svelte v3.41.0 */
    const file$S = "src/layouts/login.svelte";

    // (13:12) {#if step}
    function create_if_block$t(ctx) {
    	let small;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			small = element("small");
    			t0 = text$1("STEP ");
    			t1 = text$1(/*step*/ ctx[1]);
    			t2 = text$1(" OF 4");
    			attr_dev(small, "class", "no-of-steps");
    			add_location(small, file$S, 13, 12, 392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, small, anchor);
    			append_dev(small, t0);
    			append_dev(small, t1);
    			append_dev(small, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*step*/ 2) set_data_dev(t1, /*step*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(small);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(13:12) {#if step}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let div7;
    	let div0;
    	let leftbanner;
    	let t0;
    	let div6;
    	let div5;
    	let div4;
    	let t1;
    	let h1;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let div3;
    	let div2;
    	let ul;
    	let li0;
    	let a0;
    	let t6;
    	let li1;
    	let a1;
    	let t8;
    	let li2;
    	let a2;
    	let t10;
    	let li3;
    	let a3;
    	let t12;
    	let p0;
    	let t14;
    	let p1;
    	let t16;
    	let p2;
    	let t18;
    	let p3;
    	let current;
    	leftbanner = new Leftbanner({ $$inline: true });
    	let if_block = /*step*/ ctx[1] && create_if_block$t(ctx);
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div0 = element("div");
    			create_component(leftbanner.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			if (if_block) if_block.c();
    			t1 = space();
    			h1 = element("h1");
    			t2 = text$1(/*title*/ ctx[0]);
    			t3 = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Terms of Use";
    			t6 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Privacy";
    			t8 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "About Qualcomm";
    			t10 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "Rulebook";
    			t12 = space();
    			p0 = element("p");
    			p0.textContent = "©2020 Qualcomm Technologies, Inc. and/or its affiliated companies.";
    			t14 = space();
    			p1 = element("p");
    			p1.textContent = "The Qualcomm Snapdragon Conquest tournament is sponsored by Qualcomm Technologies, Inc. and/or its subsidiaries. Qualcomm Snapdragon is a product of Qualcomm Technologies, Inc. and or its subsidiaries";
    			t16 = space();
    			p2 = element("p");
    			p2.textContent = "References to \"Qualcomm\" may mean Qualcomm Incorporated, or subsidiaries or business units within the Qualcomm corporate structure, as applicable.";
    			t18 = space();
    			p3 = element("p");
    			p3.textContent = "Qualcomm Incorporated includes Qualcomm's licensing business, QTL, and the vast majority of its patent portfolio. Qualcomm Technologies, Inc., a wholly-owned subsidiary of Qualcomm Incorporated, operates, along with its subsidiaries, substantially all of Qualcomm's engineering, research and development functions, and substantially all of its products and services businesses. Qualcomm products referenced herein are products of Qualcomm Technologies, Inc. and/or its subsidiaries.";
    			attr_dev(div0, "class", "col-lg-6 col-sm-12 col-xs-12");
    			add_location(div0, file$S, 6, 3, 175);
    			attr_dev(h1, "class", "main-heading");
    			add_location(h1, file$S, 15, 11, 473);
    			attr_dev(div1, "class", "col-12 no-padding");
    			add_location(div1, file$S, 18, 11, 550);
    			attr_dev(a0, "href", "https://www.qualcomm.com/site/terms-of-use");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$S, 26, 16, 766);
    			add_location(li0, file$S, 25, 14, 745);
    			attr_dev(a1, "href", "https://www.qualcomm.com/site/privacy");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$S, 31, 16, 943);
    			add_location(li1, file$S, 30, 14, 922);
    			attr_dev(a2, "href", "https://www.qualcomm.com/company/about");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$S, 36, 16, 1110);
    			add_location(li2, file$S, 35, 14, 1089);
    			attr_dev(a3, "href", "/rulebook.pdf");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$S, 41, 16, 1285);
    			add_location(li3, file$S, 40, 14, 1264);
    			add_location(ul, file$S, 24, 12, 726);
    			attr_dev(p0, "class", "copyrights-txt");
    			add_location(p0, file$S, 46, 12, 1424);
    			attr_dev(div2, "class", "right-side-links svelte-1v8yi48");
    			add_location(div2, file$S, 23, 10, 683);
    			add_location(p1, file$S, 50, 12, 1583);
    			add_location(p2, file$S, 53, 13, 1832);
    			attr_dev(p3, "class", "no-margin");
    			add_location(p3, file$S, 56, 13, 2031);
    			attr_dev(div3, "class", "info-txt svelte-1v8yi48");
    			add_location(div3, file$S, 22, 9, 650);
    			attr_dev(div4, "class", "form-box svelte-1v8yi48");
    			add_location(div4, file$S, 11, 7, 334);
    			attr_dev(div5, "class", "scroll-box svelte-1v8yi48");
    			add_location(div5, file$S, 10, 6, 302);
    			attr_dev(div6, "class", "col-lg-6 col-sm-12 col-xs-12");
    			add_location(div6, file$S, 9, 3, 253);
    			attr_dev(div7, "class", "row no-gutters full-height");
    			add_location(div7, file$S, 5, 0, 131);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			mount_component(leftbanner, div0, null);
    			append_dev(div7, t0);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			if (if_block) if_block.m(div4, null);
    			append_dev(div4, t1);
    			append_dev(div4, h1);
    			append_dev(h1, t2);
    			append_dev(div4, t3);
    			append_dev(div4, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(ul, t6);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(ul, t8);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(ul, t10);
    			append_dev(ul, li3);
    			append_dev(li3, a3);
    			append_dev(div2, t12);
    			append_dev(div2, p0);
    			append_dev(div3, t14);
    			append_dev(div3, p1);
    			append_dev(div3, t16);
    			append_dev(div3, p2);
    			append_dev(div3, t18);
    			append_dev(div3, p3);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*step*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					if_block.m(div4, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*title*/ 1) set_data_dev(t2, /*title*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leftbanner.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leftbanner.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(leftbanner);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, ['default']);
    	let { title = '' } = $$props;
    	let { step = '' } = $$props;
    	const writable_props = ['title', 'step'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('step' in $$props) $$invalidate(1, step = $$props.step);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ LeftBanner: Leftbanner, title, step });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('step' in $$props) $$invalidate(1, step = $$props.step);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, step, $$scope, slots];
    }

    class Login$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Y, safe_not_equal, { title: 0, step: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get title() {
    		throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/FieldError.svelte generated by Svelte v3.41.0 */

    const { Object: Object_1$2 } = globals;
    const file$R = "src/components/FieldError.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (6:0) {#if errors.length && errors.filter(e => e.property == field).length > 0}
    function create_if_block$s(ctx) {
    	let each_1_anchor;
    	let each_value = Object.values(/*errors*/ ctx[0].find(/*func_1*/ ctx[4]).constraints);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, errors, field, label*/ 7) {
    				each_value = Object.values(/*errors*/ ctx[0].find(/*func_1*/ ctx[4]).constraints);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(6:0) {#if errors.length && errors.filter(e => e.property == field).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (7:4) {#each Object.values(errors.find(e => e.property == field).constraints) as msg }
    function create_each_block$e(ctx) {
    	let p;
    	let b;
    	let t1;
    	let t2_value = /*msg*/ ctx[5].split(/*field*/ ctx[1]).join(/*label*/ ctx[2]) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			b = element("b");
    			b.textContent = "X";
    			t1 = space();
    			t2 = text$1(t2_value);
    			add_location(b, file$R, 7, 39, 289);
    			attr_dev(p, "class", "email-error-message");
    			add_location(p, file$R, 7, 8, 258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, b);
    			append_dev(p, t1);
    			append_dev(p, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errors, field, label*/ 7 && t2_value !== (t2_value = /*msg*/ ctx[5].split(/*field*/ ctx[1]).join(/*label*/ ctx[2]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(7:4) {#each Object.values(errors.find(e => e.property == field).constraints) as msg }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let show_if = /*errors*/ ctx[0].length && /*errors*/ ctx[0].filter(/*func*/ ctx[3]).length > 0;
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*errors, field*/ 3) show_if = /*errors*/ ctx[0].length && /*errors*/ ctx[0].filter(/*func*/ ctx[3]).length > 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FieldError', slots, []);
    	let { errors = [] } = $$props;
    	let { field } = $$props;
    	let { label } = $$props;
    	const writable_props = ['errors', 'field', 'label'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FieldError> was created with unknown prop '${key}'`);
    	});

    	const func = e => e.property == field;
    	const func_1 = e => e.property == field;

    	$$self.$$set = $$props => {
    		if ('errors' in $$props) $$invalidate(0, errors = $$props.errors);
    		if ('field' in $$props) $$invalidate(1, field = $$props.field);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({ errors, field, label });

    	$$self.$inject_state = $$props => {
    		if ('errors' in $$props) $$invalidate(0, errors = $$props.errors);
    		if ('field' in $$props) $$invalidate(1, field = $$props.field);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [errors, field, label, func, func_1];
    }

    class FieldError extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$X, safe_not_equal, { errors: 0, field: 1, label: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FieldError",
    			options,
    			id: create_fragment$X.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*field*/ ctx[1] === undefined && !('field' in props)) {
    			console.warn("<FieldError> was created without expected prop 'field'");
    		}

    		if (/*label*/ ctx[2] === undefined && !('label' in props)) {
    			console.warn("<FieldError> was created without expected prop 'label'");
    		}
    	}

    	get errors() {
    		throw new Error("<FieldError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error("<FieldError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get field() {
    		throw new Error("<FieldError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set field(value) {
    		throw new Error("<FieldError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<FieldError>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FieldError>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/Registration.svelte generated by Svelte v3.41.0 */
    const file$Q = "src/pages/Registration.svelte";

    // (96:1) {#if !edit}
    function create_if_block$r(ctx) {
    	const block = { c: noop, m: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(96:1) {#if !edit}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let form;
    	let div0;
    	let input0;
    	let t0;
    	let label0;
    	let t2;
    	let fielderror0;
    	let t3;
    	let div1;
    	let input1;
    	let t4;
    	let label1;
    	let t6;
    	let fielderror1;
    	let t7;
    	let div2;
    	let input2;
    	let t8;
    	let label2;
    	let t10;
    	let fielderror2;
    	let t11;
    	let div3;
    	let input3;
    	let t12;
    	let label3;
    	let t14;
    	let fielderror3;
    	let t15;
    	let div4;
    	let input4;
    	let t16;
    	let label4;
    	let t18;
    	let fielderror4;
    	let t19;
    	let div5;
    	let t20;
    	let button;
    	let t21;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	fielderror0 = new FieldError({
    			props: {
    				errors: /*errors*/ ctx[3],
    				field: "first_name",
    				label: "First Name"
    			},
    			$$inline: true
    		});

    	fielderror1 = new FieldError({
    			props: {
    				errors: /*errors*/ ctx[3],
    				field: "last_name",
    				label: "Last Name"
    			},
    			$$inline: true
    		});

    	fielderror2 = new FieldError({
    			props: {
    				errors: /*errors*/ ctx[3],
    				field: "dob",
    				label: "Date of birth"
    			},
    			$$inline: true
    		});

    	fielderror3 = new FieldError({
    			props: {
    				errors: /*errors*/ ctx[3],
    				field: "mobile",
    				label: "Mobile"
    			},
    			$$inline: true
    		});

    	fielderror4 = new FieldError({
    			props: {
    				errors: /*errors*/ ctx[3],
    				field: "free_fire_id",
    				label: "Free fire ID"
    			},
    			$$inline: true
    		});

    	let if_block = !/*edit*/ ctx[0] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div0 = element("div");
    			input0 = element("input");
    			t0 = space();
    			label0 = element("label");
    			label0.textContent = "First Name*";
    			t2 = space();
    			create_component(fielderror0.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t4 = space();
    			label1 = element("label");
    			label1.textContent = "Last Name*";
    			t6 = space();
    			create_component(fielderror1.$$.fragment);
    			t7 = space();
    			div2 = element("div");
    			input2 = element("input");
    			t8 = space();
    			label2 = element("label");
    			label2.textContent = "Date of Birth (dd/mm/yyyy)*";
    			t10 = space();
    			create_component(fielderror2.$$.fragment);
    			t11 = space();
    			div3 = element("div");
    			input3 = element("input");
    			t12 = space();
    			label3 = element("label");
    			label3.textContent = "Mobile Number*";
    			t14 = space();
    			create_component(fielderror3.$$.fragment);
    			t15 = space();
    			div4 = element("div");
    			input4 = element("input");
    			t16 = space();
    			label4 = element("label");
    			label4.textContent = "Free Fire ID*";
    			t18 = space();
    			create_component(fielderror4.$$.fragment);
    			t19 = space();
    			div5 = element("div");
    			if (if_block) if_block.c();
    			t20 = space();
    			button = element("button");
    			t21 = text$1("Proceed");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", " ");
    			attr_dev(input0, "class", "text-box");
    			attr_dev(input0, "id", "firstname");
    			attr_dev(input0, "maxlength", "20");
    			add_location(input0, file$Q, 70, 2, 1901);
    			attr_dev(label0, "class", "lbl-txt");
    			attr_dev(label0, "for", "firstname");
    			add_location(label0, file$Q, 71, 2, 2015);
    			attr_dev(div0, "class", "form-group field svelte-1fe7qjh");
    			add_location(div0, file$Q, 69, 1, 1868);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", " ");
    			attr_dev(input1, "class", "text-box");
    			attr_dev(input1, "id", "lastname");
    			attr_dev(input1, "maxlength", "20");
    			add_location(input1, file$Q, 75, 2, 2180);
    			attr_dev(label1, "class", "lbl-txt");
    			attr_dev(label1, "for", "lastname");
    			add_location(label1, file$Q, 76, 2, 2292);
    			attr_dev(div1, "class", "form-group svelte-1fe7qjh");
    			add_location(div1, file$Q, 74, 1, 2153);
    			attr_dev(input2, "type", "date");
    			attr_dev(input2, "placeholder", "dd/mm/yyyy");
    			attr_dev(input2, "class", "text-box");
    			attr_dev(input2, "id", "date");
    			attr_dev(input2, "maxlength", "10");
    			add_location(input2, file$Q, 80, 2, 2453);
    			attr_dev(label2, "class", "lbl-txt");
    			attr_dev(label2, "for", "date");
    			add_location(label2, file$Q, 81, 2, 2586);
    			attr_dev(div2, "class", "form-group svelte-1fe7qjh");
    			add_location(div2, file$Q, 79, 1, 2426);
    			attr_dev(input3, "type", "tel");
    			attr_dev(input3, "placeholder", " ");
    			attr_dev(input3, "class", "text-box");
    			attr_dev(input3, "maxlength", "10");
    			attr_dev(input3, "id", "mobile");
    			add_location(input3, file$Q, 85, 2, 2758);
    			attr_dev(label3, "class", "lbl-txt");
    			attr_dev(label3, "for", "mobile");
    			add_location(label3, file$Q, 86, 2, 2864);
    			attr_dev(div3, "class", "form-group svelte-1fe7qjh");
    			add_location(div3, file$Q, 84, 1, 2731);
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "placeholder", " ");
    			attr_dev(input4, "class", "text-box");
    			attr_dev(input4, "id", "freeFireId");
    			attr_dev(input4, "maxlength", "10");
    			add_location(input4, file$Q, 90, 2, 3021);
    			attr_dev(label4, "class", "lbl-txt");
    			attr_dev(label4, "for", "freeFireId");
    			add_location(label4, file$Q, 91, 2, 3138);
    			attr_dev(div4, "class", "form-group svelte-1fe7qjh");
    			add_location(div4, file$Q, 89, 1, 2994);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary submit-btn");
    			button.disabled = button_disabled_value = /*user*/ ctx[1].first_name.length == 0 || /*user*/ ctx[1].last_name.length == 0 || /*user*/ ctx[1].dob == "" || /*user*/ ctx[1].mobile.length < 10 || /*user*/ ctx[1].free_fire_id.length < 8;
    			add_location(button, file$Q, 98, 1, 3545);
    			attr_dev(div5, "class", "btn-section");
    			add_location(div5, file$Q, 94, 1, 3283);
    			add_location(form, file$Q, 68, 0, 1824);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*user*/ ctx[1].first_name);
    			append_dev(div0, t0);
    			append_dev(div0, label0);
    			append_dev(div0, t2);
    			mount_component(fielderror0, div0, null);
    			append_dev(form, t3);
    			append_dev(form, div1);
    			append_dev(div1, input1);
    			set_input_value(input1, /*user*/ ctx[1].last_name);
    			append_dev(div1, t4);
    			append_dev(div1, label1);
    			append_dev(div1, t6);
    			mount_component(fielderror1, div1, null);
    			append_dev(form, t7);
    			append_dev(form, div2);
    			append_dev(div2, input2);
    			set_input_value(input2, /*user*/ ctx[1].dob);
    			/*input2_binding*/ ctx[10](input2);
    			append_dev(div2, t8);
    			append_dev(div2, label2);
    			append_dev(div2, t10);
    			mount_component(fielderror2, div2, null);
    			append_dev(form, t11);
    			append_dev(form, div3);
    			append_dev(div3, input3);
    			set_input_value(input3, /*user*/ ctx[1].mobile);
    			append_dev(div3, t12);
    			append_dev(div3, label3);
    			append_dev(div3, t14);
    			mount_component(fielderror3, div3, null);
    			append_dev(form, t15);
    			append_dev(form, div4);
    			append_dev(div4, input4);
    			set_input_value(input4, /*user*/ ctx[1].free_fire_id);
    			append_dev(div4, t16);
    			append_dev(div4, label4);
    			append_dev(div4, t18);
    			mount_component(fielderror4, div4, null);
    			append_dev(form, t19);
    			append_dev(form, div5);
    			if (if_block) if_block.m(div5, null);
    			append_dev(div5, t20);
    			append_dev(div5, button);
    			append_dev(button, t21);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[9]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[11]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[12]),
    					listen_dev(form, "submit", prevent_default(/*onSubmit*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*user*/ 2 && input0.value !== /*user*/ ctx[1].first_name) {
    				set_input_value(input0, /*user*/ ctx[1].first_name);
    			}

    			const fielderror0_changes = {};
    			if (dirty & /*errors*/ 8) fielderror0_changes.errors = /*errors*/ ctx[3];
    			fielderror0.$set(fielderror0_changes);

    			if (dirty & /*user*/ 2 && input1.value !== /*user*/ ctx[1].last_name) {
    				set_input_value(input1, /*user*/ ctx[1].last_name);
    			}

    			const fielderror1_changes = {};
    			if (dirty & /*errors*/ 8) fielderror1_changes.errors = /*errors*/ ctx[3];
    			fielderror1.$set(fielderror1_changes);

    			if (dirty & /*user*/ 2) {
    				set_input_value(input2, /*user*/ ctx[1].dob);
    			}

    			const fielderror2_changes = {};
    			if (dirty & /*errors*/ 8) fielderror2_changes.errors = /*errors*/ ctx[3];
    			fielderror2.$set(fielderror2_changes);

    			if (dirty & /*user*/ 2) {
    				set_input_value(input3, /*user*/ ctx[1].mobile);
    			}

    			const fielderror3_changes = {};
    			if (dirty & /*errors*/ 8) fielderror3_changes.errors = /*errors*/ ctx[3];
    			fielderror3.$set(fielderror3_changes);

    			if (dirty & /*user*/ 2 && input4.value !== /*user*/ ctx[1].free_fire_id) {
    				set_input_value(input4, /*user*/ ctx[1].free_fire_id);
    			}

    			const fielderror4_changes = {};
    			if (dirty & /*errors*/ 8) fielderror4_changes.errors = /*errors*/ ctx[3];
    			fielderror4.$set(fielderror4_changes);

    			if (!/*edit*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					if_block.m(div5, t20);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*user*/ 2 && button_disabled_value !== (button_disabled_value = /*user*/ ctx[1].first_name.length == 0 || /*user*/ ctx[1].last_name.length == 0 || /*user*/ ctx[1].dob == "" || /*user*/ ctx[1].mobile.length < 10 || /*user*/ ctx[1].free_fire_id.length < 8)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fielderror0.$$.fragment, local);
    			transition_in(fielderror1.$$.fragment, local);
    			transition_in(fielderror2.$$.fragment, local);
    			transition_in(fielderror3.$$.fragment, local);
    			transition_in(fielderror4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fielderror0.$$.fragment, local);
    			transition_out(fielderror1.$$.fragment, local);
    			transition_out(fielderror2.$$.fragment, local);
    			transition_out(fielderror3.$$.fragment, local);
    			transition_out(fielderror4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(fielderror0);
    			destroy_component(fielderror1);
    			/*input2_binding*/ ctx[10](null);
    			destroy_component(fielderror2);
    			destroy_component(fielderror3);
    			destroy_component(fielderror4);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $currentUser;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Registration', slots, []);
    	let { edit = false } = $$props;
    	const userModel = User.getInstance();
    	const currentUser = User.getUser();
    	validate_store(currentUser, 'currentUser');
    	component_subscribe($$self, currentUser, value => $$invalidate(13, $currentUser = value));
    	let errors = [];

    	let user = {
    		first_name: "",
    		last_name: "",
    		dob: "",
    		mobile: "",
    		free_fire_id: ""
    	};

    	const isSafari = () => {
    		var ua = window.navigator.userAgent.toLowerCase();
    		return ua.indexOf('macintosh') != -1;
    	};

    	isSafari();

    	if (edit) {
    		user = (({ first_name, last_name, dob, mobile, free_fire_id }) => ({
    			first_name,
    			last_name,
    			dob,
    			mobile,
    			free_fire_id
    		}))({ ...$currentUser });
    	}

    	const onSubmit = async e => {
    		if (!edit) {
    			let data = await userModel.register({
    				...user,
    				contest: window.localStorage.getItem('enterContest')
    				? true
    				: false
    			});

    			if (data.error) $$invalidate(3, errors = data.error); else if (window.localStorage.getItem('enterContest')) window.localStorage.removeItem('enterContest');
    			window.localStorage.setItem('firstLogin', true);
    		} else {
    			let res = await userModel.update(user);

    			if (!res.error) {
    				notyf.success('Updated successfully!');
    				Modal.close();
    			} else {
    				$$invalidate(3, errors = res.error);
    			}
    		}
    	};

    	let dateUpdated = false;
    	let dateField;
    	const writable_props = ['edit'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Registration> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		user.first_name = this.value;
    		(($$invalidate(1, user), $$invalidate(2, dateField)), $$invalidate(6, dateUpdated));
    	}

    	function input1_input_handler() {
    		user.last_name = this.value;
    		(($$invalidate(1, user), $$invalidate(2, dateField)), $$invalidate(6, dateUpdated));
    	}

    	function input2_input_handler() {
    		user.dob = this.value;
    		(($$invalidate(1, user), $$invalidate(2, dateField)), $$invalidate(6, dateUpdated));
    	}

    	function input2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			dateField = $$value;
    			$$invalidate(2, dateField);
    		});
    	}

    	function input3_input_handler() {
    		user.mobile = this.value;
    		(($$invalidate(1, user), $$invalidate(2, dateField)), $$invalidate(6, dateUpdated));
    	}

    	function input4_input_handler() {
    		user.free_fire_id = this.value;
    		(($$invalidate(1, user), $$invalidate(2, dateField)), $$invalidate(6, dateUpdated));
    	}

    	$$self.$$set = $$props => {
    		if ('edit' in $$props) $$invalidate(0, edit = $$props.edit);
    	};

    	$$self.$capture_state = () => ({
    		User,
    		FieldError,
    		Toast: notyf,
    		Modal,
    		moment,
    		edit,
    		userModel,
    		currentUser,
    		errors,
    		user,
    		isSafari,
    		onSubmit,
    		dateUpdated,
    		dateField,
    		$currentUser
    	});

    	$$self.$inject_state = $$props => {
    		if ('edit' in $$props) $$invalidate(0, edit = $$props.edit);
    		if ('errors' in $$props) $$invalidate(3, errors = $$props.errors);
    		if ('user' in $$props) $$invalidate(1, user = $$props.user);
    		if ('dateUpdated' in $$props) $$invalidate(6, dateUpdated = $$props.dateUpdated);
    		if ('dateField' in $$props) $$invalidate(2, dateField = $$props.dateField);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*user*/ 2) {
    			((() => {
    				let mobile = user.mobile.replace(/[^0-9]/g, '');
    				if (mobile != user.mobile) $$invalidate(1, user = { ...user, mobile });
    				let free_fire_id = user.free_fire_id.replace(/[^0-9]/g, '');
    				if (free_fire_id != user.free_fire_id) $$invalidate(1, user = { ...user, free_fire_id });
    			})());
    		}

    		if ($$self.$$.dirty & /*dateField, dateUpdated, user*/ 70) {
    			((() => {
    				if (dateField && !dateUpdated) {
    					if (dateField.type == 'date') $$invalidate(1, user.dob = moment(user.dob).format('YYYY-MM-DD'), user); else $$invalidate(1, user.dob = moment(user.dob).format('DD/MM/YYYY'), user);
    					$$invalidate(6, dateUpdated = true);
    				}
    			})());
    		}
    	};

    	return [
    		edit,
    		user,
    		dateField,
    		errors,
    		currentUser,
    		onSubmit,
    		dateUpdated,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input2_binding,
    		input3_input_handler,
    		input4_input_handler
    	];
    }

    class Registration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$W, safe_not_equal, { edit: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Registration",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get edit() {
    		throw new Error("<Registration>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edit(value) {
    		throw new Error("<Registration>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Video.svelte generated by Svelte v3.41.0 */

    const file$P = "src/components/Video.svelte";

    // (15:4) {#if isLive}
    function create_if_block$q(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Live now";
    			attr_dev(button, "class", "btn btn-danger btn-sm live-btn");
    			add_location(button, file$P, 15, 8, 367);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(15:4) {#if isLive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let a;
    	let img;
    	let img_src_value;
    	let t1;
    	let span1;
    	let span0;
    	let div1_class_value;
    	let if_block = /*isLive*/ ctx[3] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			a = element("a");
    			img = element("img");
    			t1 = space();
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "play_arrow";
    			if (!src_url_equal(img.src, img_src_value = /*thumb*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "video");
    			add_location(img, file$P, 20, 12, 583);
    			attr_dev(span0, "class", "material-icons");
    			add_location(span0, file$P, 22, 16, 676);
    			attr_dev(span1, "href", "#");
    			attr_dev(span1, "class", "play-btn svelte-1jth7ul");
    			add_location(span1, file$P, 21, 12, 627);
    			attr_dev(a, "href", /*url*/ ctx[0]);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$P, 18, 8, 486);
    			attr_dev(div0, "class", "video-thumbnail");
    			add_location(div0, file$P, 17, 4, 448);
    			attr_dev(div1, "class", div1_class_value = "video-thumb " + /*classes*/ ctx[2] + " svelte-1jth7ul");
    			add_location(div1, file$P, 13, 0, 306);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			append_dev(a, img);
    			append_dev(a, t1);
    			append_dev(a, span1);
    			append_dev(span1, span0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isLive*/ ctx[3]) {
    				if (if_block) ; else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(div1, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*thumb*/ 2 && !src_url_equal(img.src, img_src_value = /*thumb*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*url*/ 1) {
    				attr_dev(a, "href", /*url*/ ctx[0]);
    			}

    			if (dirty & /*classes*/ 4 && div1_class_value !== (div1_class_value = "video-thumb " + /*classes*/ ctx[2] + " svelte-1jth7ul")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Video', slots, []);
    	let { url } = $$props;
    	let { thumb } = $$props;
    	let { classes = '' } = $$props;
    	let { video } = $$props;
    	let isLive = false;

    	if (video) {
    		url = video.url;
    		thumb = `https://snapdragonconquest.com/uploads/originals/${video.filename_disk}`;
    		isLive = video.live == 1;
    	}

    	const writable_props = ['url', 'thumb', 'classes', 'video'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Video> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('url' in $$props) $$invalidate(0, url = $$props.url);
    		if ('thumb' in $$props) $$invalidate(1, thumb = $$props.thumb);
    		if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
    		if ('video' in $$props) $$invalidate(4, video = $$props.video);
    	};

    	$$self.$capture_state = () => ({ url, thumb, classes, video, isLive });

    	$$self.$inject_state = $$props => {
    		if ('url' in $$props) $$invalidate(0, url = $$props.url);
    		if ('thumb' in $$props) $$invalidate(1, thumb = $$props.thumb);
    		if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
    		if ('video' in $$props) $$invalidate(4, video = $$props.video);
    		if ('isLive' in $$props) $$invalidate(3, isLive = $$props.isLive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [url, thumb, classes, isLive, video];
    }

    class Video extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$V, safe_not_equal, { url: 0, thumb: 1, classes: 2, video: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Video",
    			options,
    			id: create_fragment$V.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*url*/ ctx[0] === undefined && !('url' in props)) {
    			console.warn("<Video> was created without expected prop 'url'");
    		}

    		if (/*thumb*/ ctx[1] === undefined && !('thumb' in props)) {
    			console.warn("<Video> was created without expected prop 'thumb'");
    		}

    		if (/*video*/ ctx[4] === undefined && !('video' in props)) {
    			console.warn("<Video> was created without expected prop 'video'");
    		}
    	}

    	get url() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get thumb() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumb(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get video() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set video(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/Login.svelte generated by Svelte v3.41.0 */
    const file$O = "src/pages/Login.svelte";

    // (56:3) {#if !otpSent}
    function create_if_block_3$5(ctx) {
    	let small;

    	const block = {
    		c: function create() {
    			small = element("small");
    			small.textContent = "You will recieve an OTP for verification";
    			attr_dev(small, "id", "mail");
    			attr_dev(small, "class", "form-text text-muted");
    			add_location(small, file$O, 56, 4, 1865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, small, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(small);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(56:3) {#if !otpSent}",
    		ctx
    	});

    	return block;
    }

    // (89:2) {:else}
    function create_else_block_2$1(ctx) {
    	let div;
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t = text$1("Verify");
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary verify-btn");
    			button.disabled = /*disableButton*/ ctx[6];
    			add_location(button, file$O, 90, 4, 3126);
    			attr_dev(div, "class", "btn-section svelte-v91jvh");
    			add_location(div, file$O, 89, 3, 3096);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onOTPRequest*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*disableButton*/ 64) {
    				prop_dev(button, "disabled", /*disableButton*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(89:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:2) {#if otpSent }
    function create_if_block$p(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*name*/ ctx[5]) return create_if_block_1$e;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(60:2) {#if otpSent }",
    		ctx
    	});

    	return block;
    }

    // (86:3) {:else}
    function create_else_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Registeration are closed! Please sign in if you have already registered.";
    			attr_dev(span, "class", "resend-txt");
    			add_location(span, file$O, 86, 4, 2969);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(86:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (61:3) {#if name}
    function create_if_block_1$e(ctx) {
    	let div0;
    	let input;
    	let t0;
    	let label;
    	let t2;
    	let div1;
    	let button;
    	let t3;
    	let button_disabled_value;
    	let t4;
    	let span0;
    	let t5;
    	let t6;
    	let br0;
    	let br1;
    	let t7;
    	let span1;
    	let mounted;
    	let dispose;

    	function select_block_type_2(ctx, dirty) {
    		if (/*timer*/ ctx[3] > 0) return create_if_block_2$a;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			label.textContent = "Enter 6 digit OTP";
    			t2 = space();
    			div1 = element("div");
    			button = element("button");
    			t3 = text$1("Verify");
    			t4 = space();
    			span0 = element("span");
    			t5 = text$1("Haven’t received OTP? \n\t\t\t\t\t\t");
    			if_block.c();
    			t6 = space();
    			br0 = element("br");
    			br1 = element("br");
    			t7 = space();
    			span1 = element("span");
    			span1.textContent = "In case you did not receive the OTP, please check your spam/junk folder too";
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "text-box");
    			attr_dev(input, "placeholder", " ");
    			attr_dev(input, "id", "otp");
    			attr_dev(input, "maxlength", "6");
    			add_location(input, file$O, 62, 5, 2043);
    			attr_dev(label, "class", "lbl-txt");
    			attr_dev(label, "for", "otp");
    			add_location(label, file$O, 63, 5, 2142);
    			attr_dev(div0, "class", "form-group");
    			add_location(div0, file$O, 61, 4, 2013);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary verify-btn");
    			button.disabled = button_disabled_value = !(/*name*/ ctx[5] || !/*name*/ ctx[5] && /*tnc*/ ctx[9]);
    			add_location(button, file$O, 66, 5, 2248);
    			attr_dev(span0, "class", "resend-txt");
    			add_location(span0, file$O, 75, 5, 2593);
    			add_location(br0, file$O, 82, 12, 2819);
    			add_location(br1, file$O, 82, 17, 2824);
    			attr_dev(span1, "class", "resend-txt");
    			add_location(span1, file$O, 83, 5, 2835);
    			attr_dev(div1, "class", "btn-section svelte-v91jvh");
    			add_location(div1, file$O, 65, 4, 2217);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, input);
    			set_input_value(input, /*otp*/ ctx[1]);
    			append_dev(div0, t0);
    			append_dev(div0, label);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, t3);
    			append_dev(div1, t4);
    			append_dev(div1, span0);
    			append_dev(span0, t5);
    			if_block.m(span0, null);
    			append_dev(span0, t6);
    			append_dev(div1, br0);
    			append_dev(div1, br1);
    			append_dev(div1, t7);
    			append_dev(div1, span1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[12]),
    					listen_dev(button, "click", /*click_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*otp*/ 2 && input.value !== /*otp*/ ctx[1]) {
    				set_input_value(input, /*otp*/ ctx[1]);
    			}

    			if (dirty & /*name*/ 32 && button_disabled_value !== (button_disabled_value = !(/*name*/ ctx[5] || !/*name*/ ctx[5] && /*tnc*/ ctx[9]))) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span0, t6);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(61:3) {#if name}",
    		ctx
    	});

    	return block;
    }

    // (80:6) {:else}
    function create_else_block$e(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Resend OTP";
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "resend-otp");
    			add_location(a, file$O, 80, 6, 2725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onOTPRequest*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(80:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (78:6) {#if timer>0}
    function create_if_block_2$a(ctx) {
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text$1("Request OTP in ");
    			t1 = text$1(/*timer*/ ctx[3]);
    			t2 = text$1(" seconds");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*timer*/ 8) set_data_dev(t1, /*timer*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(78:6) {#if timer>0}",
    		ctx
    	});

    	return block;
    }

    // (51:0) <LoginLayout title={register ? 'Your Details' : otpSent ? name ? `Hi ${name}, Confirm OTP` : 'Confirm OTP' : 'Sign In'} step={register ? '1' : ''}>
    function create_default_slot$8(ctx) {
    	let form;
    	let div;
    	let input;
    	let t0;
    	let label;
    	let t2;
    	let t3;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*otpSent*/ ctx[2] && create_if_block_3$5(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*otpSent*/ ctx[2]) return create_if_block$p;
    		return create_else_block_2$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			label.textContent = "Your Email*";
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if_block1.c();
    			attr_dev(input, "type", "email");
    			attr_dev(input, "class", "text-box");
    			attr_dev(input, "id", "mail");
    			attr_dev(input, "placeholder", " ");
    			add_location(input, file$O, 53, 3, 1703);
    			attr_dev(label, "class", "lbl-txt");
    			attr_dev(label, "for", "mail");
    			add_location(label, file$O, 54, 3, 1789);
    			attr_dev(div, "class", "form-group field");
    			add_location(div, file$O, 52, 2, 1669);
    			add_location(form, file$O, 51, 1, 1660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div);
    			append_dev(div, input);
    			set_input_value(input, /*email*/ ctx[0]);
    			append_dev(div, t0);
    			append_dev(div, label);
    			append_dev(div, t2);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(form, t3);
    			if_block1.m(form, null);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[11]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*email*/ 1 && input.value !== /*email*/ ctx[0]) {
    				set_input_value(input, /*email*/ ctx[0]);
    			}

    			if (!/*otpSent*/ ctx[2]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_3$5(ctx);
    					if_block0.c();
    					if_block0.m(div, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(form, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(51:0) <LoginLayout title={register ? 'Your Details' : otpSent ? name ? `Hi ${name}, Confirm OTP` : 'Confirm OTP' : 'Sign In'} step={register ? '1' : ''}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let loginlayout;
    	let current;

    	loginlayout = new Login$1({
    			props: {
    				title: /*register*/ ctx[4]
    				? 'Your Details'
    				: /*otpSent*/ ctx[2]
    					? /*name*/ ctx[5]
    						? `Hi ${/*name*/ ctx[5]}, Confirm OTP`
    						: 'Confirm OTP'
    					: 'Sign In',
    				step: /*register*/ ctx[4] ? '1' : '',
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loginlayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(loginlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const loginlayout_changes = {};

    			if (dirty & /*register, otpSent, name*/ 52) loginlayout_changes.title = /*register*/ ctx[4]
    			? 'Your Details'
    			: /*otpSent*/ ctx[2]
    				? /*name*/ ctx[5]
    					? `Hi ${/*name*/ ctx[5]}, Confirm OTP`
    					: 'Confirm OTP'
    				: 'Sign In';

    			if (dirty & /*register*/ 16) loginlayout_changes.step = /*register*/ ctx[4] ? '1' : '';

    			if (dirty & /*$$scope, timer, name, email, otp, register, otpSent, disableButton*/ 65663) {
    				loginlayout_changes.$$scope = { dirty, ctx };
    			}

    			loginlayout.$set(loginlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loginlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let disableButton;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, []);
    	let original = 60; // TYPE NUMBER OF SECONDS HERE
    	let timer = 60;

    	const startTimer = () => {
    		$$invalidate(3, timer = original);

    		let interval = setInterval(
    			() => {
    				if (timer > 0) $$invalidate(3, timer = timer - 1); else clearInterval(interval);
    			},
    			1000
    		);
    	};

    	let user = User.getInstance();
    	let email = '';
    	let otp = '';
    	let otpSent = false;
    	let register = false;
    	let otpEmail;
    	let name;

    	const onOTPRequest = async e => {
    		e.preventDefault();
    		let result = await user.getOTP(email);

    		if (result) {
    			if (result.first_name) $$invalidate(5, name = `${result.first_name} ${result.last_name}`);
    			$$invalidate(10, otpEmail = email);
    			startTimer();
    			$$invalidate(2, otpSent = true);
    		}
    	};

    	let tnc = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		email = this.value;
    		$$invalidate(0, email);
    	}

    	function input_input_handler_1() {
    		otp = this.value;
    		$$invalidate(1, otp);
    	}

    	const click_handler = async e => {
    		e.preventDefault();
    		let data = await user.getToken(email, otp);

    		if (data && data.register) {
    			$$invalidate(4, register = true);
    		} //document.location.reload();
    	};

    	$$self.$capture_state = () => ({
    		LoginLayout: Login$1,
    		User,
    		Registration,
    		Video,
    		original,
    		timer,
    		startTimer,
    		user,
    		email,
    		otp,
    		otpSent,
    		register,
    		otpEmail,
    		name,
    		onOTPRequest,
    		tnc,
    		disableButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('original' in $$props) original = $$props.original;
    		if ('timer' in $$props) $$invalidate(3, timer = $$props.timer);
    		if ('user' in $$props) $$invalidate(7, user = $$props.user);
    		if ('email' in $$props) $$invalidate(0, email = $$props.email);
    		if ('otp' in $$props) $$invalidate(1, otp = $$props.otp);
    		if ('otpSent' in $$props) $$invalidate(2, otpSent = $$props.otpSent);
    		if ('register' in $$props) $$invalidate(4, register = $$props.register);
    		if ('otpEmail' in $$props) $$invalidate(10, otpEmail = $$props.otpEmail);
    		if ('name' in $$props) $$invalidate(5, name = $$props.name);
    		if ('tnc' in $$props) $$invalidate(9, tnc = $$props.tnc);
    		if ('disableButton' in $$props) $$invalidate(6, disableButton = $$props.disableButton);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*otp*/ 2) {
    			((() => {
    				let numOnly = otp.replace(/[^0-9]/g, '');
    				if (otp != numOnly) $$invalidate(1, otp = numOnly);
    			})());
    		}

    		if ($$self.$$.dirty & /*email, otpEmail*/ 1025) {
    			$$invalidate(2, otpSent = email == otpEmail);
    		}

    		if ($$self.$$.dirty & /*otpSent, otp, email*/ 7) {
    			$$invalidate(6, disableButton = otpSent
    			? otp.length != 6
    			: !(/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/).test(email));
    		}
    	};

    	return [
    		email,
    		otp,
    		otpSent,
    		timer,
    		register,
    		name,
    		disableButton,
    		user,
    		onOTPRequest,
    		tnc,
    		otpEmail,
    		input_input_handler,
    		input_input_handler_1,
    		click_handler
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /* node_modules/svelte-select/src/Item.svelte generated by Svelte v3.41.0 */

    const file$N = "node_modules/svelte-select/src/Item.svelte";

    function create_fragment$T(ctx) {
    	let div;
    	let raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "";
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-bdnybl");
    			add_location(div, file$N, 61, 0, 1353);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getOptionLabel, item, filterText*/ 7 && raw_value !== (raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "")) div.innerHTML = raw_value;
    			if (dirty & /*itemClasses*/ 8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-bdnybl")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Item', slots, []);
    	let { isActive = false } = $$props;
    	let { isFirst = false } = $$props;
    	let { isHover = false } = $$props;
    	let { getOptionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	let { filterText = '' } = $$props;
    	let itemClasses = '';
    	const writable_props = ['isActive', 'isFirst', 'isHover', 'getOptionLabel', 'item', 'filterText'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Item> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		isActive,
    		isFirst,
    		isHover,
    		getOptionLabel,
    		item,
    		filterText,
    		itemClasses
    	});

    	$$self.$inject_state = $$props => {
    		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
    		if ('itemClasses' in $$props) $$invalidate(3, itemClasses = $$props.itemClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive, isFirst, isHover, item*/ 114) {
    			{
    				const classes = [];

    				if (isActive) {
    					classes.push('active');
    				}

    				if (isFirst) {
    					classes.push('first');
    				}

    				if (isHover) {
    					classes.push('hover');
    				}

    				if (item.isGroupHeader) {
    					classes.push('groupHeader');
    				}

    				if (item.isGroupItem) {
    					classes.push('groupItem');
    				}

    				$$invalidate(3, itemClasses = classes.join(' '));
    			}
    		}
    	};

    	return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$U, create_fragment$T, safe_not_equal, {
    			isActive: 4,
    			isFirst: 5,
    			isHover: 6,
    			getOptionLabel: 0,
    			item: 1,
    			filterText: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get isActive() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFirst() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFirst(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isHover() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isHover(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-select/src/VirtualList.svelte generated by Svelte v3.41.0 */
    const file$M = "node_modules/svelte-select/src/VirtualList.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes$2 = dirty => ({
    	item: dirty & /*visible*/ 32,
    	i: dirty & /*visible*/ 32,
    	hoverItemIndex: dirty & /*hoverItemIndex*/ 2
    });

    const get_default_slot_context$2 = ctx => ({
    	item: /*row*/ ctx[23].data,
    	i: /*row*/ ctx[23].index,
    	hoverItemIndex: /*hoverItemIndex*/ ctx[1]
    });

    // (160:57) Missing template
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Missing template");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(160:57) Missing template",
    		ctx
    	});

    	return block;
    }

    // (158:2) {#each visible as row (row.index)}
    function create_each_block$d(key_1, ctx) {
    	let svelte_virtual_list_row;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$2);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			svelte_virtual_list_row = element("svelte-virtual-list-row");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-p6ehlv");
    			add_location(svelte_virtual_list_row, file$M, 158, 3, 3514);
    			this.first = svelte_virtual_list_row;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_row, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svelte_virtual_list_row, null);
    			}

    			append_dev(svelte_virtual_list_row, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, visible, hoverItemIndex*/ 16418)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes$2),
    						get_default_slot_context$2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_row);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(158:2) {#each visible as row (row.index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let svelte_virtual_list_viewport;
    	let svelte_virtual_list_contents;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let svelte_virtual_list_viewport_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visible*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[23].index;
    	validate_each_keys(ctx, each_value, get_each_context$d, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$d(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
    			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-p6ehlv");
    			add_location(svelte_virtual_list_contents, file$M, 156, 1, 3364);
    			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-p6ehlv");
    			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].call(svelte_virtual_list_viewport));
    			add_location(svelte_virtual_list_viewport, file$M, 154, 0, 3222);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_viewport, anchor);
    			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svelte_virtual_list_contents, null);
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](svelte_virtual_list_contents);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](svelte_virtual_list_viewport);
    			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].bind(svelte_virtual_list_viewport));
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
    				each_value = /*visible*/ ctx[5];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$d, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$d, null, get_each_context$d);
    				check_outros();
    			}

    			if (!current || dirty & /*top*/ 64) {
    				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*bottom*/ 128) {
    				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			}

    			if (!current || dirty & /*height*/ 1) {
    				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_viewport);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](null);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](null);
    			svelte_virtual_list_viewport_resize_listener();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VirtualList', slots, ['default']);
    	let { items = undefined } = $$props;
    	let { height = '100%' } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { start = 0 } = $$props;
    	let { end = 0 } = $$props;

    	// local state
    	let height_map = [];

    	let rows;
    	let viewport;
    	let contents;
    	let viewport_height = 0;
    	let visible;
    	let mounted;
    	let top = 0;
    	let bottom = 0;
    	let average_height;

    	async function refresh(items, viewport_height, itemHeight) {
    		const { scrollTop } = viewport;
    		await tick(); // wait until the DOM is up to date
    		let content_height = top - scrollTop;
    		let i = start;

    		while (content_height < viewport_height && i < items.length) {
    			let row = rows[i - start];

    			if (!row) {
    				$$invalidate(10, end = i + 1);
    				await tick(); // render the newly visible row
    				row = rows[i - start];
    			}

    			const row_height = height_map[i] = itemHeight || row.offsetHeight;
    			content_height += row_height;
    			i += 1;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = (top + content_height) / end;
    		$$invalidate(7, bottom = remaining * average_height);
    		height_map.length = items.length;
    		$$invalidate(3, viewport.scrollTop = 0, viewport);
    	}

    	async function handle_scroll() {
    		const { scrollTop } = viewport;
    		const old_start = start;

    		for (let v = 0; v < rows.length; v += 1) {
    			height_map[start + v] = itemHeight || rows[v].offsetHeight;
    		}

    		let i = 0;
    		let y = 0;

    		while (i < items.length) {
    			const row_height = height_map[i] || average_height;

    			if (y + row_height > scrollTop) {
    				$$invalidate(9, start = i);
    				$$invalidate(6, top = y);
    				break;
    			}

    			y += row_height;
    			i += 1;
    		}

    		while (i < items.length) {
    			y += height_map[i] || average_height;
    			i += 1;
    			if (y > scrollTop + viewport_height) break;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = y / end;
    		while (i < items.length) height_map[i++] = average_height;
    		$$invalidate(7, bottom = remaining * average_height);

    		// prevent jumping if we scrolled up into unknown territory
    		if (start < old_start) {
    			await tick();
    			let expected_height = 0;
    			let actual_height = 0;

    			for (let i = start; i < old_start; i += 1) {
    				if (rows[i - start]) {
    					expected_height += height_map[i];
    					actual_height += itemHeight || rows[i - start].offsetHeight;
    				}
    			}

    			const d = actual_height - expected_height;
    			viewport.scrollTo(0, scrollTop + d);
    		}
    	} // TODO if we overestimated the space these
    	// rows would occupy we may need to add some

    	// more. maybe we can just call handle_scroll again?
    	// trigger initial refresh
    	onMount(() => {
    		rows = contents.getElementsByTagName('svelte-virtual-list-row');
    		$$invalidate(13, mounted = true);
    	});

    	const writable_props = ['items', 'height', 'itemHeight', 'hoverItemIndex', 'start', 'end'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VirtualList> was created with unknown prop '${key}'`);
    	});

    	function svelte_virtual_list_contents_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contents = $$value;
    			$$invalidate(4, contents);
    		});
    	}

    	function svelte_virtual_list_viewport_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			viewport = $$value;
    			$$invalidate(3, viewport);
    		});
    	}

    	function svelte_virtual_list_viewport_elementresize_handler() {
    		viewport_height = this.offsetHeight;
    		$$invalidate(2, viewport_height);
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(11, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('start' in $$props) $$invalidate(9, start = $$props.start);
    		if ('end' in $$props) $$invalidate(10, end = $$props.end);
    		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		items,
    		height,
    		itemHeight,
    		hoverItemIndex,
    		start,
    		end,
    		height_map,
    		rows,
    		viewport,
    		contents,
    		viewport_height,
    		visible,
    		mounted,
    		top,
    		bottom,
    		average_height,
    		refresh,
    		handle_scroll
    	});

    	$$self.$inject_state = $$props => {
    		if ('items' in $$props) $$invalidate(11, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('start' in $$props) $$invalidate(9, start = $$props.start);
    		if ('end' in $$props) $$invalidate(10, end = $$props.end);
    		if ('height_map' in $$props) height_map = $$props.height_map;
    		if ('rows' in $$props) rows = $$props.rows;
    		if ('viewport' in $$props) $$invalidate(3, viewport = $$props.viewport);
    		if ('contents' in $$props) $$invalidate(4, contents = $$props.contents);
    		if ('viewport_height' in $$props) $$invalidate(2, viewport_height = $$props.viewport_height);
    		if ('visible' in $$props) $$invalidate(5, visible = $$props.visible);
    		if ('mounted' in $$props) $$invalidate(13, mounted = $$props.mounted);
    		if ('top' in $$props) $$invalidate(6, top = $$props.top);
    		if ('bottom' in $$props) $$invalidate(7, bottom = $$props.bottom);
    		if ('average_height' in $$props) average_height = $$props.average_height;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, start, end*/ 3584) {
    			$$invalidate(5, visible = items.slice(start, end).map((data, i) => {
    				return { index: i + start, data };
    			}));
    		}

    		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 14340) {
    			// whenever `items` changes, invalidate the current heightmap
    			if (mounted) refresh(items, viewport_height, itemHeight);
    		}
    	};

    	return [
    		height,
    		hoverItemIndex,
    		viewport_height,
    		viewport,
    		contents,
    		visible,
    		top,
    		bottom,
    		handle_scroll,
    		start,
    		end,
    		items,
    		itemHeight,
    		mounted,
    		$$scope,
    		slots,
    		svelte_virtual_list_contents_binding,
    		svelte_virtual_list_viewport_binding,
    		svelte_virtual_list_viewport_elementresize_handler
    	];
    }

    class VirtualList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$T, create_fragment$S, safe_not_equal, {
    			items: 11,
    			height: 0,
    			itemHeight: 12,
    			hoverItemIndex: 1,
    			start: 9,
    			end: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VirtualList",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get items() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-select/src/List.svelte generated by Svelte v3.41.0 */
    const file$L = "node_modules/svelte-select/src/List.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[36] = i;
    	return child_ctx;
    }

    // (210:0) {#if isVirtualList}
    function create_if_block_3$4(ctx) {
    	let div;
    	let virtuallist;
    	let current;

    	virtuallist = new VirtualList({
    			props: {
    				items: /*items*/ ctx[4],
    				itemHeight: /*itemHeight*/ ctx[7],
    				$$slots: {
    					default: [
    						create_default_slot$7,
    						({ item, i }) => ({ 34: item, 36: i }),
    						({ item, i }) => [0, (item ? 8 : 0) | (i ? 32 : 0)]
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(virtuallist.$$.fragment);
    			attr_dev(div, "class", "listContainer virtualList svelte-ux0sbr");
    			add_location(div, file$L, 210, 0, 5850);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(virtuallist, div, null);
    			/*div_binding*/ ctx[20](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const virtuallist_changes = {};
    			if (dirty[0] & /*items*/ 16) virtuallist_changes.items = /*items*/ ctx[4];
    			if (dirty[0] & /*itemHeight*/ 128) virtuallist_changes.itemHeight = /*itemHeight*/ ctx[7];

    			if (dirty[0] & /*Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, items*/ 4918 | dirty[1] & /*$$scope, item, i*/ 104) {
    				virtuallist_changes.$$scope = { dirty, ctx };
    			}

    			virtuallist.$set(virtuallist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(virtuallist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(virtuallist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(virtuallist);
    			/*div_binding*/ ctx[20](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(210:0) {#if isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (213:2) <VirtualList {items} {itemHeight} let:item let:i>
    function create_default_slot$7(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[34],
    				filterText: /*filterText*/ ctx[12],
    				getOptionLabel: /*getOptionLabel*/ ctx[5],
    				isFirst: isItemFirst(/*i*/ ctx[36]),
    				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[18](/*i*/ ctx[36]);
    	}

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[19](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$L, 214, 4, 5970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[1] & /*item*/ 8) switch_instance_changes.item = /*item*/ ctx[34];
    			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
    			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
    			if (dirty[1] & /*i*/ 32) switch_instance_changes.isFirst = isItemFirst(/*i*/ ctx[36]);
    			if (dirty[0] & /*selectedValue, optionIdentifier*/ 768 | dirty[1] & /*item*/ 8) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 18 | dirty[1] & /*item, i*/ 40) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(213:2) <VirtualList {items} {itemHeight} let:item let:i>",
    		ctx
    	});

    	return block;
    }

    // (232:0) {#if !isVirtualList}
    function create_if_block$o(ctx) {
    	let div;
    	let current;
    	let each_value = /*items*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_1$2(ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			attr_dev(div, "class", "listContainer svelte-ux0sbr");
    			add_location(div, file$L, 232, 0, 6477);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(div, null);
    			}

    			/*div_binding_1*/ ctx[23](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/ 32630) {
    				each_value = /*items*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value.length) {
    					each_1_else = create_else_block_1$2(ctx);
    					each_1_else.c();
    					each_1_else.m(div, null);
    				} else if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (each_1_else) each_1_else.d();
    			/*div_binding_1*/ ctx[23](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(232:0) {#if !isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (254:2) {:else}
    function create_else_block_1$2(ctx) {
    	let if_block_anchor;
    	let if_block = !/*hideEmptyState*/ ctx[10] && create_if_block_2$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*hideEmptyState*/ ctx[10]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$9(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(254:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (255:4) {#if !hideEmptyState}
    function create_if_block_2$9(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(/*noOptionsMessage*/ ctx[11]);
    			attr_dev(div, "class", "empty svelte-ux0sbr");
    			add_location(div, file$L, 255, 6, 7178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*noOptionsMessage*/ 2048) set_data_dev(t, /*noOptionsMessage*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(255:4) {#if !hideEmptyState}",
    		ctx
    	});

    	return block;
    }

    // (237:4) { :else }
    function create_else_block$d(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[34],
    				filterText: /*filterText*/ ctx[12],
    				getOptionLabel: /*getOptionLabel*/ ctx[5],
    				isFirst: isItemFirst(/*i*/ ctx[36]),
    				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler_1() {
    		return /*mouseover_handler_1*/ ctx[21](/*i*/ ctx[36]);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[22](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$L, 237, 4, 6691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler_1, false, false, false),
    					listen_dev(div, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 16) switch_instance_changes.item = /*item*/ ctx[34];
    			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
    			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
    			if (dirty[0] & /*items, selectedValue, optionIdentifier*/ 784) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 18) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(237:4) { :else }",
    		ctx
    	});

    	return block;
    }

    // (235:4) {#if item.isGroupHeader && !item.isSelectable}
    function create_if_block_1$d(ctx) {
    	let div;
    	let t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(t_value);
    			attr_dev(div, "class", "listGroupTitle svelte-ux0sbr");
    			add_location(div, file$L, 235, 6, 6611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items*/ 80 && t_value !== (t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(235:4) {#if item.isGroupHeader && !item.isSelectable}",
    		ctx
    	});

    	return block;
    }

    // (234:2) {#each items as item, i}
    function create_each_block$c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$d, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[34].isGroupHeader && !/*item*/ ctx[34].isSelectable) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(234:2) {#each items as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isVirtualList*/ ctx[3] && create_if_block_3$4(ctx);
    	let if_block1 = !/*isVirtualList*/ ctx[3] && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*handleKeyDown*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*isVirtualList*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*isVirtualList*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isVirtualList*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isVirtualList*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$o(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function itemClasses(hoverItemIndex, item, itemIndex, items, selectedValue, optionIdentifier, isMulti) {
    	return `${selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]
	? 'active '
	: ''}${hoverItemIndex === itemIndex || items.length === 1
	? 'hover'
	: ''}`;
    }

    function isItemActive(item, selectedValue, optionIdentifier) {
    	return selectedValue && selectedValue[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
    	return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
    	return hoverItemIndex === itemIndex || items.length === 1;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { items = [] } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		if (option) return option.isCreator
    		? `Create \"${filterText}\"`
    		: option.label;
    	} } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option.label;
    	} } = $$props;

    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { selectedValue = undefined } = $$props;
    	let { optionIdentifier = 'value' } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { noOptionsMessage = 'No options' } = $$props;
    	let { isMulti = false } = $$props;
    	let { activeItemIndex = 0 } = $$props;
    	let { filterText = '' } = $$props;
    	let isScrollingTimer = 0;
    	let isScrolling = false;
    	let prev_items;
    	let prev_activeItemIndex;
    	let prev_selectedValue;

    	onMount(() => {
    		if (items.length > 0 && !isMulti && selectedValue) {
    			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === selectedValue[optionIdentifier]);

    			if (_hoverItemIndex) {
    				$$invalidate(1, hoverItemIndex = _hoverItemIndex);
    			}
    		}

    		scrollToActiveItem('active');

    		container.addEventListener(
    			'scroll',
    			() => {
    				clearTimeout(isScrollingTimer);

    				isScrollingTimer = setTimeout(
    					() => {
    						isScrolling = false;
    					},
    					100
    				);
    			},
    			false
    		);
    	});

    	onDestroy(() => {
    		
    	}); // clearTimeout(isScrollingTimer);

    	beforeUpdate(() => {
    		if (items !== prev_items && items.length > 0) {
    			$$invalidate(1, hoverItemIndex = 0);
    		}

    		// if (prev_activeItemIndex && activeItemIndex > -1) {
    		//   hoverItemIndex = activeItemIndex;
    		//   scrollToActiveItem('active');
    		// }
    		// if (prev_selectedValue && selectedValue) {
    		//   scrollToActiveItem('active');
    		//   if (items && !isMulti) {
    		//     const hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === selectedValue[optionIdentifier]);
    		//     if (hoverItemIndex) {
    		//       hoverItemIndex = hoverItemIndex;
    		//     }
    		//   }
    		// }
    		prev_items = items;

    		prev_activeItemIndex = activeItemIndex;
    		prev_selectedValue = selectedValue;
    	});

    	function handleSelect(item) {
    		if (item.isCreator) return;
    		dispatch('itemSelected', item);
    	}

    	function handleHover(i) {
    		if (isScrolling) return;
    		$$invalidate(1, hoverItemIndex = i);
    	}

    	function handleClick(args) {
    		const { item, i, event } = args;
    		event.stopPropagation();
    		if (selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]) return closeList();

    		if (item.isCreator) {
    			dispatch('itemCreated', filterText);
    		} else {
    			$$invalidate(16, activeItemIndex = i);
    			$$invalidate(1, hoverItemIndex = i);
    			handleSelect(item);
    		}
    	}

    	function closeList() {
    		dispatch('closeList');
    	}

    	async function updateHoverItem(increment) {
    		if (isVirtualList) return;
    		let isNonSelectableItem = true;

    		while (isNonSelectableItem) {
    			if (increment > 0 && hoverItemIndex === items.length - 1) {
    				$$invalidate(1, hoverItemIndex = 0);
    			} else if (increment < 0 && hoverItemIndex === 0) {
    				$$invalidate(1, hoverItemIndex = items.length - 1);
    			} else {
    				$$invalidate(1, hoverItemIndex = hoverItemIndex + increment);
    			}

    			isNonSelectableItem = items[hoverItemIndex].isGroupHeader && !items[hoverItemIndex].isSelectable;
    		}

    		await tick();
    		scrollToActiveItem('hover');
    	}

    	function handleKeyDown(e) {
    		switch (e.key) {
    			case 'ArrowDown':
    				e.preventDefault();
    				items.length && updateHoverItem(1);
    				break;
    			case 'ArrowUp':
    				e.preventDefault();
    				items.length && updateHoverItem(-1);
    				break;
    			case 'Enter':
    				e.preventDefault();
    				if (items.length === 0) break;
    				const hoverItem = items[hoverItemIndex];
    				if (selectedValue && !isMulti && selectedValue[optionIdentifier] === hoverItem[optionIdentifier]) {
    					closeList();
    					break;
    				}
    				if (hoverItem.isCreator) {
    					dispatch('itemCreated', filterText);
    				} else {
    					$$invalidate(16, activeItemIndex = hoverItemIndex);
    					handleSelect(items[hoverItemIndex]);
    				}
    				break;
    			case 'Tab':
    				e.preventDefault();
    				if (items.length === 0) break;
    				if (selectedValue && selectedValue[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
    				$$invalidate(16, activeItemIndex = hoverItemIndex);
    				handleSelect(items[hoverItemIndex]);
    				break;
    		}
    	}

    	function scrollToActiveItem(className) {
    		if (isVirtualList || !container) return;
    		let offsetBounding;
    		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

    		if (focusedElemBounding) {
    			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    		}

    		$$invalidate(0, container.scrollTop -= offsetBounding, container);
    	}

    	
    	

    	const writable_props = [
    		'container',
    		'Item',
    		'isVirtualList',
    		'items',
    		'getOptionLabel',
    		'getGroupHeaderLabel',
    		'itemHeight',
    		'hoverItemIndex',
    		'selectedValue',
    		'optionIdentifier',
    		'hideEmptyState',
    		'noOptionsMessage',
    		'isMulti',
    		'activeItemIndex',
    		'filterText'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = i => handleHover(i);
    	const click_handler = (item, i, event) => handleClick({ item, i, event });

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	const mouseover_handler_1 = i => handleHover(i);
    	const click_handler_1 = (item, i, event) => handleClick({ item, i, event });

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('Item' in $$props) $$invalidate(2, Item$1 = $$props.Item);
    		if ('isVirtualList' in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
    		if ('items' in $$props) $$invalidate(4, items = $$props.items);
    		if ('getOptionLabel' in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('itemHeight' in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('selectedValue' in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
    		if ('optionIdentifier' in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
    		if ('hideEmptyState' in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
    		if ('noOptionsMessage' in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
    		if ('isMulti' in $$props) $$invalidate(17, isMulti = $$props.isMulti);
    		if ('activeItemIndex' in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
    		if ('filterText' in $$props) $$invalidate(12, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick,
    		dispatch,
    		container,
    		ItemComponent: Item,
    		VirtualList,
    		Item: Item$1,
    		isVirtualList,
    		items,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		hoverItemIndex,
    		selectedValue,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		isMulti,
    		activeItemIndex,
    		filterText,
    		isScrollingTimer,
    		isScrolling,
    		prev_items,
    		prev_activeItemIndex,
    		prev_selectedValue,
    		itemClasses,
    		handleSelect,
    		handleHover,
    		handleClick,
    		closeList,
    		updateHoverItem,
    		handleKeyDown,
    		scrollToActiveItem,
    		isItemActive,
    		isItemFirst,
    		isItemHover
    	});

    	$$self.$inject_state = $$props => {
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('Item' in $$props) $$invalidate(2, Item$1 = $$props.Item);
    		if ('isVirtualList' in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
    		if ('items' in $$props) $$invalidate(4, items = $$props.items);
    		if ('getOptionLabel' in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('itemHeight' in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('selectedValue' in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
    		if ('optionIdentifier' in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
    		if ('hideEmptyState' in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
    		if ('noOptionsMessage' in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
    		if ('isMulti' in $$props) $$invalidate(17, isMulti = $$props.isMulti);
    		if ('activeItemIndex' in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
    		if ('filterText' in $$props) $$invalidate(12, filterText = $$props.filterText);
    		if ('isScrollingTimer' in $$props) isScrollingTimer = $$props.isScrollingTimer;
    		if ('isScrolling' in $$props) isScrolling = $$props.isScrolling;
    		if ('prev_items' in $$props) prev_items = $$props.prev_items;
    		if ('prev_activeItemIndex' in $$props) prev_activeItemIndex = $$props.prev_activeItemIndex;
    		if ('prev_selectedValue' in $$props) prev_selectedValue = $$props.prev_selectedValue;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		container,
    		hoverItemIndex,
    		Item$1,
    		isVirtualList,
    		items,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		selectedValue,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		filterText,
    		handleHover,
    		handleClick,
    		handleKeyDown,
    		activeItemIndex,
    		isMulti,
    		mouseover_handler,
    		click_handler,
    		div_binding,
    		mouseover_handler_1,
    		click_handler_1,
    		div_binding_1
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$S,
    			create_fragment$R,
    			safe_not_equal,
    			{
    				container: 0,
    				Item: 2,
    				isVirtualList: 3,
    				items: 4,
    				getOptionLabel: 5,
    				getGroupHeaderLabel: 6,
    				itemHeight: 7,
    				hoverItemIndex: 1,
    				selectedValue: 8,
    				optionIdentifier: 9,
    				hideEmptyState: 10,
    				noOptionsMessage: 11,
    				isMulti: 17,
    				activeItemIndex: 16,
    				filterText: 12
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get container() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-select/src/Selection.svelte generated by Svelte v3.41.0 */

    const file$K = "node_modules/svelte-select/src/Selection.svelte";

    function create_fragment$Q(ctx) {
    	let div;
    	let raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "selection svelte-ch6bh7");
    			add_location(div, file$K, 13, 0, 210);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getSelectionLabel, item*/ 3 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "")) div.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Selection', slots, []);
    	let { getSelectionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	const writable_props = ['getSelectionLabel', 'item'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Selection> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({ getSelectionLabel, item });

    	$$self.$inject_state = $$props => {
    		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$Q, safe_not_equal, { getSelectionLabel: 0, item: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Selection",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get getSelectionLabel() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-select/src/MultiSelection.svelte generated by Svelte v3.41.0 */
    const file$J = "node_modules/svelte-select/src/MultiSelection.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (23:2) {#if !isDisabled && !multiFullItemClearable}
    function create_if_block$n(ctx) {
    	let div;
    	let svg;
    	let path;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$J, 25, 6, 950);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "role", "presentation");
    			attr_dev(svg, "class", "svelte-14r1jr2");
    			add_location(svg, file$J, 24, 4, 851);
    			attr_dev(div, "class", "multiSelectItem_clear svelte-14r1jr2");
    			add_location(div, file$J, 23, 2, 767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(23:2) {#if !isDisabled && !multiFullItemClearable}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#each selectedValue as value, i}
    function create_each_block$b(ctx) {
    	let div1;
    	let div0;
    	let raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "";
    	let t0;
    	let t1;
    	let div1_class_value;
    	let mounted;
    	let dispose;
    	let if_block = !/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3] && create_if_block$n(ctx);

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[7](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(div0, "class", "multiSelectItem_label svelte-14r1jr2");
    			add_location(div0, file$J, 19, 2, 636);

    			attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
    			? 'active'
    			: '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-14r1jr2");

    			add_location(div1, file$J, 18, 0, 457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t0);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t1);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*getSelectionLabel, selectedValue*/ 17 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "")) div0.innerHTML = raw_value;
    			if (!/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					if_block.m(div1, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*activeSelectedValue, isDisabled*/ 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
    			? 'active'
    			: '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-14r1jr2")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(18:0) {#each selectedValue as value, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let each_1_anchor;
    	let each_value = /*selectedValue*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeSelectedValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, selectedValue*/ 63) {
    				each_value = /*selectedValue*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MultiSelection', slots, []);
    	const dispatch = createEventDispatcher();
    	let { selectedValue = [] } = $$props;
    	let { activeSelectedValue = undefined } = $$props;
    	let { isDisabled = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { getSelectionLabel = undefined } = $$props;

    	function handleClear(i, event) {
    		event.stopPropagation();
    		dispatch('multiItemClear', { i });
    	}

    	const writable_props = [
    		'selectedValue',
    		'activeSelectedValue',
    		'isDisabled',
    		'multiFullItemClearable',
    		'getSelectionLabel'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, event) => handleClear(i, event);
    	const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

    	$$self.$$set = $$props => {
    		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ('activeSelectedValue' in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
    		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		selectedValue,
    		activeSelectedValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ('activeSelectedValue' in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
    		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedValue,
    		activeSelectedValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear,
    		click_handler,
    		click_handler_1
    	];
    }

    class MultiSelection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Q, create_fragment$P, safe_not_equal, {
    			selectedValue: 0,
    			activeSelectedValue: 1,
    			isDisabled: 2,
    			multiFullItemClearable: 3,
    			getSelectionLabel: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MultiSelection",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get selectedValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeSelectedValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeSelectedValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function isOutOfViewport (elem) {
      const bounding = elem.getBoundingClientRect();
      const out = {};
      out.top = bounding.top < 0;
      out.left = bounding.left < 0;
      out.bottom = bounding.bottom > (window.innerHeight || document.documentElement.clientHeight);
      out.right = bounding.right > (window.innerWidth || document.documentElement.clientWidth);
      out.any = out.top || out.left || out.bottom || out.right;
      return out;
    }

    function debounce(func, wait, immediate) {
      let timeout;
      return function executedFunction() {
        let context = this;
        let args = arguments;

        let later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }

    /* node_modules/svelte-select/src/ClearIcon.svelte generated by Svelte v3.41.0 */

    const file$I = "node_modules/svelte-select/src/ClearIcon.svelte";

    function create_fragment$O(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$I, 7, 2, 108);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "role", "presentation");
    			add_location(svg, file$I, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClearIcon', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ClearIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClearIcon",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* node_modules/svelte-select/src/Select.svelte generated by Svelte v3.41.0 */

    const { Object: Object_1$1, console: console_1$5 } = globals;
    const file$H = "node_modules/svelte-select/src/Select.svelte";

    // (827:2) {#if Icon}
    function create_if_block_7$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*iconProps*/ ctx[18]];
    	var switch_value = /*Icon*/ ctx[17];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*iconProps*/ 262144)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[18])])
    			: {};

    			if (switch_value !== (switch_value = /*Icon*/ ctx[17])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(827:2) {#if Icon}",
    		ctx
    	});

    	return block;
    }

    // (831:2) {#if isMulti && selectedValue && selectedValue.length > 0}
    function create_if_block_6$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*MultiSelection*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: {
    				selectedValue: /*selectedValue*/ ctx[0],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[13],
    				activeSelectedValue: /*activeSelectedValue*/ ctx[25],
    				isDisabled: /*isDisabled*/ ctx[10],
    				multiFullItemClearable: /*multiFullItemClearable*/ ctx[9]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
    		switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.selectedValue = /*selectedValue*/ ctx[0];
    			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];
    			if (dirty[0] & /*activeSelectedValue*/ 33554432) switch_instance_changes.activeSelectedValue = /*activeSelectedValue*/ ctx[25];
    			if (dirty[0] & /*isDisabled*/ 1024) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[10];
    			if (dirty[0] & /*multiFullItemClearable*/ 512) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ ctx[9];

    			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
    					switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(831:2) {#if isMulti && selectedValue && selectedValue.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (852:2) {:else}
    function create_else_block_1$1(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	let input_1_levels = [
    		/*_inputAttributes*/ ctx[26],
    		{ placeholder: /*placeholderText*/ ctx[27] },
    		{ style: /*inputStyles*/ ctx[15] }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17qb5ew", true);
    			add_location(input_1, file$H, 852, 4, 21497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			if (input_1.autofocus) input_1.focus();
    			/*input_1_binding_1*/ ctx[63](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler_1*/ ctx[64])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
    				dirty[0] & /*placeholderText*/ 134217728 && { placeholder: /*placeholderText*/ ctx[27] },
    				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] }
    			]));

    			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
    				set_input_value(input_1, /*filterText*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-17qb5ew", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding_1*/ ctx[63](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(852:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (843:2) {#if isDisabled}
    function create_if_block_5$1(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	let input_1_levels = [
    		/*_inputAttributes*/ ctx[26],
    		{ placeholder: /*placeholderText*/ ctx[27] },
    		{ style: /*inputStyles*/ ctx[15] },
    		{ disabled: true }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17qb5ew", true);
    			add_location(input_1, file$H, 843, 4, 21285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			if (input_1.autofocus) input_1.focus();
    			/*input_1_binding*/ ctx[61](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[62])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
    				dirty[0] & /*placeholderText*/ 134217728 && { placeholder: /*placeholderText*/ ctx[27] },
    				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] },
    				{ disabled: true }
    			]));

    			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
    				set_input_value(input_1, /*filterText*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-17qb5ew", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[61](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(843:2) {#if isDisabled}",
    		ctx
    	});

    	return block;
    }

    // (862:2) {#if !isMulti && showSelectedItem}
    function create_if_block_4$1(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Selection*/ ctx[6];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*selectedValue*/ ctx[0],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[13]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "selectedItem svelte-17qb5ew");
    			add_location(div, file$H, 862, 4, 21730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "focus", /*handleFocus*/ ctx[32], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.item = /*selectedValue*/ ctx[0];
    			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];

    			if (switch_value !== (switch_value = /*Selection*/ ctx[6])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(862:2) {#if !isMulti && showSelectedItem}",
    		ctx
    	});

    	return block;
    }

    // (871:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}
    function create_if_block_3$3(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*ClearIcon*/ ctx[23];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "clearSelect svelte-17qb5ew");
    			add_location(div, file$H, 871, 4, 21982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", prevent_default(/*handleClear*/ ctx[24]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*ClearIcon*/ ctx[23])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(871:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}",
    		ctx
    	});

    	return block;
    }

    // (877:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
    function create_if_block_1$c(ctx) {
    	let div;

    	function select_block_type_1(ctx, dirty) {
    		if (/*indicatorSvg*/ ctx[22]) return create_if_block_2$8;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "indicator svelte-17qb5ew");
    			add_location(div, file$H, 877, 4, 22281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(877:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
    		ctx
    	});

    	return block;
    }

    // (881:6) {:else}
    function create_else_block$c(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n            3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n            1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n            0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n            0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
    			add_location(path, file$H, 886, 10, 22502);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "0 0 20 20");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "class", "svelte-17qb5ew");
    			add_location(svg, file$H, 881, 8, 22381);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(881:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (879:6) {#if indicatorSvg}
    function create_if_block_2$8(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*indicatorSvg*/ ctx[22], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*indicatorSvg*/ 4194304) html_tag.p(/*indicatorSvg*/ ctx[22]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(879:6) {#if indicatorSvg}",
    		ctx
    	});

    	return block;
    }

    // (898:2) {#if isWaiting}
    function create_if_block$m(ctx) {
    	let div;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "spinner_path svelte-17qb5ew");
    			attr_dev(circle, "cx", "50");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "r", "20");
    			attr_dev(circle, "fill", "none");
    			attr_dev(circle, "stroke", "currentColor");
    			attr_dev(circle, "stroke-width", "5");
    			attr_dev(circle, "stroke-miterlimit", "10");
    			add_location(circle, file$H, 900, 8, 23007);
    			attr_dev(svg, "class", "spinner_icon svelte-17qb5ew");
    			attr_dev(svg, "viewBox", "25 25 50 50");
    			add_location(svg, file$H, 899, 6, 22950);
    			attr_dev(div, "class", "spinner svelte-17qb5ew");
    			add_location(div, file$H, 898, 4, 22922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(898:2) {#if isWaiting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*Icon*/ ctx[17] && create_if_block_7$1(ctx);
    	let if_block1 = /*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0 && create_if_block_6$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*isDisabled*/ ctx[10]) return create_if_block_5$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);
    	let if_block3 = !/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[28] && create_if_block_4$1(ctx);
    	let if_block4 = /*showSelectedItem*/ ctx[28] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && create_if_block_3$3(ctx);
    	let if_block5 = (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[28] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[28]))) && create_if_block_1$c(ctx);
    	let if_block6 = /*isWaiting*/ ctx[5] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			attr_dev(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17qb5ew");
    			attr_dev(div, "style", /*containerStyles*/ ctx[12]);
    			toggle_class(div, "hasError", /*hasError*/ ctx[11]);
    			toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
    			toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
    			toggle_class(div, "focused", /*isFocused*/ ctx[4]);
    			add_location(div, file$H, 816, 0, 20631);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t5);
    			if (if_block6) if_block6.m(div, null);
    			/*div_binding*/ ctx[65](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*handleWindowClick*/ ctx[33], false, false, false),
    					listen_dev(window, "keydown", /*handleKeyDown*/ ctx[31], false, false, false),
    					listen_dev(window, "resize", /*getPosition*/ ctx[30], false, false, false),
    					listen_dev(div, "click", /*handleClick*/ ctx[34], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*Icon*/ ctx[17]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*Icon*/ 131072) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, selectedValue*/ 257) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			}

    			if (!/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[28]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, showSelectedItem*/ 268435712) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_4$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*showSelectedItem*/ ctx[28] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/ 268502048) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_3$3(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[28] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[28]))) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_1$c(ctx);
    					if_block5.c();
    					if_block5.m(div, t5);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*isWaiting*/ ctx[5]) {
    				if (if_block6) ; else {
    					if_block6 = create_if_block$m(ctx);
    					if_block6.c();
    					if_block6.m(div, null);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17qb5ew")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*containerStyles*/ 4096) {
    				attr_dev(div, "style", /*containerStyles*/ ctx[12]);
    			}

    			if (dirty[0] & /*containerClasses, hasError*/ 2099200) {
    				toggle_class(div, "hasError", /*hasError*/ ctx[11]);
    			}

    			if (dirty[0] & /*containerClasses, isMulti*/ 2097408) {
    				toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
    			}

    			if (dirty[0] & /*containerClasses, isDisabled*/ 2098176) {
    				toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
    			}

    			if (dirty[0] & /*containerClasses, isFocused*/ 2097168) {
    				toggle_class(div, "focused", /*isFocused*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			/*div_binding*/ ctx[65](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let disabled;
    	let showSelectedItem;
    	let placeholderText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Select', slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { input = undefined } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { Selection: Selection$1 = Selection } = $$props;
    	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
    	let { isMulti = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { isDisabled = false } = $$props;
    	let { isCreatable = false } = $$props;
    	let { isFocused = false } = $$props;
    	let { selectedValue = undefined } = $$props;
    	let { filterText = "" } = $$props;
    	let { placeholder = "Select..." } = $$props;
    	let { items = [] } = $$props;
    	let { itemFilter = (label, filterText, option) => label.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
    	let { groupBy = undefined } = $$props;
    	let { groupFilter = groups => groups } = $$props;
    	let { isGroupHeaderSelectable = false } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option.label;
    	} } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		return option.isCreator
    		? `Create \"${filterText}\"`
    		: option.label;
    	} } = $$props;

    	let { optionIdentifier = "value" } = $$props;
    	let { loadOptions = undefined } = $$props;
    	let { hasError = false } = $$props;
    	let { containerStyles = "" } = $$props;

    	let { getSelectionLabel = option => {
    		if (option) return option.label;
    	} } = $$props;

    	let { createGroupHeaderItem = groupValue => {
    		return { value: groupValue, label: groupValue };
    	} } = $$props;

    	let { createItem = filterText => {
    		return { value: filterText, label: filterText };
    	} } = $$props;

    	let { isSearchable = true } = $$props;
    	let { inputStyles = "" } = $$props;
    	let { isClearable = true } = $$props;
    	let { isWaiting = false } = $$props;
    	let { listPlacement = "auto" } = $$props;
    	let { listOpen = false } = $$props;
    	let { list = undefined } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { loadOptionsInterval = 300 } = $$props;
    	let { noOptionsMessage = "No options" } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { filteredItems = [] } = $$props;
    	let { inputAttributes = {} } = $$props;
    	let { listAutoWidth = true } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { Icon = undefined } = $$props;
    	let { iconProps = {} } = $$props;
    	let { showChevron = false } = $$props;
    	let { showIndicator = false } = $$props;
    	let { containerClasses = "" } = $$props;
    	let { indicatorSvg = undefined } = $$props;
    	let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
    	let target;
    	let activeSelectedValue;
    	let _items = [];
    	let originalItemsClone;
    	let prev_selectedValue;
    	let prev_listOpen;
    	let prev_filterText;
    	let prev_isFocused;
    	let prev_filteredItems;

    	async function resetFilter() {
    		await tick();
    		$$invalidate(1, filterText = "");
    	}

    	let getItemsHasInvoked = false;

    	const getItems = debounce(
    		async () => {
    			getItemsHasInvoked = true;
    			$$invalidate(5, isWaiting = true);

    			let res = await loadOptions(filterText).catch(err => {
    				console.warn('svelte-select loadOptions error :>> ', err);
    				dispatch("error", { type: 'loadOptions', details: err });
    			});

    			if (res && !res.cancelled) {
    				if (res) {
    					$$invalidate(35, items = [...res]);
    					dispatch("loaded", { items });
    				} else {
    					$$invalidate(35, items = []);
    				}

    				$$invalidate(5, isWaiting = false);
    				$$invalidate(4, isFocused = true);
    				$$invalidate(37, listOpen = true);
    			}
    		},
    		loadOptionsInterval
    	);

    	let _inputAttributes = {};

    	beforeUpdate(() => {
    		if (isMulti && selectedValue && selectedValue.length > 1) {
    			checkSelectedValueForDuplicates();
    		}

    		if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {
    			if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {
    				dispatch("select", selectedValue);
    			}
    		}

    		if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {
    			if (checkSelectedValueForDuplicates()) {
    				dispatch("select", selectedValue);
    			}
    		}

    		if (container && listOpen !== prev_listOpen) {
    			if (listOpen) {
    				loadList();
    			} else {
    				removeList();
    			}
    		}

    		if (filterText !== prev_filterText) {
    			if (filterText.length > 0) {
    				$$invalidate(4, isFocused = true);
    				$$invalidate(37, listOpen = true);

    				if (loadOptions) {
    					getItems();
    				} else {
    					loadList();
    					$$invalidate(37, listOpen = true);

    					if (isMulti) {
    						$$invalidate(25, activeSelectedValue = undefined);
    					}
    				}
    			} else {
    				setList([]);
    			}

    			if (list) {
    				list.$set({ filterText });
    			}
    		}

    		if (isFocused !== prev_isFocused) {
    			if (isFocused || listOpen) {
    				handleFocus();
    			} else {
    				resetFilter();
    				if (input) input.blur();
    			}
    		}

    		if (prev_filteredItems !== filteredItems) {
    			let _filteredItems = [...filteredItems];

    			if (isCreatable && filterText) {
    				const itemToCreate = createItem(filterText);
    				itemToCreate.isCreator = true;

    				const existingItemWithFilterValue = _filteredItems.find(item => {
    					return item[optionIdentifier] === itemToCreate[optionIdentifier];
    				});

    				let existingSelectionWithFilterValue;

    				if (selectedValue) {
    					if (isMulti) {
    						existingSelectionWithFilterValue = selectedValue.find(selection => {
    							return selection[optionIdentifier] === itemToCreate[optionIdentifier];
    						});
    					} else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {
    						existingSelectionWithFilterValue = selectedValue;
    					}
    				}

    				if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {
    					_filteredItems = [..._filteredItems, itemToCreate];
    				}
    			}

    			setList(_filteredItems);
    		}

    		prev_selectedValue = selectedValue;
    		prev_listOpen = listOpen;
    		prev_filterText = filterText;
    		prev_isFocused = isFocused;
    		prev_filteredItems = filteredItems;
    	});

    	function checkSelectedValueForDuplicates() {
    		let noDuplicates = true;

    		if (selectedValue) {
    			const ids = [];
    			const uniqueValues = [];

    			selectedValue.forEach(val => {
    				if (!ids.includes(val[optionIdentifier])) {
    					ids.push(val[optionIdentifier]);
    					uniqueValues.push(val);
    				} else {
    					noDuplicates = false;
    				}
    			});

    			if (!noDuplicates) $$invalidate(0, selectedValue = uniqueValues);
    		}

    		return noDuplicates;
    	}

    	function findItem(selection) {
    		let matchTo = selection
    		? selection[optionIdentifier]
    		: selectedValue[optionIdentifier];

    		return items.find(item => item[optionIdentifier] === matchTo);
    	}

    	function updateSelectedValueDisplay(items) {
    		if (!items || items.length === 0 || items.some(item => typeof item !== "object")) return;

    		if (!selectedValue || (isMulti
    		? selectedValue.some(selection => !selection || !selection[optionIdentifier])
    		: !selectedValue[optionIdentifier])) return;

    		if (Array.isArray(selectedValue)) {
    			$$invalidate(0, selectedValue = selectedValue.map(selection => findItem(selection) || selection));
    		} else {
    			$$invalidate(0, selectedValue = findItem() || selectedValue);
    		}
    	}

    	async function setList(items) {
    		await tick();
    		if (!listOpen) return;
    		if (list) return list.$set({ items });
    		if (loadOptions && getItemsHasInvoked && items.length > 0) loadList();
    	}

    	function handleMultiItemClear(event) {
    		const { detail } = event;
    		const itemToRemove = selectedValue[detail ? detail.i : selectedValue.length - 1];

    		if (selectedValue.length === 1) {
    			$$invalidate(0, selectedValue = undefined);
    		} else {
    			$$invalidate(0, selectedValue = selectedValue.filter(item => {
    				return item !== itemToRemove;
    			}));
    		}

    		dispatch("clear", itemToRemove);
    		getPosition();
    	}

    	async function getPosition() {
    		await tick();
    		if (!target || !container) return;
    		const { top, height, width } = container.getBoundingClientRect();
    		target.style["min-width"] = `${width}px`;
    		target.style.width = `${listAutoWidth ? "auto" : "100%"}`;
    		target.style.left = "0";

    		if (listPlacement === "top") {
    			target.style.bottom = `${height + 5}px`;
    		} else {
    			target.style.top = `${height + 5}px`;
    		}

    		target = target;

    		if (listPlacement === "auto" && isOutOfViewport(target).bottom) {
    			target.style.top = ``;
    			target.style.bottom = `${height + 5}px`;
    		}

    		target.style.visibility = "";
    	}

    	function handleKeyDown(e) {
    		if (!isFocused) return;

    		switch (e.key) {
    			case "ArrowDown":
    				e.preventDefault();
    				$$invalidate(37, listOpen = true);
    				$$invalidate(25, activeSelectedValue = undefined);
    				break;
    			case "ArrowUp":
    				e.preventDefault();
    				$$invalidate(37, listOpen = true);
    				$$invalidate(25, activeSelectedValue = undefined);
    				break;
    			case "Tab":
    				if (!listOpen) $$invalidate(4, isFocused = false);
    				break;
    			case "Backspace":
    				if (!isMulti || filterText.length > 0) return;
    				if (isMulti && selectedValue && selectedValue.length > 0) {
    					handleMultiItemClear(activeSelectedValue !== undefined
    					? activeSelectedValue
    					: selectedValue.length - 1);

    					if (activeSelectedValue === 0 || activeSelectedValue === undefined) break;

    					$$invalidate(25, activeSelectedValue = selectedValue.length > activeSelectedValue
    					? activeSelectedValue - 1
    					: undefined);
    				}
    				break;
    			case "ArrowLeft":
    				if (list) list.$set({ hoverItemIndex: -1 });
    				if (!isMulti || filterText.length > 0) return;
    				if (activeSelectedValue === undefined) {
    					$$invalidate(25, activeSelectedValue = selectedValue.length - 1);
    				} else if (selectedValue.length > activeSelectedValue && activeSelectedValue !== 0) {
    					$$invalidate(25, activeSelectedValue -= 1);
    				}
    				break;
    			case "ArrowRight":
    				if (list) list.$set({ hoverItemIndex: -1 });
    				if (!isMulti || filterText.length > 0 || activeSelectedValue === undefined) return;
    				if (activeSelectedValue === selectedValue.length - 1) {
    					$$invalidate(25, activeSelectedValue = undefined);
    				} else if (activeSelectedValue < selectedValue.length - 1) {
    					$$invalidate(25, activeSelectedValue += 1);
    				}
    				break;
    		}
    	}

    	function handleFocus() {
    		$$invalidate(4, isFocused = true);
    		if (input) input.focus();
    	}

    	function removeList() {
    		resetFilter();
    		$$invalidate(25, activeSelectedValue = undefined);
    		if (!list) return;
    		list.$destroy();
    		$$invalidate(36, list = undefined);
    		if (!target) return;
    		if (target.parentNode) target.parentNode.removeChild(target);
    		target = undefined;
    		$$invalidate(36, list);
    		target = target;
    	}

    	function handleWindowClick(event) {
    		if (!container) return;

    		const eventTarget = event.path && event.path.length > 0
    		? event.path[0]
    		: event.target;

    		if (container.contains(eventTarget)) return;
    		$$invalidate(4, isFocused = false);
    		$$invalidate(37, listOpen = false);
    		$$invalidate(25, activeSelectedValue = undefined);
    		if (input) input.blur();
    	}

    	function handleClick() {
    		if (isDisabled) return;
    		$$invalidate(4, isFocused = true);
    		$$invalidate(37, listOpen = !listOpen);
    	}

    	function handleClear() {
    		$$invalidate(0, selectedValue = undefined);
    		$$invalidate(37, listOpen = false);
    		dispatch("clear", selectedValue);
    		handleFocus();
    	}

    	async function loadList() {
    		await tick();
    		if (target && list) return;

    		const data = {
    			Item: Item$1,
    			filterText,
    			optionIdentifier,
    			noOptionsMessage,
    			hideEmptyState,
    			isVirtualList,
    			selectedValue,
    			isMulti,
    			getGroupHeaderLabel,
    			items: filteredItems,
    			itemHeight
    		};

    		if (getOptionLabel) {
    			data.getOptionLabel = getOptionLabel;
    		}

    		target = document.createElement("div");

    		Object.assign(target.style, {
    			position: "absolute",
    			"z-index": 2,
    			visibility: "hidden"
    		});

    		$$invalidate(36, list);
    		target = target;
    		if (container) container.appendChild(target);
    		$$invalidate(36, list = new List({ target, props: data }));

    		list.$on("itemSelected", event => {
    			const { detail } = event;

    			if (detail) {
    				const item = Object.assign({}, detail);

    				if (!item.isGroupHeader || item.isSelectable) {
    					if (isMulti) {
    						$$invalidate(0, selectedValue = selectedValue ? selectedValue.concat([item]) : [item]);
    					} else {
    						$$invalidate(0, selectedValue = item);
    					}

    					resetFilter();
    					(($$invalidate(0, selectedValue), $$invalidate(48, optionIdentifier)), $$invalidate(8, isMulti));

    					setTimeout(() => {
    						$$invalidate(37, listOpen = false);
    						$$invalidate(25, activeSelectedValue = undefined);
    					});
    				}
    			}
    		});

    		list.$on("itemCreated", event => {
    			const { detail } = event;

    			if (isMulti) {
    				$$invalidate(0, selectedValue = selectedValue || []);
    				$$invalidate(0, selectedValue = [...selectedValue, createItem(detail)]);
    			} else {
    				$$invalidate(0, selectedValue = createItem(detail));
    			}

    			dispatch('itemCreated', detail);
    			$$invalidate(1, filterText = "");
    			$$invalidate(37, listOpen = false);
    			$$invalidate(25, activeSelectedValue = undefined);
    			resetFilter();
    		});

    		list.$on("closeList", () => {
    			$$invalidate(37, listOpen = false);
    		});

    		($$invalidate(36, list), target = target);
    		getPosition();
    	}

    	onMount(() => {
    		if (isFocused) input.focus();
    		if (listOpen) loadList();

    		if (items && items.length > 0) {
    			$$invalidate(60, originalItemsClone = JSON.stringify(items));
    		}
    	});

    	onDestroy(() => {
    		removeList();
    	});

    	const writable_props = [
    		'container',
    		'input',
    		'Item',
    		'Selection',
    		'MultiSelection',
    		'isMulti',
    		'multiFullItemClearable',
    		'isDisabled',
    		'isCreatable',
    		'isFocused',
    		'selectedValue',
    		'filterText',
    		'placeholder',
    		'items',
    		'itemFilter',
    		'groupBy',
    		'groupFilter',
    		'isGroupHeaderSelectable',
    		'getGroupHeaderLabel',
    		'getOptionLabel',
    		'optionIdentifier',
    		'loadOptions',
    		'hasError',
    		'containerStyles',
    		'getSelectionLabel',
    		'createGroupHeaderItem',
    		'createItem',
    		'isSearchable',
    		'inputStyles',
    		'isClearable',
    		'isWaiting',
    		'listPlacement',
    		'listOpen',
    		'list',
    		'isVirtualList',
    		'loadOptionsInterval',
    		'noOptionsMessage',
    		'hideEmptyState',
    		'filteredItems',
    		'inputAttributes',
    		'listAutoWidth',
    		'itemHeight',
    		'Icon',
    		'iconProps',
    		'showChevron',
    		'showIndicator',
    		'containerClasses',
    		'indicatorSvg',
    		'ClearIcon'
    	];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler() {
    		filterText = this.value;
    		$$invalidate(1, filterText);
    	}

    	function input_1_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler_1() {
    		filterText = this.value;
    		$$invalidate(1, filterText);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(2, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('container' in $$props) $$invalidate(2, container = $$props.container);
    		if ('input' in $$props) $$invalidate(3, input = $$props.input);
    		if ('Item' in $$props) $$invalidate(39, Item$1 = $$props.Item);
    		if ('Selection' in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
    		if ('MultiSelection' in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
    		if ('isMulti' in $$props) $$invalidate(8, isMulti = $$props.isMulti);
    		if ('multiFullItemClearable' in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('isDisabled' in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
    		if ('isCreatable' in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
    		if ('isFocused' in $$props) $$invalidate(4, isFocused = $$props.isFocused);
    		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ('filterText' in $$props) $$invalidate(1, filterText = $$props.filterText);
    		if ('placeholder' in $$props) $$invalidate(41, placeholder = $$props.placeholder);
    		if ('items' in $$props) $$invalidate(35, items = $$props.items);
    		if ('itemFilter' in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
    		if ('groupBy' in $$props) $$invalidate(43, groupBy = $$props.groupBy);
    		if ('groupFilter' in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
    		if ('isGroupHeaderSelectable' in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('getOptionLabel' in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
    		if ('optionIdentifier' in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
    		if ('loadOptions' in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
    		if ('hasError' in $$props) $$invalidate(11, hasError = $$props.hasError);
    		if ('containerStyles' in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
    		if ('getSelectionLabel' in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
    		if ('createGroupHeaderItem' in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ('createItem' in $$props) $$invalidate(51, createItem = $$props.createItem);
    		if ('isSearchable' in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
    		if ('inputStyles' in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
    		if ('isClearable' in $$props) $$invalidate(16, isClearable = $$props.isClearable);
    		if ('isWaiting' in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
    		if ('listPlacement' in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
    		if ('listOpen' in $$props) $$invalidate(37, listOpen = $$props.listOpen);
    		if ('list' in $$props) $$invalidate(36, list = $$props.list);
    		if ('isVirtualList' in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
    		if ('loadOptionsInterval' in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ('noOptionsMessage' in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
    		if ('hideEmptyState' in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
    		if ('filteredItems' in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
    		if ('inputAttributes' in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
    		if ('listAutoWidth' in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
    		if ('itemHeight' in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
    		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick,
    		List,
    		ItemComponent: Item,
    		SelectionComponent: Selection,
    		MultiSelectionComponent: MultiSelection,
    		isOutOfViewport,
    		debounce,
    		DefaultClearIcon: ClearIcon,
    		dispatch,
    		container,
    		input,
    		Item: Item$1,
    		Selection: Selection$1,
    		MultiSelection: MultiSelection$1,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		isCreatable,
    		isFocused,
    		selectedValue,
    		filterText,
    		placeholder,
    		items,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		createGroupHeaderItem,
    		createItem,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		isWaiting,
    		listPlacement,
    		listOpen,
    		list,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		filteredItems,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon: ClearIcon$1,
    		target,
    		activeSelectedValue,
    		_items,
    		originalItemsClone,
    		prev_selectedValue,
    		prev_listOpen,
    		prev_filterText,
    		prev_isFocused,
    		prev_filteredItems,
    		resetFilter,
    		getItemsHasInvoked,
    		getItems,
    		_inputAttributes,
    		checkSelectedValueForDuplicates,
    		findItem,
    		updateSelectedValueDisplay,
    		setList,
    		handleMultiItemClear,
    		getPosition,
    		handleKeyDown,
    		handleFocus,
    		removeList,
    		handleWindowClick,
    		handleClick,
    		handleClear,
    		loadList,
    		placeholderText,
    		showSelectedItem,
    		disabled
    	});

    	$$self.$inject_state = $$props => {
    		if ('container' in $$props) $$invalidate(2, container = $$props.container);
    		if ('input' in $$props) $$invalidate(3, input = $$props.input);
    		if ('Item' in $$props) $$invalidate(39, Item$1 = $$props.Item);
    		if ('Selection' in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
    		if ('MultiSelection' in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
    		if ('isMulti' in $$props) $$invalidate(8, isMulti = $$props.isMulti);
    		if ('multiFullItemClearable' in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('isDisabled' in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
    		if ('isCreatable' in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
    		if ('isFocused' in $$props) $$invalidate(4, isFocused = $$props.isFocused);
    		if ('selectedValue' in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ('filterText' in $$props) $$invalidate(1, filterText = $$props.filterText);
    		if ('placeholder' in $$props) $$invalidate(41, placeholder = $$props.placeholder);
    		if ('items' in $$props) $$invalidate(35, items = $$props.items);
    		if ('itemFilter' in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
    		if ('groupBy' in $$props) $$invalidate(43, groupBy = $$props.groupBy);
    		if ('groupFilter' in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
    		if ('isGroupHeaderSelectable' in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('getOptionLabel' in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
    		if ('optionIdentifier' in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
    		if ('loadOptions' in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
    		if ('hasError' in $$props) $$invalidate(11, hasError = $$props.hasError);
    		if ('containerStyles' in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
    		if ('getSelectionLabel' in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
    		if ('createGroupHeaderItem' in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ('createItem' in $$props) $$invalidate(51, createItem = $$props.createItem);
    		if ('isSearchable' in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
    		if ('inputStyles' in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
    		if ('isClearable' in $$props) $$invalidate(16, isClearable = $$props.isClearable);
    		if ('isWaiting' in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
    		if ('listPlacement' in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
    		if ('listOpen' in $$props) $$invalidate(37, listOpen = $$props.listOpen);
    		if ('list' in $$props) $$invalidate(36, list = $$props.list);
    		if ('isVirtualList' in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
    		if ('loadOptionsInterval' in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ('noOptionsMessage' in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
    		if ('hideEmptyState' in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
    		if ('filteredItems' in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
    		if ('inputAttributes' in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
    		if ('listAutoWidth' in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
    		if ('itemHeight' in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
    		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    		if ('target' in $$props) target = $$props.target;
    		if ('activeSelectedValue' in $$props) $$invalidate(25, activeSelectedValue = $$props.activeSelectedValue);
    		if ('_items' in $$props) $$invalidate(75, _items = $$props._items);
    		if ('originalItemsClone' in $$props) $$invalidate(60, originalItemsClone = $$props.originalItemsClone);
    		if ('prev_selectedValue' in $$props) prev_selectedValue = $$props.prev_selectedValue;
    		if ('prev_listOpen' in $$props) prev_listOpen = $$props.prev_listOpen;
    		if ('prev_filterText' in $$props) prev_filterText = $$props.prev_filterText;
    		if ('prev_isFocused' in $$props) prev_isFocused = $$props.prev_isFocused;
    		if ('prev_filteredItems' in $$props) prev_filteredItems = $$props.prev_filteredItems;
    		if ('getItemsHasInvoked' in $$props) getItemsHasInvoked = $$props.getItemsHasInvoked;
    		if ('_inputAttributes' in $$props) $$invalidate(26, _inputAttributes = $$props._inputAttributes);
    		if ('placeholderText' in $$props) $$invalidate(27, placeholderText = $$props.placeholderText);
    		if ('showSelectedItem' in $$props) $$invalidate(28, showSelectedItem = $$props.showSelectedItem);
    		if ('disabled' in $$props) disabled = $$props.disabled;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*isDisabled*/ 1024) {
    			disabled = isDisabled;
    		}

    		if ($$self.$$.dirty[1] & /*items*/ 16) {
    			updateSelectedValueDisplay(items);
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue, isMulti*/ 257 | $$self.$$.dirty[1] & /*optionIdentifier*/ 131072) {
    			{
    				if (typeof selectedValue === "string") {
    					$$invalidate(0, selectedValue = {
    						[optionIdentifier]: selectedValue,
    						label: selectedValue
    					});
    				} else if (isMulti && Array.isArray(selectedValue) && selectedValue.length > 0) {
    					$$invalidate(0, selectedValue = selectedValue.map(item => typeof item === "string"
    					? { value: item, label: item }
    					: item));
    				}
    			}
    		}

    		if ($$self.$$.dirty[1] & /*noOptionsMessage, list*/ 16777248) {
    			{
    				if (noOptionsMessage && list) list.$set({ noOptionsMessage });
    			}
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue, filterText*/ 3) {
    			$$invalidate(28, showSelectedItem = selectedValue && filterText.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue*/ 1 | $$self.$$.dirty[1] & /*placeholder*/ 1024) {
    			$$invalidate(27, placeholderText = selectedValue ? "" : placeholder);
    		}

    		if ($$self.$$.dirty[0] & /*isSearchable*/ 16384 | $$self.$$.dirty[1] & /*inputAttributes*/ 67108864) {
    			{
    				$$invalidate(26, _inputAttributes = Object.assign(
    					{
    						autocomplete: "off",
    						autocorrect: "off",
    						spellcheck: false
    					},
    					inputAttributes
    				));

    				if (!isSearchable) {
    					$$invalidate(26, _inputAttributes.readonly = true, _inputAttributes);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*filterText, isMulti, selectedValue*/ 259 | $$self.$$.dirty[1] & /*items, loadOptions, originalItemsClone, optionIdentifier, itemFilter, getOptionLabel, groupBy, createGroupHeaderItem, isGroupHeaderSelectable, groupFilter*/ 537884688) {
    			{
    				let _filteredItems;
    				let _items = items;

    				if (items && items.length > 0 && typeof items[0] !== "object") {
    					_items = items.map((item, index) => {
    						return { index, value: item, label: item };
    					});
    				}

    				if (loadOptions && filterText.length === 0 && originalItemsClone) {
    					_filteredItems = JSON.parse(originalItemsClone);
    					_items = JSON.parse(originalItemsClone);
    				} else {
    					_filteredItems = loadOptions
    					? filterText.length === 0 ? [] : _items
    					: _items.filter(item => {
    							let keepItem = true;

    							if (isMulti && selectedValue) {
    								keepItem = !selectedValue.some(value => {
    									return value[optionIdentifier] === item[optionIdentifier];
    								});
    							}

    							if (!keepItem) return false;
    							if (filterText.length < 1) return true;
    							return itemFilter(getOptionLabel(item, filterText), filterText, item);
    						});
    				}

    				if (groupBy) {
    					const groupValues = [];
    					const groups = {};

    					_filteredItems.forEach(item => {
    						const groupValue = groupBy(item);

    						if (!groupValues.includes(groupValue)) {
    							groupValues.push(groupValue);
    							groups[groupValue] = [];

    							if (groupValue) {
    								groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
    									id: groupValue,
    									isGroupHeader: true,
    									isSelectable: isGroupHeaderSelectable
    								}));
    							}
    						}

    						groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    					});

    					const sortedGroupedItems = [];

    					groupFilter(groupValues).forEach(groupValue => {
    						sortedGroupedItems.push(...groups[groupValue]);
    					});

    					$$invalidate(38, filteredItems = sortedGroupedItems);
    				} else {
    					$$invalidate(38, filteredItems = _filteredItems);
    				}
    			}
    		}
    	};

    	return [
    		selectedValue,
    		filterText,
    		container,
    		input,
    		isFocused,
    		isWaiting,
    		Selection$1,
    		MultiSelection$1,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon$1,
    		handleClear,
    		activeSelectedValue,
    		_inputAttributes,
    		placeholderText,
    		showSelectedItem,
    		handleMultiItemClear,
    		getPosition,
    		handleKeyDown,
    		handleFocus,
    		handleWindowClick,
    		handleClick,
    		items,
    		list,
    		listOpen,
    		filteredItems,
    		Item$1,
    		isCreatable,
    		placeholder,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		createGroupHeaderItem,
    		createItem,
    		listPlacement,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		originalItemsClone,
    		input_1_binding,
    		input_1_input_handler,
    		input_1_binding_1,
    		input_1_input_handler_1,
    		div_binding
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$O,
    			create_fragment$N,
    			safe_not_equal,
    			{
    				container: 2,
    				input: 3,
    				Item: 39,
    				Selection: 6,
    				MultiSelection: 7,
    				isMulti: 8,
    				multiFullItemClearable: 9,
    				isDisabled: 10,
    				isCreatable: 40,
    				isFocused: 4,
    				selectedValue: 0,
    				filterText: 1,
    				placeholder: 41,
    				items: 35,
    				itemFilter: 42,
    				groupBy: 43,
    				groupFilter: 44,
    				isGroupHeaderSelectable: 45,
    				getGroupHeaderLabel: 46,
    				getOptionLabel: 47,
    				optionIdentifier: 48,
    				loadOptions: 49,
    				hasError: 11,
    				containerStyles: 12,
    				getSelectionLabel: 13,
    				createGroupHeaderItem: 50,
    				createItem: 51,
    				isSearchable: 14,
    				inputStyles: 15,
    				isClearable: 16,
    				isWaiting: 5,
    				listPlacement: 52,
    				listOpen: 37,
    				list: 36,
    				isVirtualList: 53,
    				loadOptionsInterval: 54,
    				noOptionsMessage: 55,
    				hideEmptyState: 56,
    				filteredItems: 38,
    				inputAttributes: 57,
    				listAutoWidth: 58,
    				itemHeight: 59,
    				Icon: 17,
    				iconProps: 18,
    				showChevron: 19,
    				showIndicator: 20,
    				containerClasses: 21,
    				indicatorSvg: 22,
    				ClearIcon: 23,
    				handleClear: 24
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get container() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Selection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Selection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get MultiSelection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set MultiSelection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isCreatable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCreatable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFocused() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFocused(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupBy() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupBy(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isGroupHeaderSelectable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isGroupHeaderSelectable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptions() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptions(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasError() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasError(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createGroupHeaderItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createGroupHeaderItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSearchable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSearchable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isWaiting() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isWaiting(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listPlacement() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listPlacement(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listOpen() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listOpen(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get list() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptionsInterval() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptionsInterval(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filteredItems() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filteredItems(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputAttributes() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputAttributes(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listAutoWidth() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listAutoWidth(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Icon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Icon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChevron() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChevron(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showIndicator() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showIndicator(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerClasses() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerClasses(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorSvg() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorSvg(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ClearIcon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ClearIcon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleClear() {
    		return this.$$.ctx[24];
    	}

    	set handleClear(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const VoteStore = writable({
      votedTeam: false,
      votedPlayer: false
    });
    let instance$N;
    class Vote extends RESTClient {
      constructor() {
        super();
        VoteStore.update(u => ({
          votedTeam: window.localStorage.getItem('votedTeam') ? window.localStorage.getItem('votedTeam') : false,
          votedPlayer: window.localStorage.getItem('votedPlayer') ? window.localStorage.getItem('votedPlayer') : false
        }));
      }

      store() {
        return VoteStore;
      }

      async votePlayer(id) {
        let status = await this.post(`vote/player/${id}`);

        if (status.status == 'OK') {
          VoteStore.update(u => ({ ...u,
            votedPlayer: id
          }));
          window.localStorage.setItem('votedPlayer', id);
        }
      }

      async voteTeam(id) {
        let status = await this.post(`vote/team/${id}`);

        if (status.status == 'OK') {
          VoteStore.update(u => ({ ...u,
            votedTeam: id
          }));
          window.localStorage.setItem('votedTeam', id);
        }
      }

      static getInstance() {
        if (!instance$N) {
          instance$N = new Vote();
        }

        return instance$N;
      }

    }

    /* src/pages/vote.svelte generated by Svelte v3.41.0 */

    const { console: console_1$4 } = globals;
    const file$G = "src/pages/vote.svelte";

    function create_fragment$M(ctx) {
    	let section;
    	let div9;
    	let div8;
    	let div7;
    	let div6;
    	let div2;
    	let div1;
    	let h30;
    	let t1;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t2;
    	let p0;
    	let t4;
    	let div5;
    	let div4;
    	let h31;
    	let t6;
    	let div3;
    	let img1;
    	let img1_src_value;
    	let t7;
    	let p1;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			h30 = element("h3");
    			h30.textContent = "FAN FAVOURITE TEAM";
    			t1 = space();
    			div0 = element("div");
    			img0 = element("img");
    			t2 = space();
    			p0 = element("p");
    			p0.textContent = "Total Gaming";
    			t4 = space();
    			div5 = element("div");
    			div4 = element("div");
    			h31 = element("h3");
    			h31.textContent = "FAN FAVOURITE PLAYER";
    			t6 = space();
    			div3 = element("div");
    			img1 = element("img");
    			t7 = space();
    			p1 = element("p");
    			p1.textContent = "TE-Pahadi";
    			attr_dev(h30, "class", "vote-for");
    			add_location(h30, file$G, 130, 28, 5822);
    			if (!src_url_equal(img0.src, img0_src_value = "images/Total_Gaming_Logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "Total gaming");
    			add_location(img0, file$G, 132, 32, 5953);
    			attr_dev(p0, "class", "fan-fav-title");
    			add_location(p0, file$G, 133, 32, 6045);
    			attr_dev(div0, "class", "fan-fev-img");
    			add_location(div0, file$G, 131, 28, 5895);
    			attr_dev(div1, "class", "vote-for-team");
    			add_location(div1, file$G, 128, 24, 5684);
    			attr_dev(div2, "class", "col-md-6");
    			add_location(div2, file$G, 127, 20, 5637);
    			attr_dev(h31, "class", "vote-for");
    			add_location(h31, file$G, 155, 28, 7594);
    			if (!src_url_equal(img1.src, img1_src_value = "images/TE-Pahadi.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "pahadi");
    			add_location(img1, file$G, 157, 32, 7734);
    			attr_dev(p1, "class", "fan-fav-title");
    			add_location(p1, file$G, 158, 32, 7812);
    			attr_dev(div3, "class", "fan-fev-img pahadi");
    			add_location(div3, file$G, 156, 28, 7669);
    			attr_dev(div4, "class", "vote-for-player");
    			add_location(div4, file$G, 153, 24, 7454);
    			attr_dev(div5, "class", "col-md-6");
    			add_location(div5, file$G, 152, 20, 7407);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$G, 126, 16, 5599);
    			attr_dev(div7, "class", "voting-team-container");
    			add_location(div7, file$G, 125, 12, 5547);
    			attr_dev(div8, "class", "container");
    			add_location(div8, file$G, 113, 8, 5070);
    			attr_dev(div9, "class", "voting-container");
    			add_location(div9, file$G, 112, 4, 5031);
    			attr_dev(section, "id", "voting_section");
    			add_location(section, file$G, 111, 0, 4975);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div2);
    			append_dev(div2, div1);
    			append_dev(div1, h30);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, img0);
    			append_dev(div0, t2);
    			append_dev(div0, p0);
    			append_dev(div6, t4);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, h31);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			append_dev(div3, img1);
    			append_dev(div3, t7);
    			append_dev(div3, p1);
    			/*section_binding*/ ctx[2](section);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			/*section_binding*/ ctx[2](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $path;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Vote', slots, []);
    	let teamVoteStatus = false;
    	let playerVoteStatus = false;
    	let teamSelected = undefined;
    	let playerSelected = undefined;
    	const path = getHistory().currentPath;
    	validate_store(path, 'path');
    	component_subscribe($$self, path, value => $$invalidate(5, $path = value));
    	let contestEl;
    	let thisEl;

    	onMount(() => {
    		if ($path.indexOf('/vote') == 0) {
    			//setTimeout(() => {window.scrollTo(0, contestEl.offsetTop - window.innerHeight + 500)}, 500);
    			contestEl.scrollIntoView();
    		} //console.log(contestEl.offsetTop - window.innerHeight);
    	});

    	let playersData = [
    		{
    			value: 672,
    			label: '6S-FABINDRO',
    			group: 'Sixth Sense'
    		},
    		{
    			value: 33458,
    			label: '6S-MRJAYYT',
    			group: 'Sixth Sense'
    		},
    		{
    			value: 33704,
    			label: '6S-GINOTRA',
    			group: 'Sixth Sense'
    		},
    		{
    			value: 419199,
    			label: '6S-ILUMINATI  ',
    			group: 'Sixth Sense'
    		},
    		{
    			value: 560,
    			label: 'mYm-WELLS ',
    			group: 'TEAM MAYHEM'
    		},
    		{
    			value: 602,
    			label: 'mYm-NINJA ',
    			group: 'TEAM MAYHEM'
    		},
    		{
    			value: 1123,
    			label: 'mYm-MARVEL',
    			group: 'TEAM MAYHEM'
    		},
    		{
    			value: 419208,
    			label: 'mYm-JAILBIRD  ',
    			group: 'TEAM MAYHEM'
    		},
    		{
    			value: 1382,
    			label: 'Lh Baby¹⁴³',
    			group: 'LIFE HACKERS '
    		},
    		{
    			value: 1724,
    			label: 'LH Old Monk',
    			group: 'LIFE HACKERS '
    		},
    		{
    			value: 13742,
    			label: 'Lh Predator',
    			group: 'LIFE HACKERS '
    		},
    		{
    			value: 419206,
    			label: 'Aatank tazu',
    			group: 'LIFE HACKERS '
    		},
    		{
    			value: 1622,
    			label: 'TC-SCARY GAMER',
    			group: 'TEAM CHAOS '
    		},
    		{
    			value: 2115,
    			label: 'TC-KUNALJR',
    			group: 'TEAM CHAOS '
    		},
    		{
    			value: 4697,
    			label: 'TC_TECHKK ',
    			group: 'TEAM CHAOS '
    		},
    		{
    			value: 5621,
    			label: 'TC-PRATHAM',
    			group: 'TEAM CHAOS '
    		},
    		{
    			value: 2389,
    			label: 'hex-YASH_09',
    			group: 'Hex Esports'
    		},
    		{
    			value: 15278,
    			label: 'hexRITIKSTAR  ',
    			group: 'Hex Esports'
    		},
    		{
    			value: 18562,
    			label: 'Infintz',
    			group: 'Hex Esports'
    		},
    		{
    			value: 18902,
    			label: 'hexMAFIA  ',
    			group: 'Hex Esports'
    		},
    		{
    			value: 4920,
    			label: 'RavenDEDSHOT  ',
    			group: 'Raven esports'
    		},
    		{
    			value: 6014,
    			label: 'Raven-SHiV',
    			group: 'Raven esports'
    		},
    		{
    			value: 10291,
    			label: 'Raven-AJIT',
    			group: 'Raven esports'
    		},
    		{
    			value: 24521,
    			label: 'Raven-PRADDY  ',
    			group: 'Raven esports'
    		},
    		{
    			value: 4449,
    			label: 'TE-RDP',
    			group: 'SURVIVOR4AM '
    		},
    		{
    			value: 14908,
    			label: 'SRV-IGNITE',
    			group: 'SURVIVOR4AM '
    		},
    		{
    			value: 30282,
    			label: 'SRV-Golden',
    			group: 'SURVIVOR4AM '
    		},
    		{
    			value: 158904,
    			label: 'SRV-SID__ ',
    			group: 'SURVIVOR4AM '
    		},
    		{
    			value: 13879,
    			label: 'GXR-BARCABOI  ',
    			group: 'Galaxy Racers'
    		},
    		{
    			value: 18006,
    			label: 'GXR-VasiyoCRJ ',
    			group: 'Galaxy Racers'
    		},
    		{
    			value: 25146,
    			label: 'GXR-MARYX ',
    			group: 'Galaxy Racers'
    		},
    		{
    			value: 26907,
    			label: 'GXR-aman2518  ',
    			group: 'Galaxy Racers'
    		},
    		{
    			value: 10455,
    			label: '1nsaneLikhi  ',
    			group: 'Blood bashers07'
    		},
    		{
    			value: 35523,
    			label: '♤Ꭼᴅᴡᴀʀᴅ㕄來  ',
    			group: 'Blood bashers07'
    		},
    		{
    			value: 35630,
    			label: '1nsaneAryan  ',
    			group: 'Blood bashers07'
    		},
    		{
    			value: 35660,
    			label: 'BLD-Subhu!',
    			group: 'Blood bashers07'
    		},
    		{
    			value: 34113,
    			label: '4UN-WIZARDO',
    			group: '4UNKNOWN '
    		},
    		{
    			value: 293342,
    			label: '4UN-DEADSOUL  ',
    			group: '4UNKNOWN '
    		},
    		{
    			value: 297400,
    			label: '4UN-SWASTIK',
    			group: '4UNKNOWN '
    		},
    		{
    			value: 297434,
    			label: '4UN-ANAND ',
    			group: '4UNKNOWN '
    		},
    		{
    			value: 293349,
    			label: 'TG-PRINCE..!  ',
    			group: 'TOTAL GAMINGESPORT '
    		},
    		{
    			value: 374003,
    			label: 'TG-MAFIABALA  ',
    			group: 'TOTAL GAMINGESPORT '
    		},
    		{
    			value: 376869,
    			label: 'TG-JAVABOY',
    			group: 'TOTAL GAMINGESPORT '
    		},
    		{
    			value: 377161,
    			label: 'TG - FOZY AJAY',
    			group: 'TOTAL GAMINGESPORT '
    		},
    		{
    			value: 419195,
    			label: 'Iconic FF ',
    			group: 'Team Elite '
    		},
    		{
    			value: 419196,
    			label: 'Killer FF ',
    			group: 'Team Elite '
    		},
    		{
    			value: 419197,
    			label: 'Pahadi',
    			group: 'Team Elite '
    		},
    		{
    			value: 419198,
    			label: 'TE_JONTY  ',
    			group: 'Team Elite '
    		}
    	];

    	let teamsName = [
    		{ value: 418, label: 'Sixth Sense' },
    		{ value: 603, label: 'TEAM MAYHEM' },
    		{ value: 858, label: 'LIFE HACKERS' },
    		{ value: 971, label: 'TEAM CHAOS' },
    		{ value: 1325, label: 'Hex Esports' },
    		{ value: 2605, label: 'Raven esports' },
    		{ value: 6579, label: 'SURVIVOR4AM' },
    		{ value: 7987, label: 'Galaxy Racers' },
    		{ value: 14040, label: 'Blood bashers07' },
    		{ value: 113642, label: '4UNKNOWN' },
    		{
    			value: 138026,
    			label: 'TOTAL GAMINGESPORT'
    		},
    		{ value: 146446, label: 'Team Elite' }
    	];

    	const voteing = Vote.getInstance();
    	const voteStore = voteing.store();
    	const groupBy = item => item.group;

    	const handleTeamSelect = e => {
    		console.log(teamSelected);
    	};

    	const handlePlayerSelect = e => {
    		console.log(playerSelected);
    	};

    	voteStore.subscribe(status => {
    		if (status.votedPlayer) playerSelected = playersData.find(p => p.value == status.votedPlayer);
    		if (status.votedTeam) teamSelected = teamsName.find(t => t.value == status.votedTeam);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<Vote> was created with unknown prop '${key}'`);
    	});

    	function section_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contestEl = $$value;
    			$$invalidate(0, contestEl);
    		});
    	}

    	$$self.$capture_state = () => ({
    		Select,
    		Vote,
    		getHistory,
    		onMount,
    		teamVoteStatus,
    		playerVoteStatus,
    		teamSelected,
    		playerSelected,
    		path,
    		contestEl,
    		thisEl,
    		playersData,
    		teamsName,
    		voteing,
    		voteStore,
    		groupBy,
    		handleTeamSelect,
    		handlePlayerSelect,
    		$path
    	});

    	$$self.$inject_state = $$props => {
    		if ('teamVoteStatus' in $$props) teamVoteStatus = $$props.teamVoteStatus;
    		if ('playerVoteStatus' in $$props) playerVoteStatus = $$props.playerVoteStatus;
    		if ('teamSelected' in $$props) teamSelected = $$props.teamSelected;
    		if ('playerSelected' in $$props) playerSelected = $$props.playerSelected;
    		if ('contestEl' in $$props) $$invalidate(0, contestEl = $$props.contestEl);
    		if ('thisEl' in $$props) thisEl = $$props.thisEl;
    		if ('playersData' in $$props) playersData = $$props.playersData;
    		if ('teamsName' in $$props) teamsName = $$props.teamsName;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contestEl, path, section_binding];
    }

    class Vote_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Vote_1",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* src/layouts/partials/Insider.svelte generated by Svelte v3.41.0 */

    const file$F = "src/layouts/partials/Insider.svelte";

    function create_fragment$L(ctx) {
    	let div15;
    	let div6;
    	let div0;
    	let video0;
    	let source0;
    	let source0_src_value;
    	let t0;
    	let t1;
    	let video1;
    	let source1;
    	let source1_src_value;
    	let t2;
    	let t3;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t4;
    	let h1;
    	let t6;
    	let div14;
    	let div13;
    	let div12;
    	let div11;
    	let div8;
    	let p0;
    	let t8;
    	let div7;
    	let a0;
    	let t10;
    	let div10;
    	let p1;
    	let t12;
    	let section;
    	let div9;
    	let ul;
    	let li0;
    	let a1;
    	let img1;
    	let img1_src_value;
    	let t13;
    	let li1;
    	let a2;
    	let img2;
    	let img2_src_value;
    	let t14;
    	let li2;
    	let a3;
    	let img3;
    	let img3_src_value;
    	let t15;
    	let li3;
    	let a4;
    	let img4;
    	let img4_src_value;

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			video0 = element("video");
    			source0 = element("source");
    			t0 = text$1("\n                Your browser does not support the video tag.");
    			t1 = space();
    			video1 = element("video");
    			source1 = element("source");
    			t2 = text$1("\n                Your browser does not support the video tag.");
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			img0 = element("img");
    			t4 = space();
    			h1 = element("h1");
    			h1.textContent = "Mobile Gamers like you deserve to be a Snapdragon Insider";
    			t6 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			div8 = element("div");
    			p0 = element("p");
    			p0.textContent = "Sign up for exclusive Snapdragon Insiders emails.";
    			t8 = space();
    			div7 = element("div");
    			a0 = element("a");
    			a0.textContent = "Sign up";
    			t10 = space();
    			div10 = element("div");
    			p1 = element("p");
    			p1.textContent = "Join the Snapdragon Insiders community.";
    			t12 = space();
    			section = element("section");
    			div9 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			img1 = element("img");
    			t13 = space();
    			li1 = element("li");
    			a2 = element("a");
    			img2 = element("img");
    			t14 = space();
    			li2 = element("li");
    			a3 = element("a");
    			img3 = element("img");
    			t15 = space();
    			li3 = element("li");
    			a4 = element("a");
    			img4 = element("img");
    			if (!src_url_equal(source0.src, source0_src_value = "https://www.qualcomm.com/sites/ember/files/bg-videos/mp4/snapdragon-insiders-graphic-animation-v2_0.mp4")) attr_dev(source0, "src", source0_src_value);
    			attr_dev(source0, "type", "video/mp4");
    			add_location(source0, file$F, 9, 16, 311);
    			attr_dev(video0, "width", "100%");
    			attr_dev(video0, "height", "100%");
    			video0.autoplay = true;
    			video0.playsInline = true;
    			video0.loop = true;
    			video0.muted = true;
    			attr_dev(video0, "class", "video-mobile-none insider-pc-video");
    			add_location(video0, file$F, 8, 12, 185);
    			if (!src_url_equal(source1.src, source1_src_value = "https://www.qualcomm.com/sites/ember/files/bg-videos/mp4/snapdragon-insiders-graphic-animation-550.mp4")) attr_dev(source1, "src", source1_src_value);
    			attr_dev(source1, "type", "video/mp4");
    			add_location(source1, file$F, 13, 16, 654);
    			attr_dev(video1, "height", "100%");
    			video1.autoplay = true;
    			video1.loop = true;
    			video1.muted = true;
    			video1.playsInline = true;
    			attr_dev(video1, "class", "video-pc-none insider-mobile-video");
    			add_location(video1, file$F, 12, 12, 541);
    			attr_dev(div0, "class", "video-sec");
    			add_location(div0, file$F, 6, 8, 91);
    			if (!src_url_equal(img0.src, img0_src_value = "images/qc_x5f_sd_x5f_5g_x5f_badge-cmyk-flat_2_.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "home-logo");
    			add_location(img0, file$F, 22, 28, 1119);
    			add_location(h1, file$F, 24, 28, 1312);
    			attr_dev(div1, "class", "insider-main-section");
    			add_location(div1, file$F, 21, 24, 1056);
    			attr_dev(div2, "class", "col");
    			add_location(div2, file$F, 20, 20, 1014);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$F, 19, 16, 976);
    			attr_dev(div4, "class", "container");
    			add_location(div4, file$F, 18, 12, 936);
    			attr_dev(div5, "class", "insider-content");
    			add_location(div5, file$F, 17, 8, 894);
    			attr_dev(div6, "class", "top-section");
    			add_location(div6, file$F, 5, 4, 57);
    			add_location(p0, file$F, 40, 24, 2092);
    			attr_dev(a0, "href", "https://assets.qualcomm.com/snapdragon-insiders-sign-up.html");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "class", "sign-up-insider-btn");
    			add_location(a0, file$F, 42, 28, 2227);
    			attr_dev(div7, "class", "insider-btn");
    			add_location(div7, file$F, 41, 24, 2173);
    			attr_dev(div8, "class", "col-md-6 col-sm-12 col-xs-12");
    			add_location(div8, file$F, 39, 20, 2025);
    			add_location(p1, file$F, 46, 24, 2499);
    			if (!src_url_equal(img1.src, img1_src_value = "images/reddit.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "reddit");
    			add_location(img1, file$F, 52, 44, 2895);
    			attr_dev(a1, "href", "https://www.reddit.com/r/snapdragon/");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$F, 51, 40, 2787);
    			add_location(li0, file$F, 50, 36, 2742);
    			if (!src_url_equal(img2.src, img2_src_value = "images/twitter-insider.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "twitter");
    			add_location(img2, file$F, 57, 44, 3208);
    			attr_dev(a2, "href", "https://twitter.com/Snapdragon");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$F, 56, 40, 3106);
    			add_location(li1, file$F, 55, 36, 3061);
    			if (!src_url_equal(img3.src, img3_src_value = "images/insta-insider.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "insta");
    			add_location(img3, file$F, 62, 44, 3546);
    			attr_dev(a3, "href", "https://www.instagram.com/snapdragoninsiders/");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$F, 61, 40, 3429);
    			add_location(li2, file$F, 60, 36, 3384);
    			if (!src_url_equal(img4.src, img4_src_value = "images/youtube-insider.png")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "alt", "Youtube");
    			add_location(img4, file$F, 67, 44, 3869);
    			attr_dev(a4, "href", "https://www.youtube.com/snapdragon");
    			attr_dev(a4, "target", "_blank");
    			add_location(a4, file$F, 66, 40, 3763);
    			add_location(li3, file$F, 65, 36, 3718);
    			add_location(ul, file$F, 49, 32, 2701);
    			attr_dev(div9, "class", "container text-center");
    			add_location(div9, file$F, 48, 28, 2633);
    			attr_dev(section, "class", "social-links-top");
    			add_location(section, file$F, 47, 24, 2570);
    			attr_dev(div10, "class", "col-md-6 col-sm-12 col-xs-12");
    			add_location(div10, file$F, 45, 20, 2432);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$F, 38, 16, 1987);
    			attr_dev(div12, "class", "container insider-bottom");
    			add_location(div12, file$F, 37, 12, 1932);
    			attr_dev(div13, "class", "");
    			add_location(div13, file$F, 36, 8, 1905);
    			attr_dev(div14, "class", "insider-bottom-section");
    			add_location(div14, file$F, 35, 4, 1860);
    			attr_dev(div15, "class", "insider-container");
    			add_location(div15, file$F, 4, 0, 21);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div6);
    			append_dev(div6, div0);
    			append_dev(div0, video0);
    			append_dev(video0, source0);
    			append_dev(video0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, video1);
    			append_dev(video1, source1);
    			append_dev(video1, t2);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, img0);
    			append_dev(div1, t4);
    			append_dev(div1, h1);
    			append_dev(div15, t6);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, p0);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, a0);
    			append_dev(div11, t10);
    			append_dev(div11, div10);
    			append_dev(div10, p1);
    			append_dev(div10, t12);
    			append_dev(div10, section);
    			append_dev(section, div9);
    			append_dev(div9, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a1);
    			append_dev(a1, img1);
    			append_dev(ul, t13);
    			append_dev(ul, li1);
    			append_dev(li1, a2);
    			append_dev(a2, img2);
    			append_dev(ul, t14);
    			append_dev(ul, li2);
    			append_dev(li2, a3);
    			append_dev(a3, img3);
    			append_dev(ul, t15);
    			append_dev(ul, li3);
    			append_dev(li3, a4);
    			append_dev(a4, img4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Insider', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Insider> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Insider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Insider",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src/pages/Format_details.svelte generated by Svelte v3.41.0 */
    const file$E = "src/pages/Format_details.svelte";

    function create_fragment$K(ctx) {
    	let div2;
    	let div1;
    	let h1;
    	let t1;
    	let video;
    	let t2;
    	let div0;
    	let format;
    	let current;

    	video = new Video({
    			props: {
    				url: "https://www.youtube.com/watch?v=obJ469oN0Vg",
    				thumb: "/images/day_13_conquest_format-explainer_thumb_HINDI.jpg"
    			},
    			$$inline: true
    		});

    	format = new Format({ $$inline: true });

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Format";
    			t1 = space();
    			create_component(video.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			create_component(format.$$.fragment);
    			attr_dev(h1, "class", "title");
    			add_location(h1, file$E, 7, 2, 264);
    			attr_dev(div0, "class", "format-details");
    			add_location(div0, file$E, 9, 2, 424);
    			attr_dev(div1, "class", "top-section");
    			add_location(div1, file$E, 6, 1, 235);
    			attr_dev(div2, "class", "format-page");
    			add_location(div2, file$E, 5, 0, 207);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			mount_component(video, div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			mount_component(format, div0, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			transition_in(format.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			transition_out(format.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(video);
    			destroy_component(format);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Format_details', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Format_details> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Format,
    		Tabs,
    		TabList,
    		TabPanel,
    		Tab,
    		Video
    	});

    	return [];
    }

    class Format_details extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Format_details",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src/layouts/partials/SigninInsider.svelte generated by Svelte v3.41.0 */

    const file$D = "src/layouts/partials/SigninInsider.svelte";

    function create_fragment$J(ctx) {
    	let section;
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let t1;
    	let a;
    	let t2;
    	let span;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Mobile Gamers like you deserve to be a Snapdragon Insider";
    			t1 = space();
    			a = element("a");
    			t2 = text$1("Sign up Today \n                    ");
    			span = element("span");
    			span.textContent = "keyboard_arrow_right";
    			attr_dev(div0, "class", "title");
    			add_location(div0, file$D, 8, 16, 192);
    			attr_dev(span, "class", "material-icons");
    			add_location(span, file$D, 12, 20, 376);
    			attr_dev(a, "href", "#");
    			add_location(a, file$D, 11, 16, 329);
    			attr_dev(div1, "class", "col-md-8 col-xs-12");
    			add_location(div1, file$D, 7, 12, 143);
    			attr_dev(div2, "class", "row justify-content-center");
    			add_location(div2, file$D, 6, 8, 90);
    			attr_dev(div3, "class", "container");
    			add_location(div3, file$D, 5, 4, 58);
    			attr_dev(section, "class", "signin-insider");
    			add_location(section, file$D, 4, 0, 21);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, a);
    			append_dev(a, t2);
    			append_dev(a, span);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SigninInsider', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SigninInsider> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class SigninInsider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SigninInsider",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src/pages/Home.svelte generated by Svelte v3.41.0 */
    const file$C = "src/pages/Home.svelte";

    function create_fragment$I(ctx) {
    	let section0;
    	let div12;
    	let div11;
    	let div8;
    	let div7;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div4;
    	let div3;
    	let div1;
    	let t2;
    	let div2;
    	let t4;
    	let div5;
    	let a0;
    	let t6;
    	let div6;
    	let img1;
    	let img1_src_value;
    	let t7;
    	let div10;
    	let div9;
    	let img2;
    	let img2_src_value;
    	let t8;
    	let section1;
    	let div13;
    	let h6;
    	let t10;
    	let ul;
    	let li0;
    	let a1;
    	let img3;
    	let img3_src_value;
    	let t11;
    	let li1;
    	let a2;
    	let img4;
    	let img4_src_value;
    	let t12;
    	let li2;
    	let a3;
    	let img5;
    	let img5_src_value;
    	let t13;
    	let li3;
    	let a4;
    	let img6;
    	let img6_src_value;
    	let t14;
    	let insider;
    	let t15;
    	let formatdetails;
    	let t16;
    	let compete;
    	let current;
    	insider = new Insider({ $$inline: true });
    	formatdetails = new Format_details({ $$inline: true });
    	compete = new Compete({ $$inline: true });

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div12 = element("div");
    			div11 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			img0 = element("img");
    			t0 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div1.textContent = "PRIZE POOL";
    			t2 = space();
    			div2 = element("div");
    			div2.textContent = "30,00,000";
    			t4 = space();
    			div5 = element("div");
    			a0 = element("a");
    			a0.textContent = "Watch Trailer";
    			t6 = space();
    			div6 = element("div");
    			img1 = element("img");
    			t7 = space();
    			div10 = element("div");
    			div9 = element("div");
    			img2 = element("img");
    			t8 = space();
    			section1 = element("section");
    			div13 = element("div");
    			h6 = element("h6");
    			h6.textContent = "Follow Snapdragon Conquest on";
    			t10 = space();
    			ul = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			img3 = element("img");
    			t11 = space();
    			li1 = element("li");
    			a2 = element("a");
    			img4 = element("img");
    			t12 = space();
    			li2 = element("li");
    			a3 = element("a");
    			img5 = element("img");
    			t13 = space();
    			li3 = element("li");
    			a4 = element("a");
    			img6 = element("img");
    			t14 = space();
    			create_component(insider.$$.fragment);
    			t15 = space();
    			create_component(formatdetails.$$.fragment);
    			t16 = space();
    			create_component(compete.$$.fragment);
    			if (!src_url_equal(img0.src, img0_src_value = "images/home-logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "home-logo");
    			add_location(img0, file$C, 23, 6, 903);
    			attr_dev(div0, "class", "qual-banner-logo");
    			add_location(div0, file$C, 22, 5, 866);
    			attr_dev(div1, "class", "winner-label pt-3");
    			add_location(div1, file$C, 27, 7, 1039);
    			attr_dev(div2, "class", "price-txt");
    			add_location(div2, file$C, 30, 7, 1111);
    			attr_dev(div3, "class", "winnig-price svelte-xj9ehz");
    			add_location(div3, file$C, 26, 6, 1005);
    			attr_dev(div4, "class", "free-fire-block");
    			add_location(div4, file$C, 25, 5, 969);
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "btn btn-primary register-btn watch-finals-btn");
    			add_location(a0, file$C, 37, 6, 1242);
    			attr_dev(div5, "class", "banner-bttom mt-40");
    			add_location(div5, file$C, 36, 5, 1203);
    			if (!src_url_equal(img1.src, img1_src_value = "images/logos-sponsor.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "FreeFire-Logo");
    			add_location(img1, file$C, 42, 6, 1393);
    			attr_dev(div6, "class", "free-fire-logo");
    			add_location(div6, file$C, 41, 5, 1358);
    			attr_dev(div7, "class", "content-wrapper s2-title-section");
    			add_location(div7, file$C, 21, 4, 814);
    			attr_dev(div8, "class", "col-lg-5 col-sm-5 col-xs-12");
    			add_location(div8, file$C, 19, 3, 726);
    			if (!src_url_equal(img2.src, img2_src_value = "images/img-hero-characters.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "home-logo");
    			add_location(img2, file$C, 49, 5, 1571);
    			attr_dev(div9, "class", "hero-image");
    			add_location(div9, file$C, 48, 4, 1541);
    			attr_dev(div10, "class", "col-lg-7 col-sm-7 col-xs-12 p-0");
    			add_location(div10, file$C, 47, 3, 1491);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$C, 18, 2, 705);
    			attr_dev(div12, "class", "container-fluid");
    			add_location(div12, file$C, 17, 1, 673);
    			attr_dev(section0, "class", "main-section");
    			add_location(section0, file$C, 16, 0, 641);
    			add_location(h6, file$C, 57, 2, 1753);
    			if (!src_url_equal(img3.src, img3_src_value = "images/ic-facebook-light.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "Facebook");
    			add_location(img3, file$C, 61, 5, 1888);
    			attr_dev(a1, "href", "https://www.facebook.com/snapdragonconquest/");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$C, 60, 4, 1811);
    			add_location(li0, file$C, 59, 3, 1802);
    			if (!src_url_equal(img4.src, img4_src_value = "images/ic-instagram-light.png")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "alt", "Instagram");
    			add_location(img4, file$C, 66, 5, 2052);
    			attr_dev(a2, "href", "https://www.instagram.com/snapdragonconquest/");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$C, 65, 4, 1974);
    			add_location(li1, file$C, 64, 3, 1965);
    			if (!src_url_equal(img5.src, img5_src_value = "images/ic-twitter-light.png")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "alt", "Twitter");
    			add_location(img5, file$C, 71, 5, 2215);
    			attr_dev(a3, "href", "https://mobile.twitter.com/_ConquestEsport");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$C, 70, 4, 2140);
    			add_location(li2, file$C, 69, 3, 2131);
    			if (!src_url_equal(img6.src, img6_src_value = "images/ic-youtube-light.png")) attr_dev(img6, "src", img6_src_value);
    			attr_dev(img6, "alt", "Youtube");
    			add_location(img6, file$C, 76, 5, 2384);
    			attr_dev(a4, "href", "https://youtube.com/channel/UCqfsjVyKK2_ajIgG_HqR36w");
    			attr_dev(a4, "target", "_blank");
    			add_location(a4, file$C, 75, 4, 2299);
    			add_location(li3, file$C, 74, 3, 2290);
    			add_location(ul, file$C, 58, 2, 1794);
    			attr_dev(div13, "class", "container text-center");
    			add_location(div13, file$C, 56, 1, 1715);
    			attr_dev(section1, "class", "social-links-top");
    			add_location(section1, file$C, 55, 0, 1679);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, img0);
    			append_dev(div7, t0);
    			append_dev(div7, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div7, t4);
    			append_dev(div7, div5);
    			append_dev(div5, a0);
    			append_dev(div7, t6);
    			append_dev(div7, div6);
    			append_dev(div6, img1);
    			append_dev(div11, t7);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, img2);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div13);
    			append_dev(div13, h6);
    			append_dev(div13, t10);
    			append_dev(div13, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a1);
    			append_dev(a1, img3);
    			append_dev(ul, t11);
    			append_dev(ul, li1);
    			append_dev(li1, a2);
    			append_dev(a2, img4);
    			append_dev(ul, t12);
    			append_dev(ul, li2);
    			append_dev(li2, a3);
    			append_dev(a3, img5);
    			append_dev(ul, t13);
    			append_dev(ul, li3);
    			append_dev(li3, a4);
    			append_dev(a4, img6);
    			insert_dev(target, t14, anchor);
    			mount_component(insider, target, anchor);
    			insert_dev(target, t15, anchor);
    			mount_component(formatdetails, target, anchor);
    			insert_dev(target, t16, anchor);
    			mount_component(compete, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(insider.$$.fragment, local);
    			transition_in(formatdetails.$$.fragment, local);
    			transition_in(compete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(insider.$$.fragment, local);
    			transition_out(formatdetails.$$.fragment, local);
    			transition_out(compete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(section1);
    			if (detaching) detach_dev(t14);
    			destroy_component(insider, detaching);
    			if (detaching) detach_dev(t15);
    			destroy_component(formatdetails, detaching);
    			if (detaching) detach_dev(t16);
    			destroy_component(compete, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const user = User.getUser();
    	const urlParams = new URLSearchParams(window.location.search);

    	if (urlParams.get('r') != null) {
    		window.localStorage.setItem('referral', urlParams.get('r'));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Format,
    		User,
    		Video,
    		Vote: Vote_1,
    		Insider,
    		FormatDetails: Format_details,
    		SigninInsider,
    		Compete,
    		user,
    		urlParams
    	});

    	return [];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src/pages/HomePage2.svelte generated by Svelte v3.41.0 */
    const file$B = "src/pages/HomePage2.svelte";

    function create_fragment$H(ctx) {
    	let section;
    	let div14;
    	let div0;
    	let t0;
    	let div13;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t1;
    	let div9;
    	let h60;
    	let t3;
    	let div2;
    	let small0;
    	let t4;
    	let div7;
    	let div3;
    	let t6;
    	let div4;
    	let t8;
    	let div5;
    	let t10;
    	let div6;
    	let small1;
    	let t11;
    	let h61;
    	let t12;
    	let span;
    	let t14;
    	let small2;
    	let t16;
    	let div8;
    	let ul;
    	let li0;
    	let a0;
    	let img1;
    	let img1_src_value;
    	let t17;
    	let li1;
    	let a1;
    	let img2;
    	let img2_src_value;
    	let t18;
    	let li2;
    	let a2;
    	let img3;
    	let img3_src_value;
    	let t19;
    	let li3;
    	let a3;
    	let img4;
    	let img4_src_value;
    	let t20;
    	let div10;
    	let t21;
    	let div11;
    	let img5;
    	let img5_src_value;
    	let t22;
    	let img6;
    	let img6_src_value;
    	let t23;
    	let div12;
    	let img7;
    	let img7_src_value;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div14 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div13 = element("div");
    			div1 = element("div");
    			img0 = element("img");
    			t1 = space();
    			div9 = element("div");
    			h60 = element("h6");
    			h60.textContent = "FREE FIRE OPEN 2020";
    			t3 = space();
    			div2 = element("div");
    			small0 = element("small");
    			t4 = space();
    			div7 = element("div");
    			div3 = element("div");
    			div3.textContent = "WIN INR";
    			t6 = space();
    			div4 = element("div");
    			div4.textContent = "₹ 50,00,000";
    			t8 = space();
    			div5 = element("div");
    			div5.textContent = "PRIZE POOL";
    			t10 = space();
    			div6 = element("div");
    			small1 = element("small");
    			t11 = space();
    			h61 = element("h6");
    			t12 = text$1("Registrations begin on ");
    			span = element("span");
    			span.textContent = "08 December 2020";
    			t14 = space();
    			small2 = element("small");
    			small2.textContent = "Like and follow us to get regular updates";
    			t16 = space();
    			div8 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			img1 = element("img");
    			t17 = space();
    			li1 = element("li");
    			a1 = element("a");
    			img2 = element("img");
    			t18 = space();
    			li2 = element("li");
    			a2 = element("a");
    			img3 = element("img");
    			t19 = space();
    			li3 = element("li");
    			a3 = element("a");
    			img4 = element("img");
    			t20 = space();
    			div10 = element("div");
    			t21 = space();
    			div11 = element("div");
    			img5 = element("img");
    			t22 = space();
    			img6 = element("img");
    			t23 = space();
    			div12 = element("div");
    			img7 = element("img");
    			attr_dev(div0, "class", "game-pic d-none d-sm-block");
    			add_location(div0, file$B, 7, 2, 219);
    			if (!src_url_equal(img0.src, img0_src_value = "images/home-logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "class", "hp-logo");
    			attr_dev(img0, "alt", "home-logo");
    			add_location(img0, file$B, 10, 4, 320);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$B, 9, 3, 301);
    			add_location(h60, file$B, 13, 4, 432);
    			add_location(small0, file$B, 17, 5, 516);
    			attr_dev(div2, "class", "text-center bar-line");
    			add_location(div2, file$B, 16, 4, 476);
    			attr_dev(div3, "class", "winner-label mt-3");
    			add_location(div3, file$B, 20, 5, 579);
    			attr_dev(div4, "class", "price-txt");
    			add_location(div4, file$B, 23, 5, 642);
    			attr_dev(div5, "class", "winner-label");
    			add_location(div5, file$B, 26, 5, 701);
    			add_location(small1, file$B, 30, 6, 808);
    			attr_dev(div6, "class", "text-center bar-line mt-3");
    			add_location(div6, file$B, 29, 5, 762);
    			attr_dev(div7, "class", "winnig-price");
    			add_location(div7, file$B, 19, 4, 547);
    			attr_dev(span, "class", "svelte-1jlzhno");
    			add_location(span, file$B, 34, 28, 900);
    			attr_dev(h61, "class", "cmg-txt svelte-1jlzhno");
    			add_location(h61, file$B, 33, 4, 851);
    			attr_dev(small2, "class", "flw-txt");
    			add_location(small2, file$B, 36, 4, 944);
    			attr_dev(img1, "alt", "Facebook");
    			if (!src_url_equal(img1.src, img1_src_value = "/images/ic-facebook-light/ic-facebook-light.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "srcset", "/images/ic-facebook-light/ic-facebook-light@2x.png 2x,\n\t\t\t\t\t\t\t\t\t\t\t/images/ic-facebook-light/ic-facebook-light@3x.png 3x");
    			attr_dev(img1, "class", "ic-facebook-light");
    			add_location(img1, file$B, 43, 8, 1279);
    			attr_dev(a0, "href", "https://www.facebook.com/snapdragonconquest/");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$B, 42, 7, 1199);
    			attr_dev(li0, "class", "svelte-1jlzhno");
    			add_location(li0, file$B, 41, 6, 1187);
    			attr_dev(img2, "alt", "Instagram");
    			if (!src_url_equal(img2.src, img2_src_value = "/images/ic-instagram-light/ic-instagram-light.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "srcset", "/images/ic-instagram-light/ic-instagram-light@2x.png 2x,\n\t\t\t\t\t\t\t\t\t\t\t/images/ic-instagram-light/ic-instagram-light@3x.png 3x");
    			attr_dev(img2, "class", "ic-instagram-light");
    			add_location(img2, file$B, 51, 8, 1650);
    			attr_dev(a1, "href", "https://www.instagram.com/snapdragonconquest/");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$B, 50, 7, 1569);
    			attr_dev(li1, "class", "svelte-1jlzhno");
    			add_location(li1, file$B, 49, 6, 1557);
    			attr_dev(img3, "alt", "Twitter");
    			if (!src_url_equal(img3.src, img3_src_value = "/images/ic-twitter-light/ic-twitter-light.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "srcset", "/images/ic-twitter-light/ic-twitter-light@2x.png 2x,\n\t\t\t\t\t\t\t\t\t\t\t/images/ic-twitter-light/ic-twitter-light@3x.png 3x");
    			attr_dev(img3, "class", "ic-twitter-light");
    			add_location(img3, file$B, 59, 8, 2027);
    			attr_dev(a2, "href", "https://mobile.twitter.com/_ConquestEsport");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$B, 58, 7, 1949);
    			attr_dev(li2, "class", "svelte-1jlzhno");
    			add_location(li2, file$B, 57, 6, 1937);
    			attr_dev(img4, "alt", "Youtube");
    			if (!src_url_equal(img4.src, img4_src_value = "/images/ic-youtube-light/ic-youtube-light.png")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "srcset", "/images/ic-youtube-light/ic-youtube-light@2x.png 2x,\n\t\t\t\t\t\t\t\t\t\t\t/images/ic-youtube-light/ic-youtube-light@3x.png 3x");
    			attr_dev(img4, "class", "ic-youtube-light");
    			add_location(img4, file$B, 67, 8, 2398);
    			attr_dev(a3, "href", "https://youtube.com/channel/UCqfsjVyKK2_ajIgG_HqR36w");
    			attr_dev(a3, "target", "_blank");
    			add_location(a3, file$B, 66, 7, 2310);
    			attr_dev(li3, "class", "svelte-1jlzhno");
    			add_location(li3, file$B, 65, 6, 2298);
    			attr_dev(ul, "class", "d-flex justify-content-center align-items-center");
    			add_location(ul, file$B, 40, 5, 1119);
    			attr_dev(div8, "class", "social-links-light d-flex justify-content-center align-items-center svelte-1jlzhno");
    			add_location(div8, file$B, 39, 4, 1032);
    			attr_dev(div9, "class", "free-fire-block");
    			add_location(div9, file$B, 12, 3, 398);
    			attr_dev(div10, "class", "game-pic game-pic-right d-none d-sm-block");
    			add_location(div10, file$B, 76, 3, 2698);
    			if (!src_url_equal(img5.src, img5_src_value = "/images/char-left/char-left.png")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "srcset", "/images/char-left/char-left@2x.png 2x,\n\t\t\t\t\t\t\t/images/char-left/char-left@3x.png 3x");
    			attr_dev(img5, "class", "char_left svelte-1jlzhno");
    			attr_dev(img5, "alt", "Game Characters");
    			add_location(img5, file$B, 78, 4, 2815);
    			if (!src_url_equal(img6.src, img6_src_value = "/images/char-right/char-right.png")) attr_dev(img6, "src", img6_src_value);
    			attr_dev(img6, "srcset", "/images/char-right/char-right@2x.png 2x,\n\t\t\t\t\t\t\t/images/char-right/char-right@3x.png 3x");
    			attr_dev(img6, "class", "char_right svelte-1jlzhno");
    			attr_dev(img6, "alt", "Game Characters");
    			add_location(img6, file$B, 82, 4, 3006);
    			attr_dev(div11, "class", "game-pic-mobile d-block d-sm-none svelte-1jlzhno");
    			add_location(div11, file$B, 77, 3, 2763);
    			if (!src_url_equal(img7.src, img7_src_value = "images/ff-logo-black-damaged.png")) attr_dev(img7, "src", img7_src_value);
    			attr_dev(img7, "alt", "FreeFire-Logo");
    			add_location(img7, file$B, 88, 4, 3246);
    			attr_dev(div12, "class", "free-fire-logo");
    			add_location(div12, file$B, 87, 3, 3213);
    			attr_dev(div13, "class", "content-wrapper");
    			add_location(div13, file$B, 8, 2, 268);
    			attr_dev(div14, "class", "container");
    			add_location(div14, file$B, 6, 1, 193);
    			attr_dev(section, "class", "main-section home-page-static");
    			add_location(section, file$B, 5, 0, 144);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div14);
    			append_dev(div14, div0);
    			append_dev(div14, t0);
    			append_dev(div14, div13);
    			append_dev(div13, div1);
    			append_dev(div1, img0);
    			append_dev(div13, t1);
    			append_dev(div13, div9);
    			append_dev(div9, h60);
    			append_dev(div9, t3);
    			append_dev(div9, div2);
    			append_dev(div2, small0);
    			append_dev(div9, t4);
    			append_dev(div9, div7);
    			append_dev(div7, div3);
    			append_dev(div7, t6);
    			append_dev(div7, div4);
    			append_dev(div7, t8);
    			append_dev(div7, div5);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			append_dev(div6, small1);
    			append_dev(div9, t11);
    			append_dev(div9, h61);
    			append_dev(h61, t12);
    			append_dev(h61, span);
    			append_dev(div9, t14);
    			append_dev(div9, small2);
    			append_dev(div9, t16);
    			append_dev(div9, div8);
    			append_dev(div8, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, img1);
    			append_dev(ul, t17);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, img2);
    			append_dev(ul, t18);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, img3);
    			append_dev(ul, t19);
    			append_dev(ul, li3);
    			append_dev(li3, a3);
    			append_dev(a3, img4);
    			append_dev(div13, t20);
    			append_dev(div13, div10);
    			append_dev(div13, t21);
    			append_dev(div13, div11);
    			append_dev(div11, img5);
    			append_dev(div11, t22);
    			append_dev(div11, img6);
    			append_dev(div13, t23);
    			append_dev(div13, div12);
    			append_dev(div12, img7);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HomePage2', slots, []);
    	const user = User.getUser();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HomePage2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Format, User, user });
    	return [];
    }

    class HomePage2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HomePage2",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/pages/Leaderboard.svelte generated by Svelte v3.41.0 */
    const file$A = "src/pages/Leaderboard.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (162:1) {:else}
    function create_else_block$b(ctx) {
    	let h3;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Leaderboard not yet available";
    			add_location(h3, file$A, 162, 2, 4811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(162:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (135:1) {#if scores.length > 0}
    function create_if_block$l(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let tbody;
    	let each_value = /*scores*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Rank";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Team Name";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "No. of matches played";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Kills";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Kill Points";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Position Points";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "Overall Points";
    			t13 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "scope", "col");
    			attr_dev(th0, "class", "svelte-6nkzk6");
    			add_location(th0, file$A, 138, 4, 4131);
    			attr_dev(th1, "scope", "col");
    			attr_dev(th1, "class", "svelte-6nkzk6");
    			add_location(th1, file$A, 139, 4, 4162);
    			attr_dev(th2, "scope", "col");
    			attr_dev(th2, "class", "svelte-6nkzk6");
    			add_location(th2, file$A, 140, 4, 4198);
    			attr_dev(th3, "scope", "col");
    			attr_dev(th3, "class", "svelte-6nkzk6");
    			add_location(th3, file$A, 141, 4, 4246);
    			attr_dev(th4, "scope", "col");
    			attr_dev(th4, "class", "svelte-6nkzk6");
    			add_location(th4, file$A, 142, 4, 4278);
    			attr_dev(th5, "scope", "col");
    			attr_dev(th5, "class", "svelte-6nkzk6");
    			add_location(th5, file$A, 143, 4, 4316);
    			attr_dev(th6, "scope", "col");
    			attr_dev(th6, "class", "svelte-6nkzk6");
    			add_location(th6, file$A, 144, 4, 4358);
    			add_location(tr, file$A, 137, 3, 4121);
    			add_location(thead, file$A, 136, 2, 4109);
    			add_location(tbody, file$A, 147, 2, 4419);
    			attr_dev(table, "class", "table svelte-6nkzk6");
    			add_location(table, file$A, 135, 1, 4084);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(table, t13);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*scores*/ 1) {
    				each_value = /*scores*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(135:1) {#if scores.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (149:3) {#each scores as score}
    function create_each_block$a(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*score*/ ctx[3]['Rank'] + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*score*/ ctx[3]['Team Name'] + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*score*/ ctx[3]['No. of matches played'] + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*score*/ ctx[3]['Kills'] + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*score*/ ctx[3]['Kill Points'] + "";
    	let t8;
    	let t9;
    	let td5;
    	let t10_value = /*score*/ ctx[3]['Position Points'] + "";
    	let t10;
    	let t11;
    	let td6;
    	let t12_value = /*score*/ ctx[3]['Overall Points'] + "";
    	let t12;
    	let t13;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td6 = element("td");
    			t12 = text$1(t12_value);
    			t13 = space();
    			attr_dev(td0, "class", "svelte-6nkzk6");
    			add_location(td0, file$A, 150, 5, 4471);
    			attr_dev(td1, "class", "svelte-6nkzk6");
    			add_location(td1, file$A, 151, 5, 4502);
    			attr_dev(td2, "class", "svelte-6nkzk6");
    			add_location(td2, file$A, 152, 5, 4538);
    			attr_dev(td3, "class", "svelte-6nkzk6");
    			add_location(td3, file$A, 153, 5, 4586);
    			attr_dev(td4, "class", "svelte-6nkzk6");
    			add_location(td4, file$A, 154, 5, 4618);
    			attr_dev(td5, "class", "svelte-6nkzk6");
    			add_location(td5, file$A, 155, 5, 4656);
    			attr_dev(td6, "class", "cell-value svelte-6nkzk6");
    			add_location(td6, file$A, 156, 5, 4698);
    			add_location(tr, file$A, 149, 4, 4460);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td6);
    			append_dev(td6, t12);
    			append_dev(tr, t13);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*scores*/ 1 && t0_value !== (t0_value = /*score*/ ctx[3]['Rank'] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*scores*/ 1 && t2_value !== (t2_value = /*score*/ ctx[3]['Team Name'] + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*scores*/ 1 && t4_value !== (t4_value = /*score*/ ctx[3]['No. of matches played'] + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*scores*/ 1 && t6_value !== (t6_value = /*score*/ ctx[3]['Kills'] + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*scores*/ 1 && t8_value !== (t8_value = /*score*/ ctx[3]['Kill Points'] + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*scores*/ 1 && t10_value !== (t10_value = /*score*/ ctx[3]['Position Points'] + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*scores*/ 1 && t12_value !== (t12_value = /*score*/ ctx[3]['Overall Points'] + "")) set_data_dev(t12, t12_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(149:3) {#each scores as score}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div0;
    	let h1;
    	let t1;
    	let video;
    	let t2;
    	let div1;
    	let h4;
    	let t3_value = /*leaderboard*/ ctx[1].title + "";
    	let t3;
    	let t4;
    	let div2;
    	let current;

    	video = new Video({
    			props: {
    				url: "https://www.youtube.com/watch?v=-gyBzQnsGT0",
    				thumb: "/images/day10_conquest_trailer_thumb_trailer.jpg"
    			},
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*scores*/ ctx[0].length > 0) return create_if_block$l;
    		return create_else_block$b;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Leaderboard";
    			t1 = space();
    			create_component(video.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			t3 = text$1(t3_value);
    			t4 = space();
    			div2 = element("div");
    			if_block.c();
    			attr_dev(h1, "class", "title svelte-6nkzk6");
    			add_location(h1, file$A, 127, 1, 3790);
    			attr_dev(div0, "class", "top-section svelte-6nkzk6");
    			add_location(div0, file$A, 126, 0, 3762);
    			attr_dev(h4, "class", "table-title svelte-6nkzk6");
    			add_location(h4, file$A, 131, 1, 3960);
    			add_location(div1, file$A, 130, 0, 3952);
    			attr_dev(div2, "class", "table-section container svelte-6nkzk6");
    			add_location(div2, file$A, 133, 0, 4018);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h1);
    			append_dev(div0, t1);
    			mount_component(video, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h4);
    			append_dev(h4, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div2, anchor);
    			if_block.m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*leaderboard*/ 2) && t3_value !== (t3_value = /*leaderboard*/ ctx[1].title + "")) set_data_dev(t3, t3_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(video);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div2);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Leaderboard', slots, []);
    	let scores = [];

    	let leaderboard = {
    		"data": [
    			{
    				"id": 1,
    				"status": "published",
    				"owner": 1,
    				"created_on": "2021-01-27T20:13:38+00:00",
    				"modified_by": 2,
    				"modified_on": "2021-03-15T10:36:08+00:00",
    				"scores": [
    					{
    						"Rank": 1,
    						"Team Name": "4 Unknown",
    						"No. of matches played": 12,
    						"Kills": 70,
    						"Kill Points": 140,
    						"Position Points": 167,
    						"Overall Points": 307
    					},
    					{
    						"Rank": 2,
    						"Team Name": "Team Elite",
    						"No. of matches played": 12,
    						"Kills": 55,
    						"Kill Points": 110,
    						"Position Points": 151,
    						"Overall Points": 261
    					},
    					{
    						"Rank": 3,
    						"Team Name": "LIFE HACKERS",
    						"No. of matches played": 12,
    						"Kills": 50,
    						"Kill Points": 100,
    						"Position Points": 129,
    						"Overall Points": 229
    					},
    					{
    						"Rank": 4,
    						"Team Name": "Team Chaos",
    						"No. of matches played": 12,
    						"Kills": 52,
    						"Kill Points": 104,
    						"Position Points": 125,
    						"Overall Points": 229
    					},
    					{
    						"Rank": 5,
    						"Team Name": "Hex Esports",
    						"No. of matches played": 12,
    						"Kills": 33,
    						"Kill Points": 66,
    						"Position Points": 122,
    						"Overall Points": 188
    					},
    					{
    						"Rank": 6,
    						"Team Name": "TEAM MAYHEM",
    						"No. of matches played": 12,
    						"Kills": 35,
    						"Kill Points": 70,
    						"Position Points": 117,
    						"Overall Points": 187
    					},
    					{
    						"Rank": 7,
    						"Team Name": "Galaxy Racer",
    						"No. of matches played": 12,
    						"Kills": 42,
    						"Kill Points": 84,
    						"Position Points": 98,
    						"Overall Points": 182
    					},
    					{
    						"Rank": 8,
    						"Team Name": "Sixth Sense",
    						"No. of matches played": 12,
    						"Kills": 39,
    						"Kill Points": 78,
    						"Position Points": 82,
    						"Overall Points": 160
    					},
    					{
    						"Rank": 9,
    						"Team Name": "Total Gaming Esports",
    						"No. of matches played": 12,
    						"Kills": 31,
    						"Kill Points": 62,
    						"Position Points": 96,
    						"Overall Points": 158
    					},
    					{
    						"Rank": 10,
    						"Team Name": "survivior-4am",
    						"No. of matches played": 12,
    						"Kills": 27,
    						"Kill Points": 54,
    						"Position Points": 87,
    						"Overall Points": 141
    					},
    					{
    						"Rank": 11,
    						"Team Name": "Blood bashers",
    						"No. of matches played": 12,
    						"Kills": 23,
    						"Kill Points": 46,
    						"Position Points": 87,
    						"Overall Points": 133
    					},
    					{
    						"Rank": 12,
    						"Team Name": "Raven esports",
    						"No. of matches played": 12,
    						"Kills": 26,
    						"Kill Points": 52,
    						"Position Points": 71,
    						"Overall Points": 123
    					}
    				],
    				"xlsx": 104,
    				"title": "Grand Finals, End of Day 2"
    			}
    		],
    		"public": true
    	};

    	// fetch('https://qsdc.tesseractesports.com/conquest/items/leaderboard').then(async res => {
    	let data = leaderboard;

    	data = data.data[0];
    	leaderboard = data;

    	if (data.status == 'published') {
    		scores = data.scores.sort((a, b) => a.Rank < b.Rank);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Leaderboard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Video, scores, leaderboard, data });

    	$$self.$inject_state = $$props => {
    		if ('scores' in $$props) $$invalidate(0, scores = $$props.scores);
    		if ('leaderboard' in $$props) $$invalidate(1, leaderboard = $$props.leaderboard);
    		if ('data' in $$props) data = $$props.data;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [scores, leaderboard];
    }

    class Leaderboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Leaderboard",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || from);
    }

    var n,
        l,
        u,
        t,
        o,
        r$1,
        f$1,
        e$1 = {},
        c$1 = [],
        s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function a$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function h(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function v$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return y(l, f, t, o, null);
    }

    function y(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u : r
      };
      return null != l.vnode && l.vnode(f), f;
    }

    function p() {
      return {
        current: null
      };
    }

    function d(n) {
      return n.children;
    }

    function _(n, l) {
      this.props = n, this.context = l;
    }

    function k(n, l) {
      if (null == l) return n.__ ? k(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? k(n) : null;
    }

    function b$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return b$1(n);
      }
    }

    function m(n) {
      (!n.__d && (n.__d = !0) && t.push(n) && !g$1.__r++ || r$1 !== l.debounceRendering) && ((r$1 = l.debounceRendering) || o)(g$1);
    }

    function g$1() {
      for (var n; g$1.__r = t.length;) n = t.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = a$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? k(t) : o, t.__h), z(u, t), t.__e != o && b$1(t)));
      });
    }

    function w$1(n, l, u, i, t, o, r, f, s, a) {
      var h,
          v,
          p,
          _,
          b,
          m,
          g,
          w = i && i.__k || c$1,
          A = w.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y(null, _, null, null, _) : Array.isArray(_) ? y(d, {
        children: _
      }, null, null, null) : _.__b > 0 ? y(_.type, _.props, _.key, null, _.__v) : _)) {
        if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
          if ((p = w[v]) && _.key == p.key && _.type === p.type) {
            w[v] = void 0;
            break;
          }

          p = null;
        }
        j$2(n, _, p = p || e$1, t, o, r, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), "function" == typeof _.type && null != _.__k && _.__k === p.__k ? _.__d = s = x$1(_, s, n) : s = P$1(n, _, p, w, b, s), a || "option" !== u.type ? "function" == typeof u.type && (u.__d = s) : n.value = "") : s && p.__e == s && s.parentNode != n && (s = k(p));
      }

      for (u.__e = m, h = A; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k(i, h + 1)), N(w[h], w[h]));

      if (g) for (h = 0; h < g.length; h++) M$1(g[h], g[++h], g[++h]);
    }

    function x$1(n, l, u) {
      var i, t;

      for (i = 0; i < n.__k.length; i++) (t = n.__k[i]) && (t.__ = n, l = "function" == typeof t.type ? x$1(t, l, u) : P$1(u, t, t, n.__k, t.__e, l));

      return l;
    }

    function A$1(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        A$1(n, l);
      }) : l.push(n)), l;
    }

    function P$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$1(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$2(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$2(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$2(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$1 : I$1, o) : n.removeEventListener(l, o ? T$1 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l.event ? l.event(n) : n);
    }

    function T$1(n) {
      this.l[n.type + !0](l.event ? l.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var s,
          h,
          v,
          y,
          p,
          k,
          b,
          m,
          g,
          x,
          A,
          P = u.type;
      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (s = l.__b) && s(u);

      try {
        n: if ("function" == typeof P) {
          if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _(m, x), h.constructor = P, h.render = O$1), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$1({}, h.__s)), a$1(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
              h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, p, k);
            });
          }
          h.context = x, h.props = m, h.state = h.__s, (s = l.__r) && s(u), h.__d = !1, h.__v = u, h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a$1(a$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), A = null != s && s.type === d && null == s.key ? s.props.children : s, w$1(n, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (s = l.diffed) && s(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l.__e(n, u, i);
      }
    }

    function z(n, u) {
      l.__c && l.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, f, c) {
      var s,
          a,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          _ = 0;
      if ("svg" === d && (o = !0), null != r) for (; _ < r.length; _++) if ((s = r[_]) && (s === l || (d ? s.localName == d : 3 == s.nodeType))) {
        l = s, r[_] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
          (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$1(l, p, y, o, c), v) u.__k = [];else if (_ = u.props.children, w$1(l, Array.isArray(_) ? _ : [_], u, i, t, o && "foreignObject" !== d, r, f, r ? r[0] : i.__k && k(i, 0), c), null != r) for (_ = r.length; _--;) null != r[_] && h(r[_]);
        c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_) && H$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H$1(l, "checked", _, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l.unmount && l.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l.__e(n, u);
        }
        t.base = t.__P = null;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
      i || null == n.__e || h(n.__e), n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function S$1(u, i, t) {
      var o, r, f;
      l.__ && l.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], j$2(i, u = (!o && t || i).__k = v$1(d, null, [u]), r || e$1, e$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, f, !o && t ? t : r ? r.__e : i.firstChild, o), z(f, u);
    }

    function D$1(n, l) {
      var u = {
        __c: l = "__cC" + f$1++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(m);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = c$1.slice, l = {
      __e: function (n, l) {
        for (var u, i, t; l = l.__;) if ((u = l.__c) && !u.__) try {
          if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u = 0, _.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(a$1({}, u), this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), m(this));
    }, _.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), m(this));
    }, _.prototype.render = d, t = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$1.__r = 0, f$1 = 0;

    var r,
        i = [],
        c = l.__b,
        f = l.__r,
        e = l.diffed,
        a = l.__c,
        v = l.unmount;

    function x() {
      i.forEach(function (t) {
        if (t.__P) try {
          t.__H.__h.forEach(g), t.__H.__h.forEach(j$1), t.__H.__h = [];
        } catch (u) {
          t.__H.__h = [], l.__e(u, t.__v);
        }
      }), i = [];
    }

    l.__b = function (n) {
      c && c(n);
    }, l.__r = function (n) {
      f && f(n);
      var r = (n.__c).__H;
      r && (r.__h.forEach(g), r.__h.forEach(j$1), r.__h = []);
    }, l.diffed = function (t) {
      e && e(t);
      var o = t.__c;
      o && o.__H && o.__H.__h.length && (1 !== i.push(o) && r === l.requestAnimationFrame || ((r = l.requestAnimationFrame) || function (n) {
        var t,
            u = function () {
          clearTimeout(r), b && cancelAnimationFrame(t), setTimeout(n);
        },
            r = setTimeout(u, 100);

        b && (t = requestAnimationFrame(u));
      })(x));
    }, l.__c = function (t, u) {
      u.some(function (t) {
        try {
          t.__h.forEach(g), t.__h = t.__h.filter(function (n) {
            return !n.__ || j$1(n);
          });
        } catch (r) {
          u.some(function (n) {
            n.__h && (n.__h = []);
          }), u = [], l.__e(r, t.__v);
        }
      }), a && a(t, u);
    }, l.unmount = function (t) {
      v && v(t);
      var u = t.__c;
      if (u && u.__H) try {
        u.__H.__.forEach(g);
      } catch (t) {
        l.__e(t, u.__v);
      }
    };
    var b = "function" == typeof requestAnimationFrame;

    function g(n) {
      "function" == typeof n.__c && n.__c();
    }

    function j$1(n) {
      n.__c = n.__();
    }

    function S(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function C(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    (E.prototype = new _()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var w = l.__b;

    l.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
    };

    var A = l.__e;

    l.__e = function (n, t, e) {
      if (n.then) for (var r, u = t; u = u.__;) if ((r = u.__c) && r.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), r.__c(n, t);
      A(n, t, e);
    };

    var O = l.unmount;

    function L() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function U(n) {
      var t = n.__.__c;
      return t && t.__e && t.__e(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
    }, (L.prototype = new _()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = U(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__e) {
            var n = r.state.__e;

            r.__v.__k[0] = function n(t, e, r) {
              return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
                return n(t, e, r);
              }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
            }(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __e: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          f = !0 === t.__h;

      r.__u++ || f || r.setState({
        __e: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, L.prototype.componentWillUnmount = function () {
      this.t = [];
    }, L.prototype.render = function (n, t) {
      if (this.__b) {
        if (this.__v.__k) {
          var e = document.createElement("div"),
              r = this.__v.__k[0].__c;

          this.__v.__k[0] = function n(t, e, r) {
            return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
              "function" == typeof n.__c && n.__c();
            }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            })), t;
          }(this.__b, e, r.__O = r.__P);
        }

        this.__b = null;
      }

      var u = t.__e && v$1(d, null, n.fallback);
      return u && (u.__h = null), [v$1(d, null, t.__e ? null : n.children), u];
    };

    var T = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function D(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function I(n) {
      var t = this,
          e = n.i;
      t.componentWillUnmount = function () {
        S$1(null, t.l), t.l = null, t.i = null;
      }, t.i && t.i !== e && t.componentWillUnmount(), n.__v ? (t.l || (t.i = e, t.l = {
        nodeType: 1,
        parentNode: e,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        insertBefore: function (n, e) {
          this.childNodes.push(n), t.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
        }
      }), S$1(v$1(D, {
        context: t.context
      }, n.__v), t.l)) : t.l && t.componentWillUnmount();
    }

    function W(n, t) {
      return v$1(I, {
        __v: n,
        i: t
      });
    }

    (M.prototype = new _()).__e = function (n) {
      var t = this,
          e = U(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = A$1(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        T(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        V = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    _.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
      Object.defineProperty(_.prototype, n, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    });
    var H = l.event;

    function Z() {}

    function Y() {
      return this.cancelBubble;
    }

    function $$1() {
      return this.defaultPrevented;
    }

    l.event = function (n) {
      return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = $$1, n.nativeEvent = n;
    };

    var G = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        J = l.vnode;

    l.vnode = function (n) {
      var t = n.type,
          e = n.props,
          r = e;

      if ("string" == typeof t) {
        for (var u in r = {}, e) {
          var o = e[u];
          "value" === u && "defaultValue" in e && null == o || ("defaultValue" === u && "value" in e && null == e.value ? u = "value" : "download" === u && !0 === o ? o = "" : /ondoubleclick/i.test(u) ? u = "ondblclick" : /^onchange(textarea|input)/i.test(u + t) && !V(e.type) ? u = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(u) ? u = u.toLowerCase() : P.test(u) ? u = u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === o && (o = void 0), r[u] = o);
        }

        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = A$1(e.children).forEach(function (n) {
          n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = A$1(e.children).forEach(function (n) {
          n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n.props = r;
      }

      t && e.class != e.className && (G.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", G)), n.$$typeof = j, J && J(n);
    };

    var K = l.__r;

    l.__r = function (n) {
      K && K(n);
    };

    var globalObj = typeof globalThis !== 'undefined' ? globalThis : window; // // TODO: streamline when killing IE11 support

    if (globalObj.FullCalendarVDom) {
      console.warn('FullCalendar VDOM already loaded');
    } else {
      globalObj.FullCalendarVDom = {
        Component: _,
        createElement: v$1,
        render: S$1,
        createRef: p,
        Fragment: d,
        createContext: createContext$1,
        createPortal: W,
        flushToDom: flushToDom$1,
        unmountComponentAtNode: unmountComponentAtNode$1
      };
    } // HACKS...
    // TODO: lock version
    // TODO: link gh issues


    function flushToDom$1() {
      var oldDebounceRendering = l.debounceRendering; // orig

      var callbackQ = [];

      function execCallbackSync(callback) {
        callbackQ.push(callback);
      }

      l.debounceRendering = execCallbackSync;
      S$1(v$1(FakeComponent, {}), document.createElement('div'));

      while (callbackQ.length) {
        callbackQ.shift()();
      }

      l.debounceRendering = oldDebounceRendering;
    }

    var FakeComponent = function (_super) {
      __extends(FakeComponent, _super);

      function FakeComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      FakeComponent.prototype.render = function () {
        return v$1('div', {});
      };

      FakeComponent.prototype.componentDidMount = function () {
        this.setState({});
      };

      return FakeComponent;
    }(_);

    function createContext$1(defaultValue) {
      var ContextType = D$1(defaultValue);
      var origProvider = ContextType.Provider;

      ContextType.Provider = function () {
        var _this = this;

        var isNew = !this.getChildContext;
        var children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params

        if (isNew) {
          var subs_1 = [];

          this.shouldComponentUpdate = function (_props) {
            if (_this.props.value !== _props.value) {
              subs_1.forEach(function (c) {
                c.context = _props.value;
                c.forceUpdate();
              });
            }
          };

          this.sub = function (c) {
            subs_1.push(c);
            var old = c.componentWillUnmount;

            c.componentWillUnmount = function () {
              subs_1.splice(subs_1.indexOf(c), 1);
              old && old.call(c);
            };
          };
        }

        return children;
      };

      return ContextType;
    }

    function unmountComponentAtNode$1(node) {
      S$1(null, node);
    }

    var css_248z$2 = "";
    styleInject(css_248z$2);

    /// <reference types="@fullcalendar/core-preact" />
    if (typeof FullCalendarVDom === 'undefined') {
      throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');
    }

    var Component = FullCalendarVDom.Component;
    var createElement = FullCalendarVDom.createElement;
    var render = FullCalendarVDom.render;
    var createRef = FullCalendarVDom.createRef;
    var Fragment = FullCalendarVDom.Fragment;
    var createContext = FullCalendarVDom.createContext;
    var createPortal = FullCalendarVDom.createPortal;
    var flushToDom = FullCalendarVDom.flushToDom;
    var unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;

    /*!
    FullCalendar v5.9.0
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */
    // import {} from './api-type-deps'

    var EventSourceApi = function () {
      function EventSourceApi(context, internalEventSource) {
        this.context = context;
        this.internalEventSource = internalEventSource;
      }

      EventSourceApi.prototype.remove = function () {
        this.context.dispatch({
          type: 'REMOVE_EVENT_SOURCE',
          sourceId: this.internalEventSource.sourceId
        });
      };

      EventSourceApi.prototype.refetch = function () {
        this.context.dispatch({
          type: 'FETCH_EVENT_SOURCES',
          sourceIds: [this.internalEventSource.sourceId],
          isRefetch: true
        });
      };

      Object.defineProperty(EventSourceApi.prototype, "id", {
        get: function () {
          return this.internalEventSource.publicId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventSourceApi.prototype, "url", {
        get: function () {
          return this.internalEventSource.meta.url;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventSourceApi.prototype, "format", {
        get: function () {
          return this.internalEventSource.meta.format; // TODO: bad. not guaranteed
        },
        enumerable: false,
        configurable: true
      });
      return EventSourceApi;
    }();

    function removeElement(el) {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } // Querying
    // ----------------------------------------------------------------------------------------------------------------


    function elementClosest(el, selector) {
      if (el.closest) {
        return el.closest(selector); // really bad fallback for IE
        // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
      }

      if (!document.documentElement.contains(el)) {
        return null;
      }

      do {
        if (elementMatches(el, selector)) {
          return el;
        }

        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === 1);

      return null;
    }

    function elementMatches(el, selector) {
      var method = el.matches || el.matchesSelector || el.msMatchesSelector;
      return method.call(el, selector);
    } // accepts multiple subject els
    // returns a real array. good for methods like forEach
    // TODO: accept the document


    function findElements(container, selector) {
      var containers = container instanceof HTMLElement ? [container] : container;
      var allMatches = [];

      for (var i = 0; i < containers.length; i += 1) {
        var matches = containers[i].querySelectorAll(selector);

        for (var j = 0; j < matches.length; j += 1) {
          allMatches.push(matches[j]);
        }
      }

      return allMatches;
    } // accepts multiple subject els
    // ----------------------------------------------------------------------------------------------------------------


    var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;

    function applyStyle(el, props) {
      for (var propName in props) {
        applyStyleProp(el, propName, props[propName]);
      }
    }

    function applyStyleProp(el, name, val) {
      if (val == null) {
        el.style[name] = '';
      } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
        el.style[name] = val + "px";
      } else {
        el.style[name] = val;
      }
    } // Event Handling
    // ----------------------------------------------------------------------------------------------------------------
    // if intercepting bubbled events at the document/window/body level,
    // and want to see originating element (the 'target'), use this util instead
    // of `ev.target` because it goes within web-component boundaries.


    function getEventTargetViaRoot(ev) {
      var _a, _b;

      return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
    } // Shadow DOM consuderations
    // ----------------------------------------------------------------------------------------------------------------


    function buildDelegationHandler(selector, handler) {
      return function (ev) {
        var matchedChild = elementClosest(ev.target, selector);

        if (matchedChild) {
          handler.call(matchedChild, ev, matchedChild);
        }
      };
    }

    function listenBySelector(container, eventType, selector, handler) {
      var attachedHandler = buildDelegationHandler(selector, handler);
      container.addEventListener(eventType, attachedHandler);
      return function () {
        container.removeEventListener(eventType, attachedHandler);
      };
    }

    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
      var currentMatchedChild;
      return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {
        if (matchedChild !== currentMatchedChild) {
          currentMatchedChild = matchedChild;
          onMouseEnter(mouseOverEv, matchedChild);

          var realOnMouseLeave_1 = function (mouseLeaveEv) {
            currentMatchedChild = null;
            onMouseLeave(mouseLeaveEv, matchedChild);
            matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
          }; // listen to the next mouseleave, and then unattach


          matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
        }
      });
    } // Animation

    var guidNumber = 0;

    function guid() {
      guidNumber += 1;
      return String(guidNumber);
    }

    function parseFieldSpecs(input) {
      var specs = [];
      var tokens = [];
      var i;
      var token;

      if (typeof input === 'string') {
        tokens = input.split(/\s*,\s*/);
      } else if (typeof input === 'function') {
        tokens = [input];
      } else if (Array.isArray(input)) {
        tokens = input;
      }

      for (i = 0; i < tokens.length; i += 1) {
        token = tokens[i];

        if (typeof token === 'string') {
          specs.push(token.charAt(0) === '-' ? {
            field: token.substring(1),
            order: -1
          } : {
            field: token,
            order: 1
          });
        } else if (typeof token === 'function') {
          specs.push({
            func: token
          });
        }
      }

      return specs;
    }

    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
      var i;
      var cmp;

      for (i = 0; i < fieldSpecs.length; i += 1) {
        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);

        if (cmp) {
          return cmp;
        }
      }

      return 0;
    }

    function compareByFieldSpec(obj0, obj1, fieldSpec) {
      if (fieldSpec.func) {
        return fieldSpec.func(obj0, obj1);
      }

      return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
    }

    function flexibleCompare(a, b) {
      if (!a && !b) {
        return 0;
      }

      if (b == null) {
        return -1;
      }

      if (a == null) {
        return 1;
      }

      if (typeof a === 'string' || typeof b === 'string') {
        return String(a).localeCompare(String(b));
      }

      return a - b;
    }
    /* String Utilities
    ----------------------------------------------------------------------------------------------------------------------*/


    function padStart(val, len) {
      var s = String(val);
      return '000'.substr(0, len - s.length) + s;
    }

    function isInt(n) {
      return n % 1 === 0;
    }
    /* FC-specific DOM dimension stuff
    ----------------------------------------------------------------------------------------------------------------------*/


    function computeSmallestCellWidth(cellEl) {
      var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');
      var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');

      if (!allWidthEl) {
        throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const
      }

      if (!contentWidthEl) {
        throw new Error('needs fc-scrollgrid-shrink-cushion className');
      }

      return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
      contentWidthEl.getBoundingClientRect().width;
    }

    var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding

    function addWeeks(m, n) {
      var a = dateToUtcArray(m);
      a[2] += n * 7;
      return arrayToUtcDate(a);
    }

    function addDays(m, n) {
      var a = dateToUtcArray(m);
      a[2] += n;
      return arrayToUtcDate(a);
    }

    function addMs(m, n) {
      var a = dateToUtcArray(m);
      a[6] += n;
      return arrayToUtcDate(a);
    } // Diffing (all return floats)
    // TODO: why not use ranges?


    function diffWeeks(m0, m1) {
      return diffDays(m0, m1) / 7;
    }

    function diffDays(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
    }

    function diffHours(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
    }

    function diffMinutes(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
    }

    function diffSeconds(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / 1000;
    }

    function diffDayAndTime(m0, m1) {
      var m0day = startOfDay(m0);
      var m1day = startOfDay(m1);
      return {
        years: 0,
        months: 0,
        days: Math.round(diffDays(m0day, m1day)),
        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
      };
    } // Diffing Whole Units


    function diffWholeWeeks(m0, m1) {
      var d = diffWholeDays(m0, m1);

      if (d !== null && d % 7 === 0) {
        return d / 7;
      }

      return null;
    }

    function diffWholeDays(m0, m1) {
      if (timeAsMs(m0) === timeAsMs(m1)) {
        return Math.round(diffDays(m0, m1));
      }

      return null;
    } // Start-Of


    function startOfDay(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);
    }

    function startOfHour(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);
    }

    function startOfMinute(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);
    }

    function startOfSecond(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);
    } // Week Computation


    function weekOfYear(marker, dow, doy) {
      var y = marker.getUTCFullYear();
      var w = weekOfGivenYear(marker, y, dow, doy);

      if (w < 1) {
        return weekOfGivenYear(marker, y - 1, dow, doy);
      }

      var nextW = weekOfGivenYear(marker, y + 1, dow, doy);

      if (nextW >= 1) {
        return Math.min(w, nextW);
      }

      return w;
    }

    function weekOfGivenYear(marker, year, dow, doy) {
      var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
      var dayStart = startOfDay(marker);
      var days = Math.round(diffDays(firstWeekStart, dayStart));
      return Math.floor(days / 7) + 1; // zero-indexed
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd

      var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // Array Conversion


    function dateToLocalArray(date) {
      return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
    }

    function arrayToLocalDate(a) {
      return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
      a[3] || 0, a[4] || 0, a[5] || 0);
    }

    function dateToUtcArray(date) {
      return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
    }

    function arrayToUtcDate(a) {
      // according to web standards (and Safari), a month index is required.
      // massage if only given a year.
      if (a.length === 1) {
        a = a.concat([0]);
      }

      return new Date(Date.UTC.apply(Date, a));
    } // Other Utils


    function isValidDate(m) {
      return !isNaN(m.valueOf());
    }

    function timeAsMs(m) {
      return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();
    }

    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
      return {
        instanceId: guid(),
        defId: defId,
        range: range,
        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
      };
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.
    // The second argument allows for an array of property names who's object values will be merged together.

    function mergeProps(propObjs, complexPropsMap) {
      var dest = {};

      if (complexPropsMap) {
        for (var name_1 in complexPropsMap) {
          var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered

          for (var i = propObjs.length - 1; i >= 0; i -= 1) {
            var val = propObjs[i][name_1];

            if (typeof val === 'object' && val) {
              // non-null object
              complexObjs.unshift(val);
            } else if (val !== undefined) {
              dest[name_1] = val; // if there were no objects, this value will be used

              break;
            }
          } // if the trailing values were objects, use the merged value


          if (complexObjs.length) {
            dest[name_1] = mergeProps(complexObjs);
          }
        }
      } // copy values into the destination, going from last to first


      for (var i = propObjs.length - 1; i >= 0; i -= 1) {
        var props = propObjs[i];

        for (var name_2 in props) {
          if (!(name_2 in dest)) {
            // if already assigned by previous props or complex props, don't reassign
            dest[name_2] = props[name_2];
          }
        }
      }

      return dest;
    }

    function filterHash(hash, func) {
      var filtered = {};

      for (var key in hash) {
        if (func(hash[key], key)) {
          filtered[key] = hash[key];
        }
      }

      return filtered;
    }

    function mapHash(hash, func) {
      var newHash = {};

      for (var key in hash) {
        newHash[key] = func(hash[key], key);
      }

      return newHash;
    }

    function arrayToHash(a) {
      var hash = {};

      for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var item = a_1[_i];
        hash[item] = true;
      }

      return hash;
    }

    function hashValuesToArray(obj) {
      var a = [];

      for (var key in obj) {
        a.push(obj[key]);
      }

      return a;
    }

    function isPropsEqual(obj0, obj1) {
      if (obj0 === obj1) {
        return true;
      }

      for (var key in obj0) {
        if (hasOwnProperty.call(obj0, key)) {
          if (!(key in obj1)) {
            return false;
          }
        }
      }

      for (var key in obj1) {
        if (hasOwnProperty.call(obj1, key)) {
          if (obj0[key] !== obj1[key]) {
            return false;
          }
        }
      }

      return true;
    }

    function getUnequalProps(obj0, obj1) {
      var keys = [];

      for (var key in obj0) {
        if (hasOwnProperty.call(obj0, key)) {
          if (!(key in obj1)) {
            keys.push(key);
          }
        }
      }

      for (var key in obj1) {
        if (hasOwnProperty.call(obj1, key)) {
          if (obj0[key] !== obj1[key]) {
            keys.push(key);
          }
        }
      }

      return keys;
    }

    function compareObjs(oldProps, newProps, equalityFuncs) {
      if (equalityFuncs === void 0) {
        equalityFuncs = {};
      }

      if (oldProps === newProps) {
        return true;
      }

      for (var key in newProps) {
        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {
          return false;
        }
      } // check for props that were omitted in the new


      for (var key in oldProps) {
        if (!(key in newProps)) {
          return false;
        }
      }

      return true;
    }
    /*
    assumed "true" equality for handler names like "onReceiveSomething"
    */


    function isObjValsEqual(val0, val1, comparator) {
      if (val0 === val1 || comparator === true) {
        return true;
      }

      if (comparator) {
        return comparator(val0, val1);
      }

      return false;
    }

    function collectFromHash(hash, startIndex, endIndex, step) {
      if (startIndex === void 0) {
        startIndex = 0;
      }

      if (step === void 0) {
        step = 1;
      }

      var res = [];

      if (endIndex == null) {
        endIndex = Object.keys(hash).length;
      }

      for (var i = startIndex; i < endIndex; i += step) {
        var val = hash[i];

        if (val !== undefined) {
          // will disregard undefined for sparse arrays
          res.push(val);
        }
      }

      return res;
    }

    function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
      for (var i = 0; i < recurringTypes.length; i += 1) {
        var parsed = recurringTypes[i].parse(refined, dateEnv);

        if (parsed) {
          var allDay = refined.allDay;

          if (allDay == null) {
            allDay = defaultAllDay;

            if (allDay == null) {
              allDay = parsed.allDayGuess;

              if (allDay == null) {
                allDay = false;
              }
            }
          }

          return {
            allDay: allDay,
            duration: parsed.duration,
            typeData: parsed.typeData,
            typeId: i
          };
        }
      }

      return null;
    }

    function expandRecurring(eventStore, framingRange, context) {
      var dateEnv = context.dateEnv,
          pluginHooks = context.pluginHooks,
          options = context.options;
      var defs = eventStore.defs,
          instances = eventStore.instances; // remove existing recurring instances
      // TODO: bad. always expand events as a second step

      instances = filterHash(instances, function (instance) {
        return !defs[instance.defId].recurringDef;
      });

      for (var defId in defs) {
        var def = defs[defId];

        if (def.recurringDef) {
          var duration = def.recurringDef.duration;

          if (!duration) {
            duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
          }

          var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);

          for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {
            var start = starts_1[_i];
            var instance = createEventInstance(defId, {
              start: start,
              end: dateEnv.add(start, duration)
            });
            instances[instance.instanceId] = instance;
          }
        }
      }

      return {
        defs: defs,
        instances: instances
      };
    }
    /*
    Event MUST have a recurringDef
    */


    function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
      var typeDef = recurringTypes[eventDef.recurringDef.typeId];
      var markers = typeDef.expand(eventDef.recurringDef.typeData, {
        start: dateEnv.subtract(framingRange.start, duration),
        end: framingRange.end
      }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to

      if (eventDef.allDay) {
        markers = markers.map(startOfDay);
      }

      return markers;
    }
    var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; // Parsing and Creation

    function createDuration(input, unit) {
      var _a;

      if (typeof input === 'string') {
        return parseString(input);
      }

      if (typeof input === 'object' && input) {
        // non-null object
        return parseObject(input);
      }

      if (typeof input === 'number') {
        return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
      }

      return null;
    }

    function parseString(s) {
      var m = PARSE_RE.exec(s);

      if (m) {
        var sign = m[1] ? -1 : 1;
        return {
          years: 0,
          months: 0,
          days: sign * (m[2] ? parseInt(m[2], 10) : 0),
          milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
          (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
          (m[5] ? parseInt(m[5], 10) : 0) * 1000 + (m[6] ? parseInt(m[6], 10) : 0) // ms
          )
        };
      }

      return null;
    }

    function parseObject(obj) {
      var duration = {
        years: obj.years || obj.year || 0,
        months: obj.months || obj.month || 0,
        days: obj.days || obj.day || 0,
        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
        (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms

      };
      var weeks = obj.weeks || obj.week;

      if (weeks) {
        duration.days += weeks * 7;
        duration.specifiedWeeks = true;
      }

      return duration;
    } // Equality


    function durationsEqual(d0, d1) {
      return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
    }

    function subtractDurations(d1, d0) {
      return {
        years: d1.years - d0.years,
        months: d1.months - d0.months,
        days: d1.days - d0.days,
        milliseconds: d1.milliseconds - d0.milliseconds
      };
    }
    // "Rough" because they are based on average-case Gregorian months/years


    function asRoughYears(dur) {
      return asRoughDays(dur) / 365;
    }

    function asRoughMonths(dur) {
      return asRoughDays(dur) / 30;
    }

    function asRoughDays(dur) {
      return asRoughMs(dur) / 864e5;
    }

    function asRoughMs(dur) {
      return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
    } // Advanced Math

    function greatestDurationDenominator(dur) {
      var ms = dur.milliseconds;

      if (ms) {
        if (ms % 1000 !== 0) {
          return {
            unit: 'millisecond',
            value: ms
          };
        }

        if (ms % (1000 * 60) !== 0) {
          return {
            unit: 'second',
            value: ms / 1000
          };
        }

        if (ms % (1000 * 60 * 60) !== 0) {
          return {
            unit: 'minute',
            value: ms / (1000 * 60)
          };
        }

        if (ms) {
          return {
            unit: 'hour',
            value: ms / (1000 * 60 * 60)
          };
        }
      }

      if (dur.days) {
        if (dur.specifiedWeeks && dur.days % 7 === 0) {
          return {
            unit: 'week',
            value: dur.days / 7
          };
        }

        return {
          unit: 'day',
          value: dur.days
        };
      }

      if (dur.months) {
        return {
          unit: 'month',
          value: dur.months
        };
      }

      if (dur.years) {
        return {
          unit: 'year',
          value: dur.years
        };
      }

      return {
        unit: 'millisecond',
        value: 0
      };
    } // timeZoneOffset is in minutes


    function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
      if (stripZeroTime === void 0) {
        stripZeroTime = false;
      }

      var s = marker.toISOString();
      s = s.replace('.000', '');

      if (stripZeroTime) {
        s = s.replace('T00:00:00Z', '');
      }

      if (s.length > 10) {
        // time part wasn't stripped, can add timezone info
        if (timeZoneOffset == null) {
          s = s.replace('Z', '');
        } else if (timeZoneOffset !== 0) {
          s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
        } // otherwise, its UTC-0 and we want to keep the Z

      }

      return s;
    } // formats the date, but with no time part
    // TODO: somehow merge with buildIsoString and stripZeroTime
    // TODO: rename. omit "string"


    function formatDayString(marker) {
      return marker.toISOString().replace(/T.*$/, '');
    } // TODO: use Date::toISOString and use everything after the T?

    function formatTimeZoneOffset(minutes, doIso) {
      if (doIso === void 0) {
        doIso = false;
      }

      var sign = minutes < 0 ? '-' : '+';
      var abs = Math.abs(minutes);
      var hours = Math.floor(abs / 60);
      var mins = Math.round(abs % 60);

      if (doIso) {
        return sign + padStart(hours, 2) + ":" + padStart(mins, 2);
      }

      return "GMT" + sign + hours + (mins ? ":" + padStart(mins, 2) : '');
    } // TODO: new util arrayify?

    function isArraysEqual(a0, a1, equalityFunc) {
      if (a0 === a1) {
        return true;
      }

      var len = a0.length;
      var i;

      if (len !== a1.length) {
        // not array? or not same length?
        return false;
      }

      for (i = 0; i < len; i += 1) {
        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {
          return false;
        }
      }

      return true;
    }

    function memoize(workerFunc, resEquality, teardownFunc) {
      var currentArgs;
      var currentRes;
      return function () {
        var newArgs = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          newArgs[_i] = arguments[_i];
        }

        if (!currentArgs) {
          currentRes = workerFunc.apply(this, newArgs);
        } else if (!isArraysEqual(currentArgs, newArgs)) {
          if (teardownFunc) {
            teardownFunc(currentRes);
          }

          var res = workerFunc.apply(this, newArgs);

          if (!resEquality || !resEquality(res, currentRes)) {
            currentRes = res;
          }
        }

        currentArgs = newArgs;
        return currentRes;
      };
    }

    function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
      var _this = this;

      var currentArg;
      var currentRes;
      return function (newArg) {
        if (!currentArg) {
          currentRes = workerFunc.call(_this, newArg);
        } else if (!isPropsEqual(currentArg, newArg)) {
          if (teardownFunc) {
            teardownFunc(currentRes);
          }

          var res = workerFunc.call(_this, newArg);

          if (!resEquality || !resEquality(res, currentRes)) {
            currentRes = res;
          }
        }

        currentArg = newArg;
        return currentRes;
      };
    }

    var EXTENDED_SETTINGS_AND_SEVERITIES = {
      week: 3,
      separator: 0,
      omitZeroMinute: 0,
      meridiem: 0,
      omitCommas: 0
    };
    var STANDARD_DATE_PROP_SEVERITIES = {
      timeZoneName: 7,
      era: 6,
      year: 5,
      month: 4,
      day: 2,
      weekday: 2,
      hour: 1,
      minute: 1,
      second: 1
    };
    var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too

    var COMMA_RE = /,/g; // we need re for globalness

    var MULTI_SPACE_RE = /\s+/g;
    var LTR_RE = /\u200e/g; // control character

    var UTC_RE = /UTC|GMT/;

    var NativeFormatter = function () {
      function NativeFormatter(formatSettings) {
        var standardDateProps = {};
        var extendedSettings = {};
        var severity = 0;

        for (var name_1 in formatSettings) {
          if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
            extendedSettings[name_1] = formatSettings[name_1];
            severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
          } else {
            standardDateProps[name_1] = formatSettings[name_1];

            if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {
              // TODO: what about hour12? no severity
              severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
            }
          }
        }

        this.standardDateProps = standardDateProps;
        this.extendedSettings = extendedSettings;
        this.severity = severity;
        this.buildFormattingFunc = memoize(buildFormattingFunc);
      }

      NativeFormatter.prototype.format = function (date, context) {
        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
      };

      NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
        var _a = this,
            standardDateProps = _a.standardDateProps,
            extendedSettings = _a.extendedSettings;

        var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);

        if (!diffSeverity) {
          return this.format(start, context);
        }

        var biggestUnitForPartial = diffSeverity;

        if (biggestUnitForPartial > 1 && (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
          biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
        }

        var full0 = this.format(start, context);
        var full1 = this.format(end, context);

        if (full0 === full1) {
          return full0;
        }

        var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
        var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
        var partial0 = partialFormattingFunc(start);
        var partial1 = partialFormattingFunc(end);
        var insertion = findCommonInsertion(full0, partial0, full1, partial1);
        var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';

        if (insertion) {
          return insertion.before + partial0 + separator + partial1 + insertion.after;
        }

        return full0 + separator + full1;
      };

      NativeFormatter.prototype.getLargestUnit = function () {
        switch (this.severity) {
          case 7:
          case 6:
          case 5:
            return 'year';

          case 4:
            return 'month';

          case 3:
            return 'week';

          case 2:
            return 'day';

          default:
            return 'time';
          // really?
        }
      };

      return NativeFormatter;
    }();

    function buildFormattingFunc(standardDateProps, extendedSettings, context) {
      var standardDatePropCnt = Object.keys(standardDateProps).length;

      if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
        return function (date) {
          return formatTimeZoneOffset(date.timeZoneOffset);
        };
      }

      if (standardDatePropCnt === 0 && extendedSettings.week) {
        return function (date) {
          return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.locale, extendedSettings.week);
        };
      }

      return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
    }

    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
      standardDateProps = __assign({}, standardDateProps); // copy

      extendedSettings = __assign({}, extendedSettings); // copy

      sanitizeSettings(standardDateProps, extendedSettings);
      standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers

      var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
      var zeroFormat; // needed?

      if (extendedSettings.omitZeroMinute) {
        var zeroProps = __assign({}, standardDateProps);

        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings

        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
      }

      return function (date) {
        var marker = date.marker;
        var format;

        if (zeroFormat && !marker.getUTCMinutes()) {
          format = zeroFormat;
        } else {
          format = normalFormat;
        }

        var s = format.format(marker);
        return postProcess(s, date, standardDateProps, extendedSettings, context);
      };
    }

    function sanitizeSettings(standardDateProps, extendedSettings) {
      // deal with a browser inconsistency where formatting the timezone
      // requires that the hour/minute be present.
      if (standardDateProps.timeZoneName) {
        if (!standardDateProps.hour) {
          standardDateProps.hour = '2-digit';
        }

        if (!standardDateProps.minute) {
          standardDateProps.minute = '2-digit';
        }
      } // only support short timezone names


      if (standardDateProps.timeZoneName === 'long') {
        standardDateProps.timeZoneName = 'short';
      } // if requesting to display seconds, MUST display minutes


      if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
        delete extendedSettings.omitZeroMinute;
      }
    }

    function postProcess(s, date, standardDateProps, extendedSettings, context) {
      s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes

      if (standardDateProps.timeZoneName === 'short') {
        s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does "GMT"
        formatTimeZoneOffset(date.timeZoneOffset));
      }

      if (extendedSettings.omitCommas) {
        s = s.replace(COMMA_RE, '').trim();
      }

      if (extendedSettings.omitZeroMinute) {
        s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
      } // ^ do anything that might create adjacent spaces before this point,
      // because MERIDIEM_RE likes to eat up loading spaces


      if (extendedSettings.meridiem === false) {
        s = s.replace(MERIDIEM_RE, '').trim();
      } else if (extendedSettings.meridiem === 'narrow') {
        // a/p
        s = s.replace(MERIDIEM_RE, function (m0, m1) {
          return m1.toLocaleLowerCase();
        });
      } else if (extendedSettings.meridiem === 'short') {
        // am/pm
        s = s.replace(MERIDIEM_RE, function (m0, m1) {
          return m1.toLocaleLowerCase() + "m";
        });
      } else if (extendedSettings.meridiem === 'lowercase') {
        // other meridiem transformers already converted to lowercase
        s = s.replace(MERIDIEM_RE, function (m0) {
          return m0.toLocaleLowerCase();
        });
      }

      s = s.replace(MULTI_SPACE_RE, ' ');
      s = s.trim();
      return s;
    }

    function injectTzoStr(s, tzoStr) {
      var replaced = false;
      s = s.replace(UTC_RE, function () {
        replaced = true;
        return tzoStr;
      }); // IE11 doesn't include UTC/GMT in the original string, so append to end

      if (!replaced) {
        s += " " + tzoStr;
      }

      return s;
    }

    function formatWeekNumber(num, weekText, locale, display) {
      var parts = [];

      if (display === 'narrow') {
        parts.push(weekText);
      } else if (display === 'short') {
        parts.push(weekText, ' ');
      } // otherwise, considered 'numeric'


      parts.push(locale.simpleNumberFormat.format(num));

      if (locale.options.direction === 'rtl') {
        // TODO: use control characters instead?
        parts.reverse();
      }

      return parts.join('');
    } // Range Formatting Utils
    // 0 = exactly the same
    // 1 = different by time
    // and bigger


    function computeMarkerDiffSeverity(d0, d1, ca) {
      if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
        return 5;
      }

      if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
        return 4;
      }

      if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
        return 2;
      }

      if (timeAsMs(d0) !== timeAsMs(d1)) {
        return 1;
      }

      return 0;
    }

    function computePartialFormattingOptions(options, biggestUnit) {
      var partialOptions = {};

      for (var name_2 in options) {
        if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
        STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {
          partialOptions[name_2] = options[name_2];
        }
      }

      return partialOptions;
    }

    function findCommonInsertion(full0, partial0, full1, partial1) {
      var i0 = 0;

      while (i0 < full0.length) {
        var found0 = full0.indexOf(partial0, i0);

        if (found0 === -1) {
          break;
        }

        var before0 = full0.substr(0, found0);
        i0 = found0 + partial0.length;
        var after0 = full0.substr(i0);
        var i1 = 0;

        while (i1 < full1.length) {
          var found1 = full1.indexOf(partial1, i1);

          if (found1 === -1) {
            break;
          }

          var before1 = full1.substr(0, found1);
          i1 = found1 + partial1.length;
          var after1 = full1.substr(i1);

          if (before0 === before1 && after0 === after1) {
            return {
              before: before0,
              after: after0
            };
          }
        }
      }

      return null;
    }

    function expandZonedMarker(dateInfo, calendarSystem) {
      var a = calendarSystem.markerToArray(dateInfo.marker);
      return {
        marker: dateInfo.marker,
        timeZoneOffset: dateInfo.timeZoneOffset,
        array: a,
        year: a[0],
        month: a[1],
        day: a[2],
        hour: a[3],
        minute: a[4],
        second: a[5],
        millisecond: a[6]
      };
    }

    function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
      var startInfo = expandZonedMarker(start, context.calendarSystem);
      var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
      return {
        date: startInfo,
        start: startInfo,
        end: endInfo,
        timeZone: context.timeZone,
        localeCodes: context.locale.codes,
        defaultSeparator: betterDefaultSeparator || context.defaultSeparator
      };
    }
    /*
    TODO: fix the terminology of "formatter" vs "formatting func"
    */

    /*
    At the time of instantiation, this object does not know which cmd-formatting system it will use.
    It receives this at the time of formatting, as a setting.
    */


    var CmdFormatter = function () {
      function CmdFormatter(cmdStr) {
        this.cmdStr = cmdStr;
      }

      CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {
        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
      };

      CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
      };

      return CmdFormatter;
    }();

    var FuncFormatter = function () {
      function FuncFormatter(func) {
        this.func = func;
      }

      FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {
        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
      };

      FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
      };

      return FuncFormatter;
    }();

    function createFormatter(input) {
      if (typeof input === 'object' && input) {
        // non-null object
        return new NativeFormatter(input);
      }

      if (typeof input === 'string') {
        return new CmdFormatter(input);
      }

      if (typeof input === 'function') {
        return new FuncFormatter(input);
      }

      return null;
    } // base options
    // ------------


    var BASE_OPTION_REFINERS = {
      navLinkDayClick: identity,
      navLinkWeekClick: identity,
      duration: createDuration,
      bootstrapFontAwesome: identity,
      buttonIcons: identity,
      customButtons: identity,
      defaultAllDayEventDuration: createDuration,
      defaultTimedEventDuration: createDuration,
      nextDayThreshold: createDuration,
      scrollTime: createDuration,
      scrollTimeReset: Boolean,
      slotMinTime: createDuration,
      slotMaxTime: createDuration,
      dayPopoverFormat: createFormatter,
      slotDuration: createDuration,
      snapDuration: createDuration,
      headerToolbar: identity,
      footerToolbar: identity,
      defaultRangeSeparator: String,
      titleRangeSeparator: String,
      forceEventDuration: Boolean,
      dayHeaders: Boolean,
      dayHeaderFormat: createFormatter,
      dayHeaderClassNames: identity,
      dayHeaderContent: identity,
      dayHeaderDidMount: identity,
      dayHeaderWillUnmount: identity,
      dayCellClassNames: identity,
      dayCellContent: identity,
      dayCellDidMount: identity,
      dayCellWillUnmount: identity,
      initialView: String,
      aspectRatio: Number,
      weekends: Boolean,
      weekNumberCalculation: identity,
      weekNumbers: Boolean,
      weekNumberClassNames: identity,
      weekNumberContent: identity,
      weekNumberDidMount: identity,
      weekNumberWillUnmount: identity,
      editable: Boolean,
      viewClassNames: identity,
      viewDidMount: identity,
      viewWillUnmount: identity,
      nowIndicator: Boolean,
      nowIndicatorClassNames: identity,
      nowIndicatorContent: identity,
      nowIndicatorDidMount: identity,
      nowIndicatorWillUnmount: identity,
      showNonCurrentDates: Boolean,
      lazyFetching: Boolean,
      startParam: String,
      endParam: String,
      timeZoneParam: String,
      timeZone: String,
      locales: identity,
      locale: identity,
      themeSystem: String,
      dragRevertDuration: Number,
      dragScroll: Boolean,
      allDayMaintainDuration: Boolean,
      unselectAuto: Boolean,
      dropAccept: identity,
      eventOrder: parseFieldSpecs,
      eventOrderStrict: Boolean,
      handleWindowResize: Boolean,
      windowResizeDelay: Number,
      longPressDelay: Number,
      eventDragMinDistance: Number,
      expandRows: Boolean,
      height: identity,
      contentHeight: identity,
      direction: String,
      weekNumberFormat: createFormatter,
      eventResizableFromStart: Boolean,
      displayEventTime: Boolean,
      displayEventEnd: Boolean,
      weekText: String,
      progressiveEventRendering: Boolean,
      businessHours: identity,
      initialDate: identity,
      now: identity,
      eventDataTransform: identity,
      stickyHeaderDates: identity,
      stickyFooterScrollbar: identity,
      viewHeight: identity,
      defaultAllDay: Boolean,
      eventSourceFailure: identity,
      eventSourceSuccess: identity,
      eventDisplay: String,
      eventStartEditable: Boolean,
      eventDurationEditable: Boolean,
      eventOverlap: identity,
      eventConstraint: identity,
      eventAllow: identity,
      eventBackgroundColor: String,
      eventBorderColor: String,
      eventTextColor: String,
      eventColor: String,
      eventClassNames: identity,
      eventContent: identity,
      eventDidMount: identity,
      eventWillUnmount: identity,
      selectConstraint: identity,
      selectOverlap: identity,
      selectAllow: identity,
      droppable: Boolean,
      unselectCancel: String,
      slotLabelFormat: identity,
      slotLaneClassNames: identity,
      slotLaneContent: identity,
      slotLaneDidMount: identity,
      slotLaneWillUnmount: identity,
      slotLabelClassNames: identity,
      slotLabelContent: identity,
      slotLabelDidMount: identity,
      slotLabelWillUnmount: identity,
      dayMaxEvents: identity,
      dayMaxEventRows: identity,
      dayMinWidth: Number,
      slotLabelInterval: createDuration,
      allDayText: String,
      allDayClassNames: identity,
      allDayContent: identity,
      allDayDidMount: identity,
      allDayWillUnmount: identity,
      slotMinWidth: Number,
      navLinks: Boolean,
      eventTimeFormat: createFormatter,
      rerenderDelay: Number,
      moreLinkText: identity,
      selectMinDistance: Number,
      selectable: Boolean,
      selectLongPressDelay: Number,
      eventLongPressDelay: Number,
      selectMirror: Boolean,
      eventMaxStack: Number,
      eventMinHeight: Number,
      eventMinWidth: Number,
      eventShortHeight: Number,
      slotEventOverlap: Boolean,
      plugins: identity,
      firstDay: Number,
      dayCount: Number,
      dateAlignment: String,
      dateIncrement: createDuration,
      hiddenDays: identity,
      monthMode: Boolean,
      fixedWeekCount: Boolean,
      validRange: identity,
      visibleRange: identity,
      titleFormat: identity,
      // only used by list-view, but languages define the value, so we need it in base options
      noEventsText: String,
      moreLinkClick: identity,
      moreLinkClassNames: identity,
      moreLinkContent: identity,
      moreLinkDidMount: identity,
      moreLinkWillUnmount: identity
    }; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.
    // raw values.

    var BASE_OPTION_DEFAULTS = {
      eventDisplay: 'auto',
      defaultRangeSeparator: ' - ',
      titleRangeSeparator: ' \u2013 ',
      defaultTimedEventDuration: '01:00:00',
      defaultAllDayEventDuration: {
        day: 1
      },
      forceEventDuration: false,
      nextDayThreshold: '00:00:00',
      dayHeaders: true,
      initialView: '',
      aspectRatio: 1.35,
      headerToolbar: {
        start: 'title',
        center: '',
        end: 'today prev,next'
      },
      weekends: true,
      weekNumbers: false,
      weekNumberCalculation: 'local',
      editable: false,
      nowIndicator: false,
      scrollTime: '06:00:00',
      scrollTimeReset: true,
      slotMinTime: '00:00:00',
      slotMaxTime: '24:00:00',
      showNonCurrentDates: true,
      lazyFetching: true,
      startParam: 'start',
      endParam: 'end',
      timeZoneParam: 'timeZone',
      timeZone: 'local',
      locales: [],
      locale: '',
      themeSystem: 'standard',
      dragRevertDuration: 500,
      dragScroll: true,
      allDayMaintainDuration: false,
      unselectAuto: true,
      dropAccept: '*',
      eventOrder: 'start,-duration,allDay,title',
      dayPopoverFormat: {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      },
      handleWindowResize: true,
      windowResizeDelay: 100,
      longPressDelay: 1000,
      eventDragMinDistance: 5,
      expandRows: false,
      navLinks: false,
      selectable: false,
      eventMinHeight: 15,
      eventMinWidth: 30,
      eventShortHeight: 30
    }; // calendar listeners
    // ------------------

    var CALENDAR_LISTENER_REFINERS = {
      datesSet: identity,
      eventsSet: identity,
      eventAdd: identity,
      eventChange: identity,
      eventRemove: identity,
      windowResize: identity,
      eventClick: identity,
      eventMouseEnter: identity,
      eventMouseLeave: identity,
      select: identity,
      unselect: identity,
      loading: identity,
      // internal
      _unmount: identity,
      _beforeprint: identity,
      _afterprint: identity,
      _noEventDrop: identity,
      _noEventResize: identity,
      _resize: identity,
      _scrollRequest: identity
    }; // calendar-specific options
    // -------------------------

    var CALENDAR_OPTION_REFINERS = {
      buttonText: identity,
      views: identity,
      plugins: identity,
      initialEvents: identity,
      events: identity,
      eventSources: identity
    };
    var COMPLEX_OPTION_COMPARATORS = {
      headerToolbar: isBoolComplexEqual,
      footerToolbar: isBoolComplexEqual,
      buttonText: isBoolComplexEqual,
      buttonIcons: isBoolComplexEqual
    };

    function isBoolComplexEqual(a, b) {
      if (typeof a === 'object' && typeof b === 'object' && a && b) {
        // both non-null objects
        return isPropsEqual(a, b);
      }

      return a === b;
    } // view-specific options
    // ---------------------


    var VIEW_OPTION_REFINERS = {
      type: String,
      component: identity,
      buttonText: String,
      buttonTextKey: String,
      dateProfileGeneratorClass: identity,
      usesMinMaxTime: Boolean,
      classNames: identity,
      content: identity,
      didMount: identity,
      willUnmount: identity
    }; // util funcs
    // ----------------------------------------------------------------------------------------------------

    function mergeRawOptions(optionSets) {
      return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
    }

    function refineProps(input, refiners) {
      var refined = {};
      var extra = {};

      for (var propName in refiners) {
        if (propName in input) {
          refined[propName] = refiners[propName](input[propName]);
        }
      }

      for (var propName in input) {
        if (!(propName in refiners)) {
          extra[propName] = input[propName];
        }
      }

      return {
        refined: refined,
        extra: extra
      };
    }

    function identity(raw) {
      return raw;
    }

    function parseEvents(rawEvents, eventSource, context, allowOpenRange) {
      var eventStore = createEmptyEventStore();
      var eventRefiners = buildEventRefiners(context);

      for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
        var rawEvent = rawEvents_1[_i];
        var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);

        if (tuple) {
          eventTupleToStore(tuple, eventStore);
        }
      }

      return eventStore;
    }

    function eventTupleToStore(tuple, eventStore) {
      if (eventStore === void 0) {
        eventStore = createEmptyEventStore();
      }

      eventStore.defs[tuple.def.defId] = tuple.def;

      if (tuple.instance) {
        eventStore.instances[tuple.instance.instanceId] = tuple.instance;
      }

      return eventStore;
    } // retrieves events that have the same groupId as the instance specified by `instanceId`
    // or they are the same as the instance.
    // why might instanceId not be in the store? an event from another calendar?


    function getRelevantEvents(eventStore, instanceId) {
      var instance = eventStore.instances[instanceId];

      if (instance) {
        var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group

        var newStore = filterEventStoreDefs(eventStore, function (lookDef) {
          return isEventDefsGrouped(def_1, lookDef);
        }); // add the original
        // TODO: wish we could use eventTupleToStore or something like it

        newStore.defs[def_1.defId] = def_1;
        newStore.instances[instance.instanceId] = instance;
        return newStore;
      }

      return createEmptyEventStore();
    }

    function isEventDefsGrouped(def0, def1) {
      return Boolean(def0.groupId && def0.groupId === def1.groupId);
    }

    function createEmptyEventStore() {
      return {
        defs: {},
        instances: {}
      };
    }

    function mergeEventStores(store0, store1) {
      return {
        defs: __assign(__assign({}, store0.defs), store1.defs),
        instances: __assign(__assign({}, store0.instances), store1.instances)
      };
    }

    function filterEventStoreDefs(eventStore, filterFunc) {
      var defs = filterHash(eventStore.defs, filterFunc);
      var instances = filterHash(eventStore.instances, function (instance) {
        return defs[instance.defId] // still exists?
        ;
      });
      return {
        defs: defs,
        instances: instances
      };
    }

    function excludeSubEventStore(master, sub) {
      var defs = master.defs,
          instances = master.instances;
      var filteredDefs = {};
      var filteredInstances = {};

      for (var defId in defs) {
        if (!sub.defs[defId]) {
          // not explicitly excluded
          filteredDefs[defId] = defs[defId];
        }
      }

      for (var instanceId in instances) {
        if (!sub.instances[instanceId] && // not explicitly excluded
        filteredDefs[instances[instanceId].defId] // def wasn't filtered away
        ) {
          filteredInstances[instanceId] = instances[instanceId];
        }
      }

      return {
        defs: filteredDefs,
        instances: filteredInstances
      };
    }

    function normalizeConstraint(input, context) {
      if (Array.isArray(input)) {
        return parseEvents(input, null, context, true); // allowOpenRange=true
      }

      if (typeof input === 'object' && input) {
        // non-null object
        return parseEvents([input], null, context, true); // allowOpenRange=true
      }

      if (input != null) {
        return String(input);
      }

      return null;
    }

    function parseClassNames(raw) {
      if (Array.isArray(raw)) {
        return raw;
      }

      if (typeof raw === 'string') {
        return raw.split(/\s+/);
      }

      return [];
    } // TODO: better called "EventSettings" or "EventConfig"
    // TODO: move this file into structs
    // TODO: separate constraint/overlap/allow, because selection uses only that, not other props


    var EVENT_UI_REFINERS = {
      display: String,
      editable: Boolean,
      startEditable: Boolean,
      durationEditable: Boolean,
      constraint: identity,
      overlap: identity,
      allow: identity,
      className: parseClassNames,
      classNames: parseClassNames,
      color: String,
      backgroundColor: String,
      borderColor: String,
      textColor: String
    };
    var EMPTY_EVENT_UI = {
      display: null,
      startEditable: null,
      durationEditable: null,
      constraints: [],
      overlap: null,
      allows: [],
      backgroundColor: '',
      borderColor: '',
      textColor: '',
      classNames: []
    };

    function createEventUi(refined, context) {
      var constraint = normalizeConstraint(refined.constraint, context);
      return {
        display: refined.display || null,
        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
        constraints: constraint != null ? [constraint] : [],
        overlap: refined.overlap != null ? refined.overlap : null,
        allows: refined.allow != null ? [refined.allow] : [],
        backgroundColor: refined.backgroundColor || refined.color || '',
        borderColor: refined.borderColor || refined.color || '',
        textColor: refined.textColor || '',
        classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural

      };
    } // TODO: prevent against problems with <2 args!


    function combineEventUis(uis) {
      return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
    }

    function combineTwoEventUis(item0, item1) {
      return {
        display: item1.display != null ? item1.display : item0.display,
        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
        constraints: item0.constraints.concat(item1.constraints),
        overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
        allows: item0.allows.concat(item1.allows),
        backgroundColor: item1.backgroundColor || item0.backgroundColor,
        borderColor: item1.borderColor || item0.borderColor,
        textColor: item1.textColor || item0.textColor,
        classNames: item0.classNames.concat(item1.classNames)
      };
    }

    var EVENT_NON_DATE_REFINERS = {
      id: String,
      groupId: String,
      title: String,
      url: String
    };
    var EVENT_DATE_REFINERS = {
      start: identity,
      end: identity,
      date: identity,
      allDay: Boolean
    };

    var EVENT_REFINERS = __assign(__assign(__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {
      extendedProps: identity
    });

    function parseEvent(raw, eventSource, context, allowOpenRange, refiners) {
      if (refiners === void 0) {
        refiners = buildEventRefiners(context);
      }

      var _a = refineEventDef(raw, context, refiners),
          refined = _a.refined,
          extra = _a.extra;

      var defaultAllDay = computeIsDefaultAllDay(eventSource, context);
      var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);

      if (recurringRes) {
        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);
        def.recurringDef = {
          typeId: recurringRes.typeId,
          typeData: recurringRes.typeData,
          duration: recurringRes.duration
        };
        return {
          def: def,
          instance: null
        };
      }

      var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);

      if (singleRes) {
        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);
        var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
        return {
          def: def,
          instance: instance
        };
      }

      return null;
    }

    function refineEventDef(raw, context, refiners) {
      if (refiners === void 0) {
        refiners = buildEventRefiners(context);
      }

      return refineProps(raw, refiners);
    }

    function buildEventRefiners(context) {
      return __assign(__assign(__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
    }
    /*
    Will NOT populate extendedProps with the leftover properties.
    Will NOT populate date-related props.
    */


    function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {
      var def = {
        title: refined.title || '',
        groupId: refined.groupId || '',
        publicId: refined.id || '',
        url: refined.url || '',
        recurringDef: null,
        defId: guid(),
        sourceId: sourceId,
        allDay: allDay,
        hasEnd: hasEnd,
        ui: createEventUi(refined, context),
        extendedProps: __assign(__assign({}, refined.extendedProps || {}), extra)
      };

      for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {
        var memberAdder = _a[_i];

        __assign(def, memberAdder(refined));
      } // help out EventApi from having user modify props


      Object.freeze(def.ui.classNames);
      Object.freeze(def.extendedProps);
      return def;
    }

    function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
      var allDay = refined.allDay;
      var startMeta;
      var startMarker = null;
      var hasEnd = false;
      var endMeta;
      var endMarker = null;
      var startInput = refined.start != null ? refined.start : refined.date;
      startMeta = context.dateEnv.createMarkerMeta(startInput);

      if (startMeta) {
        startMarker = startMeta.marker;
      } else if (!allowOpenRange) {
        return null;
      }

      if (refined.end != null) {
        endMeta = context.dateEnv.createMarkerMeta(refined.end);
      }

      if (allDay == null) {
        if (defaultAllDay != null) {
          allDay = defaultAllDay;
        } else {
          // fall back to the date props LAST
          allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
        }
      }

      if (allDay && startMarker) {
        startMarker = startOfDay(startMarker);
      }

      if (endMeta) {
        endMarker = endMeta.marker;

        if (allDay) {
          endMarker = startOfDay(endMarker);
        }

        if (startMarker && endMarker <= startMarker) {
          endMarker = null;
        }
      }

      if (endMarker) {
        hasEnd = true;
      } else if (!allowOpenRange) {
        hasEnd = context.options.forceEventDuration || false;
        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
      }

      return {
        allDay: allDay,
        hasEnd: hasEnd,
        range: {
          start: startMarker,
          end: endMarker
        },
        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
        forcedEndTzo: endMeta ? endMeta.forcedTzo : null
      };
    }

    function computeIsDefaultAllDay(eventSource, context) {
      var res = null;

      if (eventSource) {
        res = eventSource.defaultAllDay;
      }

      if (res == null) {
        res = context.options.defaultAllDay;
      }

      return res;
    }
    /* Date stuff that doesn't belong in datelib core
    ----------------------------------------------------------------------------------------------------------------------*/
    // given a timed range, computes an all-day range that has the same exact duration,
    // but whose start time is aligned with the start of the day.


    function computeAlignedDayRange(timedRange) {
      var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
      var start = startOfDay(timedRange.start);
      var end = addDays(start, dayCnt);
      return {
        start: start,
        end: end
      };
    } // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
    // TODO: give nextDayThreshold a default arg


    function computeVisibleDayRange(timedRange, nextDayThreshold) {
      if (nextDayThreshold === void 0) {
        nextDayThreshold = createDuration(0);
      }

      var startDay = null;
      var endDay = null;

      if (timedRange.end) {
        endDay = startOfDay(timedRange.end);
        var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.

        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
          endDay = addDays(endDay, 1);
        }
      }

      if (timedRange.start) {
        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.

        if (endDay && endDay <= startDay) {
          endDay = addDays(startDay, 1);
        }
      }

      return {
        start: startDay,
        end: endDay
      };
    } // spans from one day into another?

    function diffDates(date0, date1, dateEnv, largeUnit) {
      if (largeUnit === 'year') {
        return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
      }

      if (largeUnit === 'month') {
        return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
      }

      return diffDayAndTime(date0, date1); // returns a duration
    }

    function parseRange(input, dateEnv) {
      var start = null;
      var end = null;

      if (input.start) {
        start = dateEnv.createMarker(input.start);
      }

      if (input.end) {
        end = dateEnv.createMarker(input.end);
      }

      if (!start && !end) {
        return null;
      }

      if (start && end && end < start) {
        return null;
      }

      return {
        start: start,
        end: end
      };
    } // SIDE-EFFECT: will mutate ranges.
    // Will return a new array result.


    function invertRanges(ranges, constraintRange) {
      var invertedRanges = [];
      var start = constraintRange.start; // the end of the previous range. the start of the new range

      var i;
      var dateRange; // ranges need to be in order. required for our date-walking algorithm

      ranges.sort(compareRanges);

      for (i = 0; i < ranges.length; i += 1) {
        dateRange = ranges[i]; // add the span of time before the event (if there is any)

        if (dateRange.start > start) {
          // compare millisecond time (skip any ambig logic)
          invertedRanges.push({
            start: start,
            end: dateRange.start
          });
        }

        if (dateRange.end > start) {
          start = dateRange.end;
        }
      } // add the span of time after the last event (if there is any)


      if (start < constraintRange.end) {
        // compare millisecond time (skip any ambig logic)
        invertedRanges.push({
          start: start,
          end: constraintRange.end
        });
      }

      return invertedRanges;
    }

    function compareRanges(range0, range1) {
      return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
    }

    function intersectRanges(range0, range1) {
      var start = range0.start,
          end = range0.end;
      var newRange = null;

      if (range1.start !== null) {
        if (start === null) {
          start = range1.start;
        } else {
          start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
        }
      }

      if (range1.end != null) {
        if (end === null) {
          end = range1.end;
        } else {
          end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
        }
      }

      if (start === null || end === null || start < end) {
        newRange = {
          start: start,
          end: end
        };
      }

      return newRange;
    }

    function rangesIntersect(range0, range1) {
      return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
    }

    function rangeContainsMarker(range, date) {
      return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
    } // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).


    function constrainMarkerToRange(date, range) {
      if (range.start != null && date < range.start) {
        return range.start;
      }

      if (range.end != null && date >= range.end) {
        return new Date(range.end.valueOf() - 1);
      }

      return date;
    }
    /*
    Specifying nextDayThreshold signals that all-day ranges should be sliced.
    */


    function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
      var inverseBgByGroupId = {};
      var inverseBgByDefId = {};
      var defByGroupId = {};
      var bgRanges = [];
      var fgRanges = [];
      var eventUis = compileEventUis(eventStore.defs, eventUiBases);

      for (var defId in eventStore.defs) {
        var def = eventStore.defs[defId];
        var ui = eventUis[def.defId];

        if (ui.display === 'inverse-background') {
          if (def.groupId) {
            inverseBgByGroupId[def.groupId] = [];

            if (!defByGroupId[def.groupId]) {
              defByGroupId[def.groupId] = def;
            }
          } else {
            inverseBgByDefId[defId] = [];
          }
        }
      }

      for (var instanceId in eventStore.instances) {
        var instance = eventStore.instances[instanceId];
        var def = eventStore.defs[instance.defId];
        var ui = eventUis[def.defId];
        var origRange = instance.range;
        var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
        var slicedRange = intersectRanges(normalRange, framingRange);

        if (slicedRange) {
          if (ui.display === 'inverse-background') {
            if (def.groupId) {
              inverseBgByGroupId[def.groupId].push(slicedRange);
            } else {
              inverseBgByDefId[instance.defId].push(slicedRange);
            }
          } else if (ui.display !== 'none') {
            (ui.display === 'background' ? bgRanges : fgRanges).push({
              def: def,
              ui: ui,
              instance: instance,
              range: slicedRange,
              isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
              isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
            });
          }
        }
      }

      for (var groupId in inverseBgByGroupId) {
        // BY GROUP
        var ranges = inverseBgByGroupId[groupId];
        var invertedRanges = invertRanges(ranges, framingRange);

        for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {
          var invertedRange = invertedRanges_1[_i];
          var def = defByGroupId[groupId];
          var ui = eventUis[def.defId];
          bgRanges.push({
            def: def,
            ui: ui,
            instance: null,
            range: invertedRange,
            isStart: false,
            isEnd: false
          });
        }
      }

      for (var defId in inverseBgByDefId) {
        var ranges = inverseBgByDefId[defId];
        var invertedRanges = invertRanges(ranges, framingRange);

        for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {
          var invertedRange = invertedRanges_2[_a];
          bgRanges.push({
            def: eventStore.defs[defId],
            ui: eventUis[defId],
            instance: null,
            range: invertedRange,
            isStart: false,
            isEnd: false
          });
        }
      }

      return {
        bg: bgRanges,
        fg: fgRanges
      };
    }

    function setElSeg(el, seg) {
      el.fcSeg = seg;
    }

    function getElSeg(el) {
      return el.fcSeg || el.parentNode.fcSeg || // for the harness
      null;
    } // event ui computation


    function compileEventUis(eventDefs, eventUiBases) {
      return mapHash(eventDefs, function (eventDef) {
        return compileEventUi(eventDef, eventUiBases);
      });
    }

    function compileEventUi(eventDef, eventUiBases) {
      var uis = [];

      if (eventUiBases['']) {
        uis.push(eventUiBases['']);
      }

      if (eventUiBases[eventDef.defId]) {
        uis.push(eventUiBases[eventDef.defId]);
      }

      uis.push(eventDef.ui);
      return combineEventUis(uis);
    }

    function sortEventSegs(segs, eventOrderSpecs) {
      var objs = segs.map(buildSegCompareObj);
      objs.sort(function (obj0, obj1) {
        return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);
      });
      return objs.map(function (c) {
        return c._seg;
      });
    } // returns a object with all primitive props that can be compared


    function buildSegCompareObj(seg) {
      var eventRange = seg.eventRange;
      var eventDef = eventRange.def;
      var range = eventRange.instance ? eventRange.instance.range : eventRange.range;
      var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events

      var end = range.end ? range.end.valueOf() : 0; // "

      return __assign(__assign(__assign({}, eventDef.extendedProps), eventDef), {
        id: eventDef.publicId,
        start: start,
        end: end,
        duration: end - start,
        allDay: Number(eventDef.allDay),
        _seg: seg
      });
    }

    function computeSegDraggable(seg, context) {
      var pluginHooks = context.pluginHooks;
      var transformers = pluginHooks.isDraggableTransformers;
      var _a = seg.eventRange,
          def = _a.def,
          ui = _a.ui;
      var val = ui.startEditable;

      for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
        var transformer = transformers_1[_i];
        val = transformer(val, def, ui, context);
      }

      return val;
    }

    function computeSegStartResizable(seg, context) {
      return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
    }

    function computeSegEndResizable(seg, context) {
      return seg.isEnd && seg.eventRange.ui.durationEditable;
    }

    function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true
    defaultDisplayEventEnd, // defaults to true
    startOverride, endOverride) {
      var dateEnv = context.dateEnv,
          options = context.options;
      var displayEventTime = options.displayEventTime,
          displayEventEnd = options.displayEventEnd;
      var eventDef = seg.eventRange.def;
      var eventInstance = seg.eventRange.instance;

      if (displayEventTime == null) {
        displayEventTime = defaultDisplayEventTime !== false;
      }

      if (displayEventEnd == null) {
        displayEventEnd = defaultDisplayEventEnd !== false;
      }

      var wholeEventStart = eventInstance.range.start;
      var wholeEventEnd = eventInstance.range.end;
      var segStart = startOverride || seg.start || seg.eventRange.range.start;
      var segEnd = endOverride || seg.end || seg.eventRange.range.end;
      var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
      var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();

      if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
        segStart = isStartDay ? wholeEventStart : segStart;
        segEnd = isEndDay ? wholeEventEnd : segEnd;

        if (displayEventEnd && eventDef.hasEnd) {
          return dateEnv.formatRange(segStart, segEnd, timeFormat, {
            forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
            forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
          });
        }

        return dateEnv.format(segStart, timeFormat, {
          forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same

        });
      }

      return '';
    }

    function getSegMeta(seg, todayRange, nowDate) {
      var segRange = seg.eventRange.range;
      return {
        isPast: segRange.end < (nowDate || todayRange.start),
        isFuture: segRange.start >= (nowDate || todayRange.end),
        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
      };
    }

    function getEventClassNames(props) {
      var classNames = ['fc-event'];

      if (props.isMirror) {
        classNames.push('fc-event-mirror');
      }

      if (props.isDraggable) {
        classNames.push('fc-event-draggable');
      }

      if (props.isStartResizable || props.isEndResizable) {
        classNames.push('fc-event-resizable');
      }

      if (props.isDragging) {
        classNames.push('fc-event-dragging');
      }

      if (props.isResizing) {
        classNames.push('fc-event-resizing');
      }

      if (props.isSelected) {
        classNames.push('fc-event-selected');
      }

      if (props.isStart) {
        classNames.push('fc-event-start');
      }

      if (props.isEnd) {
        classNames.push('fc-event-end');
      }

      if (props.isPast) {
        classNames.push('fc-event-past');
      }

      if (props.isToday) {
        classNames.push('fc-event-today');
      }

      if (props.isFuture) {
        classNames.push('fc-event-future');
      }

      return classNames;
    }

    function buildEventRangeKey(eventRange) {
      return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + ":" + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution
    }

    var STANDARD_PROPS = {
      start: identity,
      end: identity,
      allDay: Boolean
    };

    function parseDateSpan(raw, dateEnv, defaultDuration) {
      var span = parseOpenDateSpan(raw, dateEnv);
      var range = span.range;

      if (!range.start) {
        return null;
      }

      if (!range.end) {
        if (defaultDuration == null) {
          return null;
        }

        range.end = dateEnv.add(range.start, defaultDuration);
      }

      return span;
    }
    /*
    TODO: somehow combine with parseRange?
    Will return null if the start/end props were present but parsed invalidly.
    */


    function parseOpenDateSpan(raw, dateEnv) {
      var _a = refineProps(raw, STANDARD_PROPS),
          standardProps = _a.refined,
          extra = _a.extra;

      var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
      var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
      var allDay = standardProps.allDay;

      if (allDay == null) {
        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
      }

      return __assign({
        range: {
          start: startMeta ? startMeta.marker : null,
          end: endMeta ? endMeta.marker : null
        },
        allDay: allDay
      }, extra);
    }

    function buildDateSpanApi(span, dateEnv) {
      return __assign(__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {
        allDay: span.allDay
      });
    }

    function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
      return __assign(__assign({}, buildRangeApi(range, dateEnv, omitTime)), {
        timeZone: dateEnv.timeZone
      });
    }

    function buildRangeApi(range, dateEnv, omitTime) {
      return {
        start: dateEnv.toDate(range.start),
        end: dateEnv.toDate(range.end),
        startStr: dateEnv.formatIso(range.start, {
          omitTime: omitTime
        }),
        endStr: dateEnv.formatIso(range.end, {
          omitTime: omitTime
        })
      };
    }

    function fabricateEventRange(dateSpan, eventUiBases, context) {
      var res = refineEventDef({
        editable: false
      }, context);
      var def = parseEventDef(res.refined, res.extra, '', // sourceId
      dateSpan.allDay, true, // hasEnd
      context);
      return {
        def: def,
        ui: compileEventUi(def, eventUiBases),
        instance: createEventInstance(def.defId, dateSpan.range),
        range: dateSpan.range,
        isStart: true,
        isEnd: true
      };
    }

    function triggerDateSelect(selection, pev, context) {
      context.emitter.trigger('select', __assign(__assign({}, buildDateSpanApiWithContext(selection, context)), {
        jsEvent: pev ? pev.origEvent : null,
        view: context.viewApi || context.calendarApi.view
      }));
    }

    function triggerDateUnselect(pev, context) {
      context.emitter.trigger('unselect', {
        jsEvent: pev ? pev.origEvent : null,
        view: context.viewApi || context.calendarApi.view
      });
    }

    function buildDateSpanApiWithContext(dateSpan, context) {
      var props = {};

      for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {
        var transform = _a[_i];

        __assign(props, transform(dateSpan, context));
      }

      __assign(props, buildDateSpanApi(dateSpan, context.dateEnv));

      return props;
    } // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd


    function getDefaultEventEnd(allDay, marker, context) {
      var dateEnv = context.dateEnv,
          options = context.options;
      var end = marker;

      if (allDay) {
        end = startOfDay(end);
        end = dateEnv.add(end, options.defaultAllDayEventDuration);
      } else {
        end = dateEnv.add(end, options.defaultTimedEventDuration);
      }

      return end;
    } // applies the mutation to ALL defs/instances within the event store


    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
      var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
      var dest = createEmptyEventStore();

      for (var defId in eventStore.defs) {
        var def = eventStore.defs[defId];
        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
      }

      for (var instanceId in eventStore.instances) {
        var instance = eventStore.instances[instanceId];
        var def = dest.defs[instance.defId]; // important to grab the newly modified def

        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
      }

      return dest;
    }

    function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
      var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.
      // if duration will change, there's no way the default duration will persist,
      // and thus, we need to mark the event as having a real end

      if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
        standardProps.hasEnd = true; // TODO: is this mutation okay?
      }

      var copy = __assign(__assign(__assign({}, eventDef), standardProps), {
        ui: __assign(__assign({}, eventDef.ui), standardProps.ui)
      });

      if (mutation.extendedProps) {
        copy.extendedProps = __assign(__assign({}, copy.extendedProps), mutation.extendedProps);
      }

      for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {
        var applier = _a[_i];
        applier(copy, mutation, context);
      }

      if (!copy.hasEnd && context.options.forceEventDuration) {
        copy.hasEnd = true;
      }

      return copy;
    }

    function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
    eventConfig, mutation, context) {
      var dateEnv = context.dateEnv;
      var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
      var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;

      var copy = __assign({}, eventInstance);

      if (forceAllDay) {
        copy.range = computeAlignedDayRange(copy.range);
      }

      if (mutation.datesDelta && eventConfig.startEditable) {
        copy.range = {
          start: dateEnv.add(copy.range.start, mutation.datesDelta),
          end: dateEnv.add(copy.range.end, mutation.datesDelta)
        };
      }

      if (mutation.startDelta && eventConfig.durationEditable) {
        copy.range = {
          start: dateEnv.add(copy.range.start, mutation.startDelta),
          end: copy.range.end
        };
      }

      if (mutation.endDelta && eventConfig.durationEditable) {
        copy.range = {
          start: copy.range.start,
          end: dateEnv.add(copy.range.end, mutation.endDelta)
        };
      }

      if (clearEnd) {
        copy.range = {
          start: copy.range.start,
          end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
        };
      } // in case event was all-day but the supplied deltas were not
      // better util for this?


      if (eventDef.allDay) {
        copy.range = {
          start: startOfDay(copy.range.start),
          end: startOfDay(copy.range.end)
        };
      } // handle invalid durations


      if (copy.range.end < copy.range.start) {
        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
      }

      return copy;
    } // no public types yet. when there are, export from:
    // import {} from './api-type-deps'


    var ViewApi = function () {
      function ViewApi(type, getCurrentData, dateEnv) {
        this.type = type;
        this.getCurrentData = getCurrentData;
        this.dateEnv = dateEnv;
      }

      Object.defineProperty(ViewApi.prototype, "calendar", {
        get: function () {
          return this.getCurrentData().calendarApi;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewApi.prototype, "title", {
        get: function () {
          return this.getCurrentData().viewTitle;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewApi.prototype, "activeStart", {
        get: function () {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewApi.prototype, "activeEnd", {
        get: function () {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewApi.prototype, "currentStart", {
        get: function () {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewApi.prototype, "currentEnd", {
        get: function () {
          return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
        },
        enumerable: false,
        configurable: true
      });

      ViewApi.prototype.getOption = function (name) {
        return this.getCurrentData().options[name]; // are the view-specific options
      };

      return ViewApi;
    }();

    var EVENT_SOURCE_REFINERS = {
      id: String,
      defaultAllDay: Boolean,
      url: String,
      format: String,
      events: identity,
      eventDataTransform: identity,
      // for any network-related sources
      success: identity,
      failure: identity
    };

    function parseEventSource(raw, context, refiners) {
      if (refiners === void 0) {
        refiners = buildEventSourceRefiners(context);
      }

      var rawObj;

      if (typeof raw === 'string') {
        rawObj = {
          url: raw
        };
      } else if (typeof raw === 'function' || Array.isArray(raw)) {
        rawObj = {
          events: raw
        };
      } else if (typeof raw === 'object' && raw) {
        // not null
        rawObj = raw;
      }

      if (rawObj) {
        var _a = refineProps(rawObj, refiners),
            refined = _a.refined,
            extra = _a.extra;

        var metaRes = buildEventSourceMeta(refined, context);

        if (metaRes) {
          return {
            _raw: raw,
            isFetching: false,
            latestFetchId: '',
            fetchRange: null,
            defaultAllDay: refined.defaultAllDay,
            eventDataTransform: refined.eventDataTransform,
            success: refined.success,
            failure: refined.failure,
            publicId: refined.id || '',
            sourceId: guid(),
            sourceDefId: metaRes.sourceDefId,
            meta: metaRes.meta,
            ui: createEventUi(refined, context),
            extendedProps: extra
          };
        }
      }

      return null;
    }

    function buildEventSourceRefiners(context) {
      return __assign(__assign(__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
    }

    function buildEventSourceMeta(raw, context) {
      var defs = context.pluginHooks.eventSourceDefs;

      for (var i = defs.length - 1; i >= 0; i -= 1) {
        // later-added plugins take precedence
        var def = defs[i];
        var meta = def.parseMeta(raw);

        if (meta) {
          return {
            sourceDefId: i,
            meta: meta
          };
        }
      }

      return null;
    }

    function reduceCurrentDate(currentDate, action) {
      switch (action.type) {
        case 'CHANGE_DATE':
          return action.dateMarker;

        default:
          return currentDate;
      }
    }

    function getInitialDate(options, dateEnv) {
      var initialDateInput = options.initialDate; // compute the initial ambig-timezone date

      if (initialDateInput != null) {
        return dateEnv.createMarker(initialDateInput);
      }

      return getNow(options.now, dateEnv); // getNow already returns unzoned
    }

    function getNow(nowInput, dateEnv) {
      if (typeof nowInput === 'function') {
        nowInput = nowInput();
      }

      if (nowInput == null) {
        return dateEnv.createNowMarker();
      }

      return dateEnv.createMarker(nowInput);
    }

    var CalendarApi = function () {
      function CalendarApi() {}

      CalendarApi.prototype.getCurrentData = function () {
        return this.currentDataManager.getCurrentData();
      };

      CalendarApi.prototype.dispatch = function (action) {
        return this.currentDataManager.dispatch(action);
      };

      Object.defineProperty(CalendarApi.prototype, "view", {
        get: function () {
          return this.getCurrentData().viewApi;
        } // for public API
        ,
        enumerable: false,
        configurable: true
      });

      CalendarApi.prototype.batchRendering = function (callback) {
        callback();
      };

      CalendarApi.prototype.updateSize = function () {
        this.trigger('_resize', true);
      }; // Options
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.setOption = function (name, val) {
        this.dispatch({
          type: 'SET_OPTION',
          optionName: name,
          rawOptionValue: val
        });
      };

      CalendarApi.prototype.getOption = function (name) {
        return this.currentDataManager.currentCalendarOptionsInput[name];
      };

      CalendarApi.prototype.getAvailableLocaleCodes = function () {
        return Object.keys(this.getCurrentData().availableRawLocales);
      }; // Trigger
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.on = function (handlerName, handler) {
        var currentDataManager = this.currentDataManager;

        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
          currentDataManager.emitter.on(handlerName, handler);
        } else {
          console.warn("Unknown listener name '" + handlerName + "'");
        }
      };

      CalendarApi.prototype.off = function (handlerName, handler) {
        this.currentDataManager.emitter.off(handlerName, handler);
      }; // not meant for public use


      CalendarApi.prototype.trigger = function (handlerName) {
        var _a;

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        (_a = this.currentDataManager.emitter).trigger.apply(_a, __spreadArray([handlerName], args));
      }; // View
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.changeView = function (viewType, dateOrRange) {
        var _this = this;

        this.batchRendering(function () {
          _this.unselect();

          if (dateOrRange) {
            if (dateOrRange.start && dateOrRange.end) {
              // a range
              _this.dispatch({
                type: 'CHANGE_VIEW_TYPE',
                viewType: viewType
              });

              _this.dispatch({
                type: 'SET_OPTION',
                optionName: 'visibleRange',
                rawOptionValue: dateOrRange
              });
            } else {
              var dateEnv = _this.getCurrentData().dateEnv;

              _this.dispatch({
                type: 'CHANGE_VIEW_TYPE',
                viewType: viewType,
                dateMarker: dateEnv.createMarker(dateOrRange)
              });
            }
          } else {
            _this.dispatch({
              type: 'CHANGE_VIEW_TYPE',
              viewType: viewType
            });
          }
        });
      }; // Forces navigation to a view for the given date.
      // `viewType` can be a specific view name or a generic one like "week" or "day".
      // needs to change


      CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {
        var state = this.getCurrentData();
        var spec;
        viewType = viewType || 'day'; // day is default zoom

        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
        this.unselect();

        if (spec) {
          this.dispatch({
            type: 'CHANGE_VIEW_TYPE',
            viewType: spec.type,
            dateMarker: dateMarker
          });
        } else {
          this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: dateMarker
          });
        }
      }; // Given a duration singular unit, like "week" or "day", finds a matching view spec.
      // Preference is given to views that have corresponding buttons.


      CalendarApi.prototype.getUnitViewSpec = function (unit) {
        var _a = this.getCurrentData(),
            viewSpecs = _a.viewSpecs,
            toolbarConfig = _a.toolbarConfig;

        var viewTypes = [].concat(toolbarConfig.viewsWithButtons);
        var i;
        var spec;

        for (var viewType in viewSpecs) {
          viewTypes.push(viewType);
        }

        for (i = 0; i < viewTypes.length; i += 1) {
          spec = viewSpecs[viewTypes[i]];

          if (spec) {
            if (spec.singleUnit === unit) {
              return spec;
            }
          }
        }

        return null;
      }; // Current Date
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.prev = function () {
        this.unselect();
        this.dispatch({
          type: 'PREV'
        });
      };

      CalendarApi.prototype.next = function () {
        this.unselect();
        this.dispatch({
          type: 'NEXT'
        });
      };

      CalendarApi.prototype.prevYear = function () {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
          type: 'CHANGE_DATE',
          dateMarker: state.dateEnv.addYears(state.currentDate, -1)
        });
      };

      CalendarApi.prototype.nextYear = function () {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
          type: 'CHANGE_DATE',
          dateMarker: state.dateEnv.addYears(state.currentDate, 1)
        });
      };

      CalendarApi.prototype.today = function () {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
          type: 'CHANGE_DATE',
          dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
        });
      };

      CalendarApi.prototype.gotoDate = function (zonedDateInput) {
        var state = this.getCurrentData();
        this.unselect();
        this.dispatch({
          type: 'CHANGE_DATE',
          dateMarker: state.dateEnv.createMarker(zonedDateInput)
        });
      };

      CalendarApi.prototype.incrementDate = function (deltaInput) {
        var state = this.getCurrentData();
        var delta = createDuration(deltaInput);

        if (delta) {
          // else, warn about invalid input?
          this.unselect();
          this.dispatch({
            type: 'CHANGE_DATE',
            dateMarker: state.dateEnv.add(state.currentDate, delta)
          });
        }
      }; // for external API


      CalendarApi.prototype.getDate = function () {
        var state = this.getCurrentData();
        return state.dateEnv.toDate(state.currentDate);
      }; // Date Formatting Utils
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.formatDate = function (d, formatter) {
        var dateEnv = this.getCurrentData().dateEnv;
        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
      }; // `settings` is for formatter AND isEndExclusive


      CalendarApi.prototype.formatRange = function (d0, d1, settings) {
        var dateEnv = this.getCurrentData().dateEnv;
        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
      };

      CalendarApi.prototype.formatIso = function (d, omitTime) {
        var dateEnv = this.getCurrentData().dateEnv;
        return dateEnv.formatIso(dateEnv.createMarker(d), {
          omitTime: omitTime
        });
      }; // Date Selection / Event Selection / DayClick
      // -----------------------------------------------------------------------------------------------------------------
      // this public method receives start/end dates in any format, with any timezone
      // NOTE: args were changed from v3


      CalendarApi.prototype.select = function (dateOrObj, endDate) {
        var selectionInput;

        if (endDate == null) {
          if (dateOrObj.start != null) {
            selectionInput = dateOrObj;
          } else {
            selectionInput = {
              start: dateOrObj,
              end: null
            };
          }
        } else {
          selectionInput = {
            start: dateOrObj,
            end: endDate
          };
        }

        var state = this.getCurrentData();
        var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({
          days: 1
        }));

        if (selection) {
          // throw parse error otherwise?
          this.dispatch({
            type: 'SELECT_DATES',
            selection: selection
          });
          triggerDateSelect(selection, null, state);
        }
      }; // public method


      CalendarApi.prototype.unselect = function (pev) {
        var state = this.getCurrentData();

        if (state.dateSelection) {
          this.dispatch({
            type: 'UNSELECT_DATES'
          });
          triggerDateUnselect(pev, state);
        }
      }; // Public Events API
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {
        if (eventInput instanceof EventApi) {
          var def = eventInput._def;
          var instance = eventInput._instance;
          var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot

          if (!currentData.eventStore.defs[def.defId]) {
            this.dispatch({
              type: 'ADD_EVENTS',
              eventStore: eventTupleToStore({
                def: def,
                instance: instance
              }) // TODO: better util for two args?

            });
            this.triggerEventAdd(eventInput);
          }

          return eventInput;
        }

        var state = this.getCurrentData();
        var eventSource;

        if (sourceInput instanceof EventSourceApi) {
          eventSource = sourceInput.internalEventSource;
        } else if (typeof sourceInput === 'boolean') {
          if (sourceInput) {
            // true. part of the first event source
            eventSource = hashValuesToArray(state.eventSources)[0];
          }
        } else if (sourceInput != null) {
          // an ID. accepts a number too
          var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function

          if (!sourceApi) {
            console.warn("Could not find an event source with ID \"" + sourceInput + "\""); // TODO: test

            return null;
          }

          eventSource = sourceApi.internalEventSource;
        }

        var tuple = parseEvent(eventInput, eventSource, state, false);

        if (tuple) {
          var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
          this.dispatch({
            type: 'ADD_EVENTS',
            eventStore: eventTupleToStore(tuple)
          });
          this.triggerEventAdd(newEventApi);
          return newEventApi;
        }

        return null;
      };

      CalendarApi.prototype.triggerEventAdd = function (eventApi) {
        var _this = this;

        var emitter = this.getCurrentData().emitter;
        emitter.trigger('eventAdd', {
          event: eventApi,
          relatedEvents: [],
          revert: function () {
            _this.dispatch({
              type: 'REMOVE_EVENTS',
              eventStore: eventApiToStore(eventApi)
            });
          }
        });
      }; // TODO: optimize


      CalendarApi.prototype.getEventById = function (id) {
        var state = this.getCurrentData();
        var _a = state.eventStore,
            defs = _a.defs,
            instances = _a.instances;
        id = String(id);

        for (var defId in defs) {
          var def = defs[defId];

          if (def.publicId === id) {
            if (def.recurringDef) {
              return new EventApi(state, def, null);
            }

            for (var instanceId in instances) {
              var instance = instances[instanceId];

              if (instance.defId === def.defId) {
                return new EventApi(state, def, instance);
              }
            }
          }
        }

        return null;
      };

      CalendarApi.prototype.getEvents = function () {
        var currentData = this.getCurrentData();
        return buildEventApis(currentData.eventStore, currentData);
      };

      CalendarApi.prototype.removeAllEvents = function () {
        this.dispatch({
          type: 'REMOVE_ALL_EVENTS'
        });
      }; // Public Event Sources API
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.getEventSources = function () {
        var state = this.getCurrentData();
        var sourceHash = state.eventSources;
        var sourceApis = [];

        for (var internalId in sourceHash) {
          sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));
        }

        return sourceApis;
      };

      CalendarApi.prototype.getEventSourceById = function (id) {
        var state = this.getCurrentData();
        var sourceHash = state.eventSources;
        id = String(id);

        for (var sourceId in sourceHash) {
          if (sourceHash[sourceId].publicId === id) {
            return new EventSourceApi(state, sourceHash[sourceId]);
          }
        }

        return null;
      };

      CalendarApi.prototype.addEventSource = function (sourceInput) {
        var state = this.getCurrentData();

        if (sourceInput instanceof EventSourceApi) {
          // not already present? don't want to add an old snapshot
          if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
            this.dispatch({
              type: 'ADD_EVENT_SOURCES',
              sources: [sourceInput.internalEventSource]
            });
          }

          return sourceInput;
        }

        var eventSource = parseEventSource(sourceInput, state);

        if (eventSource) {
          // TODO: error otherwise?
          this.dispatch({
            type: 'ADD_EVENT_SOURCES',
            sources: [eventSource]
          });
          return new EventSourceApi(state, eventSource);
        }

        return null;
      };

      CalendarApi.prototype.removeAllEventSources = function () {
        this.dispatch({
          type: 'REMOVE_ALL_EVENT_SOURCES'
        });
      };

      CalendarApi.prototype.refetchEvents = function () {
        this.dispatch({
          type: 'FETCH_EVENT_SOURCES',
          isRefetch: true
        });
      }; // Scroll
      // -----------------------------------------------------------------------------------------------------------------


      CalendarApi.prototype.scrollToTime = function (timeInput) {
        var time = createDuration(timeInput);

        if (time) {
          this.trigger('_scrollRequest', {
            time: time
          });
        }
      };

      return CalendarApi;
    }();

    var EventApi = function () {
      // instance will be null if expressing a recurring event that has no current instances,
      // OR if trying to validate an incoming external event that has no dates assigned
      function EventApi(context, def, instance) {
        this._context = context;
        this._def = def;
        this._instance = instance || null;
      }
      /*
      TODO: make event struct more responsible for this
      */


      EventApi.prototype.setProp = function (name, val) {
        var _a, _b;

        if (name in EVENT_DATE_REFINERS) {
          console.warn('Could not set date-related prop \'name\'. Use one of the date-related methods instead.'); // TODO: make proper aliasing system?
        } else if (name === 'id') {
          val = EVENT_NON_DATE_REFINERS[name](val);
          this.mutate({
            standardProps: {
              publicId: val
            } // hardcoded internal name

          });
        } else if (name in EVENT_NON_DATE_REFINERS) {
          val = EVENT_NON_DATE_REFINERS[name](val);
          this.mutate({
            standardProps: (_a = {}, _a[name] = val, _a)
          });
        } else if (name in EVENT_UI_REFINERS) {
          var ui = EVENT_UI_REFINERS[name](val);

          if (name === 'color') {
            ui = {
              backgroundColor: val,
              borderColor: val
            };
          } else if (name === 'editable') {
            ui = {
              startEditable: val,
              durationEditable: val
            };
          } else {
            ui = (_b = {}, _b[name] = val, _b);
          }

          this.mutate({
            standardProps: {
              ui: ui
            }
          });
        } else {
          console.warn("Could not set prop '" + name + "'. Use setExtendedProp instead.");
        }
      };

      EventApi.prototype.setExtendedProp = function (name, val) {
        var _a;

        this.mutate({
          extendedProps: (_a = {}, _a[name] = val, _a)
        });
      };

      EventApi.prototype.setStart = function (startInput, options) {
        if (options === void 0) {
          options = {};
        }

        var dateEnv = this._context.dateEnv;
        var start = dateEnv.createMarker(startInput);

        if (start && this._instance) {
          // TODO: warning if parsed bad
          var instanceRange = this._instance.range;
          var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?

          if (options.maintainDuration) {
            this.mutate({
              datesDelta: startDelta
            });
          } else {
            this.mutate({
              startDelta: startDelta
            });
          }
        }
      };

      EventApi.prototype.setEnd = function (endInput, options) {
        if (options === void 0) {
          options = {};
        }

        var dateEnv = this._context.dateEnv;
        var end;

        if (endInput != null) {
          end = dateEnv.createMarker(endInput);

          if (!end) {
            return; // TODO: warning if parsed bad
          }
        }

        if (this._instance) {
          if (end) {
            var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
            this.mutate({
              endDelta: endDelta
            });
          } else {
            this.mutate({
              standardProps: {
                hasEnd: false
              }
            });
          }
        }
      };

      EventApi.prototype.setDates = function (startInput, endInput, options) {
        if (options === void 0) {
          options = {};
        }

        var dateEnv = this._context.dateEnv;
        var standardProps = {
          allDay: options.allDay
        };
        var start = dateEnv.createMarker(startInput);
        var end;

        if (!start) {
          return; // TODO: warning if parsed bad
        }

        if (endInput != null) {
          end = dateEnv.createMarker(endInput);

          if (!end) {
            // TODO: warning if parsed bad
            return;
          }
        }

        if (this._instance) {
          var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,
          // compute diff off of the all-day values the way event-mutation does.

          if (options.allDay === true) {
            instanceRange = computeAlignedDayRange(instanceRange);
          }

          var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);

          if (end) {
            var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);

            if (durationsEqual(startDelta, endDelta)) {
              this.mutate({
                datesDelta: startDelta,
                standardProps: standardProps
              });
            } else {
              this.mutate({
                startDelta: startDelta,
                endDelta: endDelta,
                standardProps: standardProps
              });
            }
          } else {
            // means "clear the end"
            standardProps.hasEnd = false;
            this.mutate({
              datesDelta: startDelta,
              standardProps: standardProps
            });
          }
        }
      };

      EventApi.prototype.moveStart = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // TODO: warning if parsed bad
          this.mutate({
            startDelta: delta
          });
        }
      };

      EventApi.prototype.moveEnd = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // TODO: warning if parsed bad
          this.mutate({
            endDelta: delta
          });
        }
      };

      EventApi.prototype.moveDates = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // TODO: warning if parsed bad
          this.mutate({
            datesDelta: delta
          });
        }
      };

      EventApi.prototype.setAllDay = function (allDay, options) {
        if (options === void 0) {
          options = {};
        }

        var standardProps = {
          allDay: allDay
        };
        var maintainDuration = options.maintainDuration;

        if (maintainDuration == null) {
          maintainDuration = this._context.options.allDayMaintainDuration;
        }

        if (this._def.allDay !== allDay) {
          standardProps.hasEnd = maintainDuration;
        }

        this.mutate({
          standardProps: standardProps
        });
      };

      EventApi.prototype.formatRange = function (formatInput) {
        var dateEnv = this._context.dateEnv;
        var instance = this._instance;
        var formatter = createFormatter(formatInput);

        if (this._def.hasEnd) {
          return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
            forcedStartTzo: instance.forcedStartTzo,
            forcedEndTzo: instance.forcedEndTzo
          });
        }

        return dateEnv.format(instance.range.start, formatter, {
          forcedTzo: instance.forcedStartTzo
        });
      };

      EventApi.prototype.mutate = function (mutation) {
        var instance = this._instance;

        if (instance) {
          var def = this._def;
          var context_1 = this._context;
          var eventStore_1 = context_1.getCurrentData().eventStore;
          var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);
          var eventConfigBase = {
            '': {
              display: '',
              startEditable: true,
              durationEditable: true,
              constraints: [],
              overlap: null,
              allows: [],
              backgroundColor: '',
              borderColor: '',
              textColor: '',
              classNames: []
            }
          };
          relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);
          var oldEvent = new EventApi(context_1, def, instance); // snapshot

          this._def = relevantEvents.defs[def.defId];
          this._instance = relevantEvents.instances[instance.instanceId];
          context_1.dispatch({
            type: 'MERGE_EVENTS',
            eventStore: relevantEvents
          });
          context_1.emitter.trigger('eventChange', {
            oldEvent: oldEvent,
            event: this,
            relatedEvents: buildEventApis(relevantEvents, context_1, instance),
            revert: function () {
              context_1.dispatch({
                type: 'RESET_EVENTS',
                eventStore: eventStore_1
              });
            }
          });
        }
      };

      EventApi.prototype.remove = function () {
        var context = this._context;
        var asStore = eventApiToStore(this);
        context.dispatch({
          type: 'REMOVE_EVENTS',
          eventStore: asStore
        });
        context.emitter.trigger('eventRemove', {
          event: this,
          relatedEvents: [],
          revert: function () {
            context.dispatch({
              type: 'MERGE_EVENTS',
              eventStore: asStore
            });
          }
        });
      };

      Object.defineProperty(EventApi.prototype, "source", {
        get: function () {
          var sourceId = this._def.sourceId;

          if (sourceId) {
            return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);
          }

          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "start", {
        get: function () {
          return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "end", {
        get: function () {
          return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "startStr", {
        get: function () {
          var instance = this._instance;

          if (instance) {
            return this._context.dateEnv.formatIso(instance.range.start, {
              omitTime: this._def.allDay,
              forcedTzo: instance.forcedStartTzo
            });
          }

          return '';
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "endStr", {
        get: function () {
          var instance = this._instance;

          if (instance && this._def.hasEnd) {
            return this._context.dateEnv.formatIso(instance.range.end, {
              omitTime: this._def.allDay,
              forcedTzo: instance.forcedEndTzo
            });
          }

          return '';
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "id", {
        // computable props that all access the def
        // TODO: find a TypeScript-compatible way to do this at scale
        get: function () {
          return this._def.publicId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "groupId", {
        get: function () {
          return this._def.groupId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "allDay", {
        get: function () {
          return this._def.allDay;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "title", {
        get: function () {
          return this._def.title;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "url", {
        get: function () {
          return this._def.url;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "display", {
        get: function () {
          return this._def.ui.display || 'auto';
        } // bad. just normalize the type earlier
        ,
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "startEditable", {
        get: function () {
          return this._def.ui.startEditable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "durationEditable", {
        get: function () {
          return this._def.ui.durationEditable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "constraint", {
        get: function () {
          return this._def.ui.constraints[0] || null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "overlap", {
        get: function () {
          return this._def.ui.overlap;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "allow", {
        get: function () {
          return this._def.ui.allows[0] || null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "backgroundColor", {
        get: function () {
          return this._def.ui.backgroundColor;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "borderColor", {
        get: function () {
          return this._def.ui.borderColor;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "textColor", {
        get: function () {
          return this._def.ui.textColor;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "classNames", {
        // NOTE: user can't modify these because Object.freeze was called in event-def parsing
        get: function () {
          return this._def.ui.classNames;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "extendedProps", {
        get: function () {
          return this._def.extendedProps;
        },
        enumerable: false,
        configurable: true
      });

      EventApi.prototype.toPlainObject = function (settings) {
        if (settings === void 0) {
          settings = {};
        }

        var def = this._def;
        var ui = def.ui;

        var _a = this,
            startStr = _a.startStr,
            endStr = _a.endStr;

        var res = {};

        if (def.title) {
          res.title = def.title;
        }

        if (startStr) {
          res.start = startStr;
        }

        if (endStr) {
          res.end = endStr;
        }

        if (def.publicId) {
          res.id = def.publicId;
        }

        if (def.groupId) {
          res.groupId = def.groupId;
        }

        if (def.url) {
          res.url = def.url;
        }

        if (ui.display && ui.display !== 'auto') {
          res.display = ui.display;
        } // TODO: what about recurring-event properties???
        // TODO: include startEditable/durationEditable/constraint/overlap/allow


        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
          res.color = ui.backgroundColor;
        } else {
          if (ui.backgroundColor) {
            res.backgroundColor = ui.backgroundColor;
          }

          if (ui.borderColor) {
            res.borderColor = ui.borderColor;
          }
        }

        if (ui.textColor) {
          res.textColor = ui.textColor;
        }

        if (ui.classNames.length) {
          res.classNames = ui.classNames;
        }

        if (Object.keys(def.extendedProps).length) {
          if (settings.collapseExtendedProps) {
            __assign(res, def.extendedProps);
          } else {
            res.extendedProps = def.extendedProps;
          }
        }

        return res;
      };

      EventApi.prototype.toJSON = function () {
        return this.toPlainObject();
      };

      return EventApi;
    }();

    function eventApiToStore(eventApi) {
      var _a, _b;

      var def = eventApi._def;
      var instance = eventApi._instance;
      return {
        defs: (_a = {}, _a[def.defId] = def, _a),
        instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}
      };
    }

    function buildEventApis(eventStore, context, excludeInstance) {
      var defs = eventStore.defs,
          instances = eventStore.instances;
      var eventApis = [];
      var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';

      for (var id in instances) {
        var instance = instances[id];
        var def = defs[instance.defId];

        if (instance.instanceId !== excludeInstanceId) {
          eventApis.push(new EventApi(context, def, instance));
        }
      }

      return eventApis;
    }

    var calendarSystemClassMap = {};

    function registerCalendarSystem(name, theClass) {
      calendarSystemClassMap[name] = theClass;
    }

    function createCalendarSystem(name) {
      return new calendarSystemClassMap[name]();
    }

    var GregorianCalendarSystem = function () {
      function GregorianCalendarSystem() {}

      GregorianCalendarSystem.prototype.getMarkerYear = function (d) {
        return d.getUTCFullYear();
      };

      GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {
        return d.getUTCMonth();
      };

      GregorianCalendarSystem.prototype.getMarkerDay = function (d) {
        return d.getUTCDate();
      };

      GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {
        return arrayToUtcDate(arr);
      };

      GregorianCalendarSystem.prototype.markerToArray = function (marker) {
        return dateToUtcArray(marker);
      };

      return GregorianCalendarSystem;
    }();

    registerCalendarSystem('gregory', GregorianCalendarSystem);
    var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;

    function parse(str) {
      var m = ISO_RE.exec(str);

      if (m) {
        var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number("0." + m[12]) * 1000 : 0));

        if (isValidDate(marker)) {
          var timeZoneOffset = null;

          if (m[13]) {
            timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));
          }

          return {
            marker: marker,
            isTimeUnspecified: !m[6],
            timeZoneOffset: timeZoneOffset
          };
        }
      }

      return null;
    }

    var DateEnv = function () {
      function DateEnv(settings) {
        var timeZone = this.timeZone = settings.timeZone;
        var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';

        if (settings.namedTimeZoneImpl && isNamedTimeZone) {
          this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
        }

        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
        this.calendarSystem = createCalendarSystem(settings.calendarSystem);
        this.locale = settings.locale;
        this.weekDow = settings.locale.week.dow;
        this.weekDoy = settings.locale.week.doy;

        if (settings.weekNumberCalculation === 'ISO') {
          this.weekDow = 1;
          this.weekDoy = 4;
        }

        if (typeof settings.firstDay === 'number') {
          this.weekDow = settings.firstDay;
        }

        if (typeof settings.weekNumberCalculation === 'function') {
          this.weekNumberFunc = settings.weekNumberCalculation;
        }

        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
        this.cmdFormatter = settings.cmdFormatter;
        this.defaultSeparator = settings.defaultSeparator;
      } // Creating / Parsing


      DateEnv.prototype.createMarker = function (input) {
        var meta = this.createMarkerMeta(input);

        if (meta === null) {
          return null;
        }

        return meta.marker;
      };

      DateEnv.prototype.createNowMarker = function () {
        if (this.canComputeOffset) {
          return this.timestampToMarker(new Date().valueOf());
        } // if we can't compute the current date val for a timezone,
        // better to give the current local date vals than UTC


        return arrayToUtcDate(dateToLocalArray(new Date()));
      };

      DateEnv.prototype.createMarkerMeta = function (input) {
        if (typeof input === 'string') {
          return this.parse(input);
        }

        var marker = null;

        if (typeof input === 'number') {
          marker = this.timestampToMarker(input);
        } else if (input instanceof Date) {
          input = input.valueOf();

          if (!isNaN(input)) {
            marker = this.timestampToMarker(input);
          }
        } else if (Array.isArray(input)) {
          marker = arrayToUtcDate(input);
        }

        if (marker === null || !isValidDate(marker)) {
          return null;
        }

        return {
          marker: marker,
          isTimeUnspecified: false,
          forcedTzo: null
        };
      };

      DateEnv.prototype.parse = function (s) {
        var parts = parse(s);

        if (parts === null) {
          return null;
        }

        var marker = parts.marker;
        var forcedTzo = null;

        if (parts.timeZoneOffset !== null) {
          if (this.canComputeOffset) {
            marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
          } else {
            forcedTzo = parts.timeZoneOffset;
          }
        }

        return {
          marker: marker,
          isTimeUnspecified: parts.isTimeUnspecified,
          forcedTzo: forcedTzo
        };
      }; // Accessors


      DateEnv.prototype.getYear = function (marker) {
        return this.calendarSystem.getMarkerYear(marker);
      };

      DateEnv.prototype.getMonth = function (marker) {
        return this.calendarSystem.getMarkerMonth(marker);
      }; // Adding / Subtracting


      DateEnv.prototype.add = function (marker, dur) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] += dur.years;
        a[1] += dur.months;
        a[2] += dur.days;
        a[6] += dur.milliseconds;
        return this.calendarSystem.arrayToMarker(a);
      };

      DateEnv.prototype.subtract = function (marker, dur) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] -= dur.years;
        a[1] -= dur.months;
        a[2] -= dur.days;
        a[6] -= dur.milliseconds;
        return this.calendarSystem.arrayToMarker(a);
      };

      DateEnv.prototype.addYears = function (marker, n) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] += n;
        return this.calendarSystem.arrayToMarker(a);
      };

      DateEnv.prototype.addMonths = function (marker, n) {
        var a = this.calendarSystem.markerToArray(marker);
        a[1] += n;
        return this.calendarSystem.arrayToMarker(a);
      }; // Diffing Whole Units


      DateEnv.prototype.diffWholeYears = function (m0, m1) {
        var calendarSystem = this.calendarSystem;

        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
          return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
        }

        return null;
      };

      DateEnv.prototype.diffWholeMonths = function (m0, m1) {
        var calendarSystem = this.calendarSystem;

        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
          return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
        }

        return null;
      }; // Range / Duration


      DateEnv.prototype.greatestWholeUnit = function (m0, m1) {
        var n = this.diffWholeYears(m0, m1);

        if (n !== null) {
          return {
            unit: 'year',
            value: n
          };
        }

        n = this.diffWholeMonths(m0, m1);

        if (n !== null) {
          return {
            unit: 'month',
            value: n
          };
        }

        n = diffWholeWeeks(m0, m1);

        if (n !== null) {
          return {
            unit: 'week',
            value: n
          };
        }

        n = diffWholeDays(m0, m1);

        if (n !== null) {
          return {
            unit: 'day',
            value: n
          };
        }

        n = diffHours(m0, m1);

        if (isInt(n)) {
          return {
            unit: 'hour',
            value: n
          };
        }

        n = diffMinutes(m0, m1);

        if (isInt(n)) {
          return {
            unit: 'minute',
            value: n
          };
        }

        n = diffSeconds(m0, m1);

        if (isInt(n)) {
          return {
            unit: 'second',
            value: n
          };
        }

        return {
          unit: 'millisecond',
          value: m1.valueOf() - m0.valueOf()
        };
      };

      DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {
        // TODO: can use greatestWholeUnit
        var diff;

        if (d.years) {
          diff = this.diffWholeYears(m0, m1);

          if (diff !== null) {
            return diff / asRoughYears(d);
          }
        }

        if (d.months) {
          diff = this.diffWholeMonths(m0, m1);

          if (diff !== null) {
            return diff / asRoughMonths(d);
          }
        }

        if (d.days) {
          diff = diffWholeDays(m0, m1);

          if (diff !== null) {
            return diff / asRoughDays(d);
          }
        }

        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
      }; // Start-Of
      // these DON'T return zoned-dates. only UTC start-of dates


      DateEnv.prototype.startOf = function (m, unit) {
        if (unit === 'year') {
          return this.startOfYear(m);
        }

        if (unit === 'month') {
          return this.startOfMonth(m);
        }

        if (unit === 'week') {
          return this.startOfWeek(m);
        }

        if (unit === 'day') {
          return startOfDay(m);
        }

        if (unit === 'hour') {
          return startOfHour(m);
        }

        if (unit === 'minute') {
          return startOfMinute(m);
        }

        if (unit === 'second') {
          return startOfSecond(m);
        }

        return null;
      };

      DateEnv.prototype.startOfYear = function (m) {
        return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);
      };

      DateEnv.prototype.startOfMonth = function (m) {
        return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);
      };

      DateEnv.prototype.startOfWeek = function (m) {
        return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);
      }; // Week Number


      DateEnv.prototype.computeWeekNumber = function (marker) {
        if (this.weekNumberFunc) {
          return this.weekNumberFunc(this.toDate(marker));
        }

        return weekOfYear(marker, this.weekDow, this.weekDoy);
      }; // TODO: choke on timeZoneName: long


      DateEnv.prototype.format = function (marker, formatter, dateOptions) {
        if (dateOptions === void 0) {
          dateOptions = {};
        }

        return formatter.format({
          marker: marker,
          timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
        }, this);
      };

      DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {
        if (dateOptions === void 0) {
          dateOptions = {};
        }

        if (dateOptions.isEndExclusive) {
          end = addMs(end, -1);
        }

        return formatter.formatRange({
          marker: start,
          timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
        }, {
          marker: end,
          timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
        }, this, dateOptions.defaultSeparator);
      };
      /*
      DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
      might as well use buildIsoString or some other util directly
      */


      DateEnv.prototype.formatIso = function (marker, extraOptions) {
        if (extraOptions === void 0) {
          extraOptions = {};
        }

        var timeZoneOffset = null;

        if (!extraOptions.omitTimeZoneOffset) {
          if (extraOptions.forcedTzo != null) {
            timeZoneOffset = extraOptions.forcedTzo;
          } else {
            timeZoneOffset = this.offsetForMarker(marker);
          }
        }

        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
      }; // TimeZone


      DateEnv.prototype.timestampToMarker = function (ms) {
        if (this.timeZone === 'local') {
          return arrayToUtcDate(dateToLocalArray(new Date(ms)));
        }

        if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
          return new Date(ms);
        }

        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
      };

      DateEnv.prototype.offsetForMarker = function (m) {
        if (this.timeZone === 'local') {
          return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
        }

        if (this.timeZone === 'UTC') {
          return 0;
        }

        if (this.namedTimeZoneImpl) {
          return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
        }

        return null;
      }; // Conversion


      DateEnv.prototype.toDate = function (m, forcedTzo) {
        if (this.timeZone === 'local') {
          return arrayToLocalDate(dateToUtcArray(m));
        }

        if (this.timeZone === 'UTC') {
          return new Date(m.valueOf()); // make sure it's a copy
        }

        if (!this.namedTimeZoneImpl) {
          return new Date(m.valueOf() - (forcedTzo || 0));
        }

        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);
      };

      return DateEnv;
    }();

    var globalLocales = [];
    var RAW_EN_LOCALE = {
      code: 'en',
      week: {
        dow: 0,
        doy: 4 // 4 days need to be within the year to be considered the first week

      },
      direction: 'ltr',
      buttonText: {
        prev: 'prev',
        next: 'next',
        prevYear: 'prev year',
        nextYear: 'next year',
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day',
        list: 'list'
      },
      weekText: 'W',
      allDayText: 'all-day',
      moreLinkText: 'more',
      noEventsText: 'No events to display'
    };

    function organizeRawLocales(explicitRawLocales) {
      var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
      var allRawLocales = globalLocales.concat(explicitRawLocales);
      var rawLocaleMap = {
        en: RAW_EN_LOCALE // necessary?

      };

      for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {
        var rawLocale = allRawLocales_1[_i];
        rawLocaleMap[rawLocale.code] = rawLocale;
      }

      return {
        map: rawLocaleMap,
        defaultCode: defaultCode
      };
    }

    function buildLocale(inputSingular, available) {
      if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {
        return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
      }

      return queryLocale(inputSingular, available);
    }

    function queryLocale(codeArg, available) {
      var codes = [].concat(codeArg || []); // will convert to array

      var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
      return parseLocale(codeArg, codes, raw);
    }

    function queryRawLocale(codes, available) {
      for (var i = 0; i < codes.length; i += 1) {
        var parts = codes[i].toLocaleLowerCase().split('-');

        for (var j = parts.length; j > 0; j -= 1) {
          var simpleId = parts.slice(0, j).join('-');

          if (available[simpleId]) {
            return available[simpleId];
          }
        }
      }

      return null;
    }

    function parseLocale(codeArg, codes, raw) {
      var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);
      delete merged.code; // don't want this part of the options

      var week = merged.week;
      delete merged.week;
      return {
        codeArg: codeArg,
        codes: codes,
        week: week,
        simpleNumberFormat: new Intl.NumberFormat(codeArg),
        options: merged
      };
    }

    var DEF_DEFAULTS = {
      startTime: '09:00',
      endTime: '17:00',
      daysOfWeek: [1, 2, 3, 4, 5],
      display: 'inverse-background',
      classNames: 'fc-non-business',
      groupId: '_businessHours' // so multiple defs get grouped

    };
    /*
    TODO: pass around as EventDefHash!!!
    */

    function parseBusinessHours(input, context) {
      return parseEvents(refineInputs(input), null, context);
    }

    function refineInputs(input) {
      var rawDefs;

      if (input === true) {
        rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
      } else if (Array.isArray(input)) {
        // if specifying an array, every sub-definition NEEDS a day-of-week
        rawDefs = input.filter(function (rawDef) {
          return rawDef.daysOfWeek;
        });
      } else if (typeof input === 'object' && input) {
        // non-null object
        rawDefs = [input];
      } else {
        // is probably false
        rawDefs = [];
      }

      rawDefs = rawDefs.map(function (rawDef) {
        return __assign(__assign({}, DEF_DEFAULTS), rawDef);
      });
      return rawDefs;
    }


    function intersectRects(rect1, rect2) {
      var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
      };

      if (res.left < res.right && res.top < res.bottom) {
        return res;
      }

      return false;
    }

    var canVGrowWithinCell;

    function getCanVGrowWithinCell() {
      if (canVGrowWithinCell == null) {
        canVGrowWithinCell = computeCanVGrowWithinCell();
      }

      return canVGrowWithinCell;
    }

    function computeCanVGrowWithinCell() {
      // for SSR, because this function is call immediately at top-level
      // TODO: just make this logic execute top-level, immediately, instead of doing lazily
      if (typeof document === 'undefined') {
        return true;
      }

      var el = document.createElement('div');
      el.style.position = 'absolute';
      el.style.top = '0px';
      el.style.left = '0px';
      el.innerHTML = '<table><tr><td><div></div></td></tr></table>';
      el.querySelector('table').style.height = '100px';
      el.querySelector('div').style.height = '100%';
      document.body.appendChild(el);
      var div = el.querySelector('div');
      var possible = div.offsetHeight > 0;
      document.body.removeChild(el);
      return possible;
    }

    function getDateMeta(date, todayRange, nowDate, dateProfile) {
      return {
        dow: date.getUTCDay(),
        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
      };
    }

    function getDayClassNames(meta, theme) {
      var classNames = ['fc-day', "fc-day-" + DAY_IDS[meta.dow]];

      if (meta.isDisabled) {
        classNames.push('fc-day-disabled');
      } else {
        if (meta.isToday) {
          classNames.push('fc-day-today');
          classNames.push(theme.getClass('today'));
        }

        if (meta.isPast) {
          classNames.push('fc-day-past');
        }

        if (meta.isFuture) {
          classNames.push('fc-day-future');
        }

        if (meta.isOther) {
          classNames.push('fc-day-other');
        }
      }

      return classNames;
    }

    function buildNavLinkData(date, type) {
      if (type === void 0) {
        type = 'day';
      }

      return JSON.stringify({
        date: formatDayString(date),
        type: type
      });
    }

    var _scrollbarWidths;

    function getScrollbarWidths() {
      if (!_scrollbarWidths) {
        _scrollbarWidths = computeScrollbarWidths();
      }

      return _scrollbarWidths;
    }

    function computeScrollbarWidths() {
      var el = document.createElement('div');
      el.style.overflow = 'scroll';
      el.style.position = 'absolute';
      el.style.top = '-9999px';
      el.style.left = '-9999px';
      document.body.appendChild(el);
      var res = computeScrollbarWidthsForEl(el);
      document.body.removeChild(el);
      return res;
    } // WARNING: will include border


    function computeScrollbarWidthsForEl(el) {
      return {
        x: el.offsetHeight - el.clientHeight,
        y: el.offsetWidth - el.clientWidth
      };
    }

    function computeClippedClientRect(el) {
      var clippingParents = getClippingParents(el);
      var rect = el.getBoundingClientRect();

      for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {
        var clippingParent = clippingParents_1[_i];
        var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());

        if (intersection) {
          rect = intersection;
        } else {
          return null;
        }
      }

      return rect;
    }


    function getClippingParents(el) {
      var parents = [];

      while (el instanceof HTMLElement) {
        // will stop when gets to document or null
        var computedStyle = window.getComputedStyle(el);

        if (computedStyle.position === 'fixed') {
          break;
        }

        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
          parents.push(el);
        }

        el = el.parentNode;
      }

      return parents;
    } // given a function that resolves a result asynchronously.
    // the function can either call passed-in success and failure callbacks,
    // or it can return a promise.
    // if you need to pass additional params to func, bind them first.


    function unpromisify(func, success, failure) {
      // guard against success/failure callbacks being called more than once
      // and guard against a promise AND callback being used together.
      var isResolved = false;

      var wrappedSuccess = function () {
        if (!isResolved) {
          isResolved = true;
          success.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }
      };

      var wrappedFailure = function () {
        if (!isResolved) {
          isResolved = true;

          if (failure) {
            failure.apply(this, arguments); // eslint-disable-line prefer-rest-params
          }
        }
      };

      var res = func(wrappedSuccess, wrappedFailure);

      if (res && typeof res.then === 'function') {
        res.then(wrappedSuccess, wrappedFailure);
      }
    }

    var Emitter = function () {
      function Emitter() {
        this.handlers = {};
        this.thisContext = null;
      }

      Emitter.prototype.setThisContext = function (thisContext) {
        this.thisContext = thisContext;
      };

      Emitter.prototype.setOptions = function (options) {
        this.options = options;
      };

      Emitter.prototype.on = function (type, handler) {
        addToHash(this.handlers, type, handler);
      };

      Emitter.prototype.off = function (type, handler) {
        removeFromHash(this.handlers, type, handler);
      };

      Emitter.prototype.trigger = function (type) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var attachedHandlers = this.handlers[type] || [];
        var optionHandler = this.options && this.options[type];
        var handlers = [].concat(optionHandler || [], attachedHandlers);

        for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {
          var handler = handlers_1[_a];
          handler.apply(this.thisContext, args);
        }
      };

      Emitter.prototype.hasHandlers = function (type) {
        return this.handlers[type] && this.handlers[type].length || this.options && this.options[type];
      };

      return Emitter;
    }();

    function addToHash(hash, type, handler) {
      (hash[type] || (hash[type] = [])).push(handler);
    }

    function removeFromHash(hash, type, handler) {
      if (handler) {
        if (hash[type]) {
          hash[type] = hash[type].filter(function (func) {
            return func !== handler;
          });
        }
      } else {
        delete hash[type]; // remove all handler funcs for this type
      }
    }
    /*
    Records offset information for a set of elements, relative to an origin element.
    Can record the left/right OR the top/bottom OR both.
    Provides methods for querying the cache by position.
    */


    var PositionCache = function () {
      function PositionCache(originEl, els, isHorizontal, isVertical) {
        this.els = els;
        var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left

        if (isHorizontal) {
          this.buildElHorizontals(originClientRect.left);
        }

        if (isVertical) {
          this.buildElVerticals(originClientRect.top);
        }
      } // Populates the left/right internal coordinate arrays


      PositionCache.prototype.buildElHorizontals = function (originClientLeft) {
        var lefts = [];
        var rights = [];

        for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
          var el = _a[_i];
          var rect = el.getBoundingClientRect();
          lefts.push(rect.left - originClientLeft);
          rights.push(rect.right - originClientLeft);
        }

        this.lefts = lefts;
        this.rights = rights;
      }; // Populates the top/bottom internal coordinate arrays


      PositionCache.prototype.buildElVerticals = function (originClientTop) {
        var tops = [];
        var bottoms = [];

        for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
          var el = _a[_i];
          var rect = el.getBoundingClientRect();
          tops.push(rect.top - originClientTop);
          bottoms.push(rect.bottom - originClientTop);
        }

        this.tops = tops;
        this.bottoms = bottoms;
      }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
      // If no intersection is made, returns undefined.


      PositionCache.prototype.leftToIndex = function (leftPosition) {
        var _a = this,
            lefts = _a.lefts,
            rights = _a.rights;

        var len = lefts.length;
        var i;

        for (i = 0; i < len; i += 1) {
          if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
            return i;
          }
        }

        return undefined; // TODO: better
      }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.
      // If no intersection is made, returns undefined.


      PositionCache.prototype.topToIndex = function (topPosition) {
        var _a = this,
            tops = _a.tops,
            bottoms = _a.bottoms;

        var len = tops.length;
        var i;

        for (i = 0; i < len; i += 1) {
          if (topPosition >= tops[i] && topPosition < bottoms[i]) {
            return i;
          }
        }

        return undefined; // TODO: better
      }; // Gets the width of the element at the given index


      PositionCache.prototype.getWidth = function (leftIndex) {
        return this.rights[leftIndex] - this.lefts[leftIndex];
      }; // Gets the height of the element at the given index


      PositionCache.prototype.getHeight = function (topIndex) {
        return this.bottoms[topIndex] - this.tops[topIndex];
      };

      return PositionCache;
    }();
    /* eslint max-classes-per-file: "off" */

    /*
    An object for getting/setting scroll-related information for an element.
    Internally, this is done very differently for window versus DOM element,
    so this object serves as a common interface.
    */


    var ScrollController = function () {
      function ScrollController() {}

      ScrollController.prototype.getMaxScrollTop = function () {
        return this.getScrollHeight() - this.getClientHeight();
      };

      ScrollController.prototype.getMaxScrollLeft = function () {
        return this.getScrollWidth() - this.getClientWidth();
      };

      ScrollController.prototype.canScrollVertically = function () {
        return this.getMaxScrollTop() > 0;
      };

      ScrollController.prototype.canScrollHorizontally = function () {
        return this.getMaxScrollLeft() > 0;
      };

      ScrollController.prototype.canScrollUp = function () {
        return this.getScrollTop() > 0;
      };

      ScrollController.prototype.canScrollDown = function () {
        return this.getScrollTop() < this.getMaxScrollTop();
      };

      ScrollController.prototype.canScrollLeft = function () {
        return this.getScrollLeft() > 0;
      };

      ScrollController.prototype.canScrollRight = function () {
        return this.getScrollLeft() < this.getMaxScrollLeft();
      };

      return ScrollController;
    }();

    (function (_super) {
      __extends(ElementScrollController, _super);

      function ElementScrollController(el) {
        var _this = _super.call(this) || this;

        _this.el = el;
        return _this;
      }

      ElementScrollController.prototype.getScrollTop = function () {
        return this.el.scrollTop;
      };

      ElementScrollController.prototype.getScrollLeft = function () {
        return this.el.scrollLeft;
      };

      ElementScrollController.prototype.setScrollTop = function (top) {
        this.el.scrollTop = top;
      };

      ElementScrollController.prototype.setScrollLeft = function (left) {
        this.el.scrollLeft = left;
      };

      ElementScrollController.prototype.getScrollWidth = function () {
        return this.el.scrollWidth;
      };

      ElementScrollController.prototype.getScrollHeight = function () {
        return this.el.scrollHeight;
      };

      ElementScrollController.prototype.getClientHeight = function () {
        return this.el.clientHeight;
      };

      ElementScrollController.prototype.getClientWidth = function () {
        return this.el.clientWidth;
      };

      return ElementScrollController;
    })(ScrollController);

    (function (_super) {
      __extends(WindowScrollController, _super);

      function WindowScrollController() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      WindowScrollController.prototype.getScrollTop = function () {
        return window.pageYOffset;
      };

      WindowScrollController.prototype.getScrollLeft = function () {
        return window.pageXOffset;
      };

      WindowScrollController.prototype.setScrollTop = function (n) {
        window.scroll(window.pageXOffset, n);
      };

      WindowScrollController.prototype.setScrollLeft = function (n) {
        window.scroll(n, window.pageYOffset);
      };

      WindowScrollController.prototype.getScrollWidth = function () {
        return document.documentElement.scrollWidth;
      };

      WindowScrollController.prototype.getScrollHeight = function () {
        return document.documentElement.scrollHeight;
      };

      WindowScrollController.prototype.getClientHeight = function () {
        return document.documentElement.clientHeight;
      };

      WindowScrollController.prototype.getClientWidth = function () {
        return document.documentElement.clientWidth;
      };

      return WindowScrollController;
    })(ScrollController);

    var Theme = function () {
      function Theme(calendarOptions) {
        if (this.iconOverrideOption) {
          this.setIconOverride(calendarOptions[this.iconOverrideOption]);
        }
      }

      Theme.prototype.setIconOverride = function (iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;

        if (typeof iconOverrideHash === 'object' && iconOverrideHash) {
          // non-null object
          iconClassesCopy = __assign({}, this.iconClasses);

          for (buttonName in iconOverrideHash) {
            iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
          }

          this.iconClasses = iconClassesCopy;
        } else if (iconOverrideHash === false) {
          this.iconClasses = {};
        }
      };

      Theme.prototype.applyIconOverridePrefix = function (className) {
        var prefix = this.iconOverridePrefix;

        if (prefix && className.indexOf(prefix) !== 0) {
          // if not already present
          className = prefix + className;
        }

        return className;
      };

      Theme.prototype.getClass = function (key) {
        return this.classes[key] || '';
      };

      Theme.prototype.getIconClass = function (buttonName, isRtl) {
        var className;

        if (isRtl && this.rtlIconClasses) {
          className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
        } else {
          className = this.iconClasses[buttonName];
        }

        if (className) {
          return this.baseIconClass + " " + className;
        }

        return '';
      };

      Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
        var className;

        if (this.iconOverrideCustomButtonOption) {
          className = customButtonProps[this.iconOverrideCustomButtonOption];

          if (className) {
            return this.baseIconClass + " " + this.applyIconOverridePrefix(className);
          }
        }

        return '';
      };

      return Theme;
    }();

    Theme.prototype.classes = {};
    Theme.prototype.iconClasses = {};
    Theme.prototype.baseIconClass = '';
    Theme.prototype.iconOverridePrefix = '';

    var ScrollResponder = function () {
      function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {
        var _this = this;

        this.execFunc = execFunc;
        this.emitter = emitter;
        this.scrollTime = scrollTime;
        this.scrollTimeReset = scrollTimeReset;

        this.handleScrollRequest = function (request) {
          _this.queuedRequest = __assign({}, _this.queuedRequest || {}, request);

          _this.drain();
        };

        emitter.on('_scrollRequest', this.handleScrollRequest);
        this.fireInitialScroll();
      }

      ScrollResponder.prototype.detach = function () {
        this.emitter.off('_scrollRequest', this.handleScrollRequest);
      };

      ScrollResponder.prototype.update = function (isDatesNew) {
        if (isDatesNew && this.scrollTimeReset) {
          this.fireInitialScroll(); // will drain
        } else {
          this.drain();
        }
      };

      ScrollResponder.prototype.fireInitialScroll = function () {
        this.handleScrollRequest({
          time: this.scrollTime
        });
      };

      ScrollResponder.prototype.drain = function () {
        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
          this.queuedRequest = null;
        }
      };

      return ScrollResponder;
    }();

    var ViewContextType = createContext({}); // for Components

    function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
      return {
        dateEnv: dateEnv,
        options: viewOptions,
        pluginHooks: pluginHooks,
        emitter: emitter,
        dispatch: dispatch,
        getCurrentData: getCurrentData,
        calendarApi: calendarApi,
        viewSpec: viewSpec,
        viewApi: viewApi,
        dateProfileGenerator: dateProfileGenerator,
        theme: theme,
        isRtl: viewOptions.direction === 'rtl',
        addResizeHandler: function (handler) {
          emitter.on('_resize', handler);
        },
        removeResizeHandler: function (handler) {
          emitter.off('_resize', handler);
        },
        createScrollResponder: function (execFunc) {
          return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
        },
        registerInteractiveComponent: registerInteractiveComponent,
        unregisterInteractiveComponent: unregisterInteractiveComponent
      };
    }
    /* eslint max-classes-per-file: off */


    var PureComponent = function (_super) {
      __extends(PureComponent, _super);

      function PureComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        if (this.debug) {
          // eslint-disable-next-line no-console
          console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
        }

        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
      };

      PureComponent.addPropsEquality = addPropsEquality;
      PureComponent.addStateEquality = addStateEquality;
      PureComponent.contextType = ViewContextType;
      return PureComponent;
    }(Component);

    PureComponent.prototype.propEquality = {};
    PureComponent.prototype.stateEquality = {};

    var BaseComponent = function (_super) {
      __extends(BaseComponent, _super);

      function BaseComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      BaseComponent.contextType = ViewContextType;
      return BaseComponent;
    }(PureComponent);

    function addPropsEquality(propEquality) {
      var hash = Object.create(this.prototype.propEquality);

      __assign(hash, propEquality);

      this.prototype.propEquality = hash;
    }

    function addStateEquality(stateEquality) {
      var hash = Object.create(this.prototype.stateEquality);

      __assign(hash, stateEquality);

      this.prototype.stateEquality = hash;
    } // use other one


    function setRef(ref, current) {
      if (typeof ref === 'function') {
        ref(current);
      } else if (ref) {
        // see https://github.com/facebook/react/issues/13029
        ref.current = current;
      }
    }
    /*
    an INTERACTABLE date component

    PURPOSES:
    - hook up to fg, fill, and mirror renderers
    - interface for dragging and hits
    */


    var DateComponent = function (_super) {
      __extends(DateComponent, _super);

      function DateComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.uid = guid();
        return _this;
      } // Hit System
      // -----------------------------------------------------------------------------------------------------------------


      DateComponent.prototype.prepareHits = function () {};

      DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
        return null; // this should be abstract
      }; // Pointer Interaction Utils
      // -----------------------------------------------------------------------------------------------------------------


      DateComponent.prototype.isValidSegDownEl = function (el) {
        return !this.props.eventDrag && // HACK
        !this.props.eventResize && // HACK
        !elementClosest(el, '.fc-event-mirror');
      };

      DateComponent.prototype.isValidDateDownEl = function (el) {
        return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a "more.." link
        !elementClosest(el, 'a[data-navlink]') && // a clickable nav link
        !elementClosest(el, '.fc-popover'); // hack
      };

      return DateComponent;
    }(BaseComponent); // TODO: easier way to add new hooks? need to update a million things


    function createPlugin(input) {
      return {
        id: guid(),
        deps: input.deps || [],
        reducers: input.reducers || [],
        isLoadingFuncs: input.isLoadingFuncs || [],
        contextInit: [].concat(input.contextInit || []),
        eventRefiners: input.eventRefiners || {},
        eventDefMemberAdders: input.eventDefMemberAdders || [],
        eventSourceRefiners: input.eventSourceRefiners || {},
        isDraggableTransformers: input.isDraggableTransformers || [],
        eventDragMutationMassagers: input.eventDragMutationMassagers || [],
        eventDefMutationAppliers: input.eventDefMutationAppliers || [],
        dateSelectionTransformers: input.dateSelectionTransformers || [],
        datePointTransforms: input.datePointTransforms || [],
        dateSpanTransforms: input.dateSpanTransforms || [],
        views: input.views || {},
        viewPropsTransformers: input.viewPropsTransformers || [],
        isPropsValid: input.isPropsValid || null,
        externalDefTransforms: input.externalDefTransforms || [],
        viewContainerAppends: input.viewContainerAppends || [],
        eventDropTransformers: input.eventDropTransformers || [],
        componentInteractions: input.componentInteractions || [],
        calendarInteractions: input.calendarInteractions || [],
        themeClasses: input.themeClasses || {},
        eventSourceDefs: input.eventSourceDefs || [],
        cmdFormatter: input.cmdFormatter,
        recurringTypes: input.recurringTypes || [],
        namedTimeZonedImpl: input.namedTimeZonedImpl,
        initialView: input.initialView || '',
        elementDraggingImpl: input.elementDraggingImpl,
        optionChangeHandlers: input.optionChangeHandlers || {},
        scrollGridImpl: input.scrollGridImpl || null,
        contentTypeHandlers: input.contentTypeHandlers || {},
        listenerRefiners: input.listenerRefiners || {},
        optionRefiners: input.optionRefiners || {},
        propSetHandlers: input.propSetHandlers || {}
      };
    }

    function buildPluginHooks(pluginDefs, globalDefs) {
      var isAdded = {};
      var hooks = {
        reducers: [],
        isLoadingFuncs: [],
        contextInit: [],
        eventRefiners: {},
        eventDefMemberAdders: [],
        eventSourceRefiners: {},
        isDraggableTransformers: [],
        eventDragMutationMassagers: [],
        eventDefMutationAppliers: [],
        dateSelectionTransformers: [],
        datePointTransforms: [],
        dateSpanTransforms: [],
        views: {},
        viewPropsTransformers: [],
        isPropsValid: null,
        externalDefTransforms: [],
        viewContainerAppends: [],
        eventDropTransformers: [],
        componentInteractions: [],
        calendarInteractions: [],
        themeClasses: {},
        eventSourceDefs: [],
        cmdFormatter: null,
        recurringTypes: [],
        namedTimeZonedImpl: null,
        initialView: '',
        elementDraggingImpl: null,
        optionChangeHandlers: {},
        scrollGridImpl: null,
        contentTypeHandlers: {},
        listenerRefiners: {},
        optionRefiners: {},
        propSetHandlers: {}
      };

      function addDefs(defs) {
        for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {
          var def = defs_1[_i];

          if (!isAdded[def.id]) {
            isAdded[def.id] = true;
            addDefs(def.deps);
            hooks = combineHooks(hooks, def);
          }
        }
      }

      if (pluginDefs) {
        addDefs(pluginDefs);
      }

      addDefs(globalDefs);
      return hooks;
    }

    function buildBuildPluginHooks() {
      var currentOverrideDefs = [];
      var currentGlobalDefs = [];
      var currentHooks;
      return function (overrideDefs, globalDefs) {
        if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
          currentHooks = buildPluginHooks(overrideDefs, globalDefs);
        }

        currentOverrideDefs = overrideDefs;
        currentGlobalDefs = globalDefs;
        return currentHooks;
      };
    }

    function combineHooks(hooks0, hooks1) {
      return {
        reducers: hooks0.reducers.concat(hooks1.reducers),
        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
        contextInit: hooks0.contextInit.concat(hooks1.contextInit),
        eventRefiners: __assign(__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
        eventSourceRefiners: __assign(__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
        views: __assign(__assign({}, hooks0.views), hooks1.views),
        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
        themeClasses: __assign(__assign({}, hooks0.themeClasses), hooks1.themeClasses),
        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
        initialView: hooks0.initialView || hooks1.initialView,
        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
        optionChangeHandlers: __assign(__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
        contentTypeHandlers: __assign(__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),
        listenerRefiners: __assign(__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
        optionRefiners: __assign(__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
        propSetHandlers: __assign(__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
      };
    }

    var StandardTheme = function (_super) {
      __extends(StandardTheme, _super);

      function StandardTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      return StandardTheme;
    }(Theme);

    StandardTheme.prototype.classes = {
      root: 'fc-theme-standard',
      tableCellShaded: 'fc-cell-shaded',
      buttonGroup: 'fc-button-group',
      button: 'fc-button fc-button-primary',
      buttonActive: 'fc-button-active'
    };
    StandardTheme.prototype.baseIconClass = 'fc-icon';
    StandardTheme.prototype.iconClasses = {
      close: 'fc-icon-x',
      prev: 'fc-icon-chevron-left',
      next: 'fc-icon-chevron-right',
      prevYear: 'fc-icon-chevrons-left',
      nextYear: 'fc-icon-chevrons-right'
    };
    StandardTheme.prototype.rtlIconClasses = {
      prev: 'fc-icon-chevron-right',
      next: 'fc-icon-chevron-left',
      prevYear: 'fc-icon-chevrons-right',
      nextYear: 'fc-icon-chevrons-left'
    };
    StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly

    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

    function compileViewDefs(defaultConfigs, overrideConfigs) {
      var hash = {};
      var viewType;

      for (viewType in defaultConfigs) {
        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      }

      for (viewType in overrideConfigs) {
        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      }

      return hash;
    }

    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
      if (hash[viewType]) {
        return hash[viewType];
      }

      var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);

      if (viewDef) {
        hash[viewType] = viewDef;
      }

      return viewDef;
    }

    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
      var defaultConfig = defaultConfigs[viewType];
      var overrideConfig = overrideConfigs[viewType];

      var queryProp = function (name) {
        return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
      };

      var theComponent = queryProp('component');
      var superType = queryProp('superType');
      var superDef = null;

      if (superType) {
        if (superType === viewType) {
          throw new Error('Can\'t have a custom view type that references itself');
        }

        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
      }

      if (!theComponent && superDef) {
        theComponent = superDef.component;
      }

      if (!theComponent) {
        return null; // don't throw a warning, might be settings for a single-unit view
      }

      return {
        type: viewType,
        component: theComponent,
        defaults: __assign(__assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
        overrides: __assign(__assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
      };
    }
    /* eslint max-classes-per-file: off */
    // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???


    var RenderHook = function (_super) {
      __extends(RenderHook, _super);

      function RenderHook() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.rootElRef = createRef();

        _this.handleRootEl = function (el) {
          setRef(_this.rootElRef, el);

          if (_this.props.elRef) {
            setRef(_this.props.elRef, el);
          }
        };

        return _this;
      }

      RenderHook.prototype.render = function () {
        var _this = this;

        var props = this.props;
        var hookProps = props.hookProps;
        return createElement(MountHook, {
          hookProps: hookProps,
          didMount: props.didMount,
          willUnmount: props.willUnmount,
          elRef: this.handleRootEl
        }, function (rootElRef) {
          return createElement(ContentHook, {
            hookProps: hookProps,
            content: props.content,
            defaultContent: props.defaultContent,
            backupElRef: _this.rootElRef
          }, function (innerElRef, innerContent) {
            return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);
          });
        });
      };

      return RenderHook;
    }(BaseComponent); // TODO: rename to be about function, not default. use in above type
    // for forcing rerender of components that use the ContentHook


    var CustomContentRenderContext = createContext(0);

    function ContentHook(props) {
      return createElement(CustomContentRenderContext.Consumer, null, function (renderId) {
        return createElement(ContentHookInner, __assign({
          renderId: renderId
        }, props));
      });
    }

    var ContentHookInner = function (_super) {
      __extends(ContentHookInner, _super);

      function ContentHookInner() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.innerElRef = createRef();
        return _this;
      }

      ContentHookInner.prototype.render = function () {
        return this.props.children(this.innerElRef, this.renderInnerContent());
      };

      ContentHookInner.prototype.componentDidMount = function () {
        this.updateCustomContent();
      };

      ContentHookInner.prototype.componentDidUpdate = function () {
        this.updateCustomContent();
      };

      ContentHookInner.prototype.componentWillUnmount = function () {
        if (this.customContentInfo && this.customContentInfo.destroy) {
          this.customContentInfo.destroy();
        }
      };

      ContentHookInner.prototype.renderInnerContent = function () {
        var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)

        var innerContent = this.getInnerContent();
        var meta = this.getContentMeta(innerContent); // initial run, or content-type changing? (from vue -> react for example)

        if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {
          // clearing old value
          if (customContentInfo) {
            if (customContentInfo.destroy) {
              customContentInfo.destroy();
            }

            customContentInfo = this.customContentInfo = null;
          } // assigning new value


          if (meta.contentKey) {
            customContentInfo = this.customContentInfo = __assign({
              contentKey: meta.contentKey,
              contentVal: innerContent[meta.contentKey]
            }, meta.buildLifecycleFuncs());
          } // updating

        } else if (customContentInfo) {
          customContentInfo.contentVal = innerContent[meta.contentKey];
        }

        return customContentInfo ? [] // signal that something was specified
        : innerContent; // assume a [p]react vdom node. use it
      };

      ContentHookInner.prototype.getInnerContent = function () {
        var props = this.props;
        var innerContent = normalizeContent(props.content, props.hookProps);

        if (innerContent === undefined) {
          // use the default
          innerContent = normalizeContent(props.defaultContent, props.hookProps);
        }

        return innerContent == null ? null : innerContent; // convert undefined to null (better for React)
      };

      ContentHookInner.prototype.getContentMeta = function (innerContent) {
        var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;
        var contentKey = '';
        var buildLifecycleFuncs = null;

        if (innerContent) {
          // allowed to be null, for convenience to caller
          for (var searchKey in contentTypeHandlers) {
            if (innerContent[searchKey] !== undefined) {
              contentKey = searchKey;
              buildLifecycleFuncs = contentTypeHandlers[searchKey];
              break;
            }
          }
        }

        return {
          contentKey: contentKey,
          buildLifecycleFuncs: buildLifecycleFuncs
        };
      };

      ContentHookInner.prototype.updateCustomContent = function () {
        if (this.customContentInfo) {
          // for non-[p]react
          this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into
          this.customContentInfo.contentVal);
        }
      };

      return ContentHookInner;
    }(BaseComponent);

    var MountHook = function (_super) {
      __extends(MountHook, _super);

      function MountHook() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.handleRootEl = function (rootEl) {
          _this.rootEl = rootEl;

          if (_this.props.elRef) {
            setRef(_this.props.elRef, rootEl);
          }
        };

        return _this;
      }

      MountHook.prototype.render = function () {
        return this.props.children(this.handleRootEl);
      };

      MountHook.prototype.componentDidMount = function () {
        var callback = this.props.didMount;

        if (callback) {
          callback(__assign(__assign({}, this.props.hookProps), {
            el: this.rootEl
          }));
        }
      };

      MountHook.prototype.componentWillUnmount = function () {
        var callback = this.props.willUnmount;

        if (callback) {
          callback(__assign(__assign({}, this.props.hookProps), {
            el: this.rootEl
          }));
        }
      };

      return MountHook;
    }(BaseComponent);

    function buildClassNameNormalizer() {
      var currentGenerator;
      var currentHookProps;
      var currentClassNames = [];
      return function (generator, hookProps) {
        if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {
          currentGenerator = generator;
          currentHookProps = hookProps;
          currentClassNames = normalizeClassNames(generator, hookProps);
        }

        return currentClassNames;
      };
    }

    function normalizeClassNames(classNames, hookProps) {
      if (typeof classNames === 'function') {
        classNames = classNames(hookProps);
      }

      return parseClassNames(classNames);
    }

    function normalizeContent(input, hookProps) {
      if (typeof input === 'function') {
        return input(hookProps, createElement); // give the function the vdom-creation func
      }

      return input;
    }

    var ViewRoot = function (_super) {
      __extends(ViewRoot, _super);

      function ViewRoot() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.normalizeClassNames = buildClassNameNormalizer();
        return _this;
      }

      ViewRoot.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var options = context.options;
        var hookProps = {
          view: context.viewApi
        };
        var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);
        return createElement(MountHook, {
          hookProps: hookProps,
          didMount: options.viewDidMount,
          willUnmount: options.viewWillUnmount,
          elRef: props.elRef
        }, function (rootElRef) {
          return props.children(rootElRef, ["fc-" + props.viewSpec.type + "-view", 'fc-view'].concat(customClassNames));
        });
      };

      return ViewRoot;
    }(BaseComponent);

    function parseViewConfigs(inputs) {
      return mapHash(inputs, parseViewConfig);
    }

    function parseViewConfig(input) {
      var rawOptions = typeof input === 'function' ? {
        component: input
      } : input;
      var component = rawOptions.component;

      if (rawOptions.content) {
        component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?
      }

      return {
        superType: rawOptions.type,
        component: component,
        rawOptions: rawOptions
      };
    }

    function createViewHookComponent(options) {
      return function (viewProps) {
        return createElement(ViewContextType.Consumer, null, function (context) {
          return createElement(ViewRoot, {
            viewSpec: context.viewSpec
          }, function (viewElRef, viewClassNames) {
            var hookProps = __assign(__assign({}, viewProps), {
              nextDayThreshold: context.options.nextDayThreshold
            });

            return createElement(RenderHook, {
              hookProps: hookProps,
              classNames: options.classNames,
              content: options.content,
              didMount: options.didMount,
              willUnmount: options.willUnmount,
              elRef: viewElRef
            }, function (rootElRef, customClassNames, innerElRef, innerContent) {
              return createElement("div", {
                className: viewClassNames.concat(customClassNames).join(' '),
                ref: rootElRef
              }, innerContent);
            });
          });
        });
      };
    }

    function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
      var defaultConfigs = parseViewConfigs(defaultInputs);
      var overrideConfigs = parseViewConfigs(optionOverrides.views);
      var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
      return mapHash(viewDefs, function (viewDef) {
        return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);
      });
    }

    function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
      var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
      var duration = null;
      var durationUnit = '';
      var singleUnit = '';
      var singleUnitOverrides = {};

      if (durationInput) {
        duration = createDurationCached(durationInput);

        if (duration) {
          // valid?
          var denom = greatestDurationDenominator(duration);
          durationUnit = denom.unit;

          if (denom.value === 1) {
            singleUnit = durationUnit;
            singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
          }
        }
      }

      var queryButtonText = function (optionsSubset) {
        var buttonTextMap = optionsSubset.buttonText || {};
        var buttonTextKey = viewDef.defaults.buttonTextKey;

        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
          return buttonTextMap[buttonTextKey];
        }

        if (buttonTextMap[viewDef.type] != null) {
          return buttonTextMap[viewDef.type];
        }

        if (buttonTextMap[singleUnit] != null) {
          return buttonTextMap[singleUnit];
        }

        return null;
      };

      return {
        type: viewDef.type,
        component: viewDef.component,
        duration: duration,
        durationUnit: durationUnit,
        singleUnit: singleUnit,
        optionDefaults: viewDef.defaults,
        optionOverrides: __assign(__assign({}, singleUnitOverrides), viewDef.overrides),
        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
        viewDef.overrides.buttonText,
        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type // fall back to given view name

      };
    } // hack to get memoization working


    var durationInputMap = {};

    function createDurationCached(durationInput) {
      var json = JSON.stringify(durationInput);
      var res = durationInputMap[json];

      if (res === undefined) {
        res = createDuration(durationInput);
        durationInputMap[json] = res;
      }

      return res;
    }

    var DateProfileGenerator = function () {
      function DateProfileGenerator(props) {
        this.props = props;
        this.nowDate = getNow(props.nowInput, props.dateEnv);
        this.initHiddenDays();
      }
      /* Date Range Computation
      ------------------------------------------------------------------------------------------------------------------*/
      // Builds a structure with info about what the dates/ranges will be for the "prev" view.


      DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {
        var dateEnv = this.props.dateEnv;
        var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
        currentDateProfile.dateIncrement);
        return this.build(prevDate, -1, forceToValid);
      }; // Builds a structure with info about what the dates/ranges will be for the "next" view.


      DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {
        var dateEnv = this.props.dateEnv;
        var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
        currentDateProfile.dateIncrement);
        return this.build(nextDate, 1, forceToValid);
      }; // Builds a structure holding dates/ranges for rendering around the given date.
      // Optional direction param indicates whether the date is being incremented/decremented
      // from its previous value. decremented = -1, incremented = 1 (default).


      DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {
        if (forceToValid === void 0) {
          forceToValid = true;
        }

        var props = this.props;
        var validRange;
        var currentInfo;
        var isRangeAllDay;
        var renderRange;
        var activeRange;
        var isValid;
        validRange = this.buildValidRange();
        validRange = this.trimHiddenDays(validRange);

        if (forceToValid) {
          currentDate = constrainMarkerToRange(currentDate, validRange);
        }

        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
        renderRange = this.trimHiddenDays(renderRange);
        activeRange = renderRange;

        if (!props.showNonCurrentDates) {
          activeRange = intersectRanges(activeRange, currentInfo.range);
        }

        activeRange = this.adjustActiveRange(activeRange);
        activeRange = intersectRanges(activeRange, validRange); // might return null
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.

        isValid = rangesIntersect(currentInfo.range, validRange);
        return {
          // constraint for where prev/next operations can go and where events can be dragged/resized to.
          // an object with optional start and end properties.
          validRange: validRange,
          // range the view is formally responsible for.
          // for example, a month view might have 1st-31st, excluding padded dates
          currentRange: currentInfo.range,
          // name of largest unit being displayed, like "month" or "week"
          currentRangeUnit: currentInfo.unit,
          isRangeAllDay: isRangeAllDay,
          // dates that display events and accept drag-n-drop
          // will be `null` if no dates accept events
          activeRange: activeRange,
          // date range with a rendered skeleton
          // includes not-active days that need some sort of DOM
          renderRange: renderRange,
          // Duration object that denotes the first visible time of any given day
          slotMinTime: props.slotMinTime,
          // Duration object that denotes the exclusive visible end time of any given day
          slotMaxTime: props.slotMaxTime,
          isValid: isValid,
          // how far the current date will move for a prev/next operation
          dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^

        };
      }; // Builds an object with optional start/end properties.
      // Indicates the minimum/maximum dates to display.
      // not responsible for trimming hidden days.


      DateProfileGenerator.prototype.buildValidRange = function () {
        var input = this.props.validRangeInput;
        var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;
        return this.refineRange(simpleInput) || {
          start: null,
          end: null
        }; // completely open-ended
      }; // Builds a structure with info about the "current" range, the range that is
      // highlighted as being the current month for example.
      // See build() for a description of `direction`.
      // Guaranteed to have `range` and `unit` properties. `duration` is optional.


      DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
        var props = this.props;
        var duration = null;
        var unit = null;
        var range = null;
        var dayCount;

        if (props.duration) {
          duration = props.duration;
          unit = props.durationUnit;
          range = this.buildRangeFromDuration(date, direction, duration, unit);
        } else if (dayCount = this.props.dayCount) {
          unit = 'day';
          range = this.buildRangeFromDayCount(date, direction, dayCount);
        } else if (range = this.buildCustomVisibleRange(date)) {
          unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
        } else {
          duration = this.getFallbackDuration();
          unit = greatestDurationDenominator(duration).unit;
          range = this.buildRangeFromDuration(date, direction, duration, unit);
        }

        return {
          duration: duration,
          unit: unit,
          range: range
        };
      };

      DateProfileGenerator.prototype.getFallbackDuration = function () {
        return createDuration({
          day: 1
        });
      }; // Returns a new activeRange to have time values (un-ambiguate)
      // slotMinTime or slotMaxTime causes the range to expand.


      DateProfileGenerator.prototype.adjustActiveRange = function (range) {
        var _a = this.props,
            dateEnv = _a.dateEnv,
            usesMinMaxTime = _a.usesMinMaxTime,
            slotMinTime = _a.slotMinTime,
            slotMaxTime = _a.slotMaxTime;
        var start = range.start,
            end = range.end;

        if (usesMinMaxTime) {
          // expand active range if slotMinTime is negative (why not when positive?)
          if (asRoughDays(slotMinTime) < 0) {
            start = startOfDay(start); // necessary?

            start = dateEnv.add(start, slotMinTime);
          } // expand active range if slotMaxTime is beyond one day (why not when negative?)


          if (asRoughDays(slotMaxTime) > 1) {
            end = startOfDay(end); // necessary?

            end = addDays(end, -1);
            end = dateEnv.add(end, slotMaxTime);
          }
        }

        return {
          start: start,
          end: end
        };
      }; // Builds the "current" range when it is specified as an explicit duration.
      // `unit` is the already-computed greatestDurationDenominator unit of duration.


      DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
        var _a = this.props,
            dateEnv = _a.dateEnv,
            dateAlignment = _a.dateAlignment;
        var start;
        var end;
        var res; // compute what the alignment should be

        if (!dateAlignment) {
          var dateIncrement = this.props.dateIncrement;

          if (dateIncrement) {
            // use the smaller of the two units
            if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
              dateAlignment = greatestDurationDenominator(dateIncrement).unit;
            } else {
              dateAlignment = unit;
            }
          } else {
            dateAlignment = unit;
          }
        } // if the view displays a single day or smaller


        if (asRoughDays(duration) <= 1) {
          if (this.isHiddenDay(start)) {
            start = this.skipHiddenDays(start, direction);
            start = startOfDay(start);
          }
        }

        function computeRes() {
          start = dateEnv.startOf(date, dateAlignment);
          end = dateEnv.add(start, duration);
          res = {
            start: start,
            end: end
          };
        }

        computeRes(); // if range is completely enveloped by hidden days, go past the hidden days

        if (!this.trimHiddenDays(res)) {
          date = this.skipHiddenDays(date, direction);
          computeRes();
        }

        return res;
      }; // Builds the "current" range when a dayCount is specified.


      DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
        var _a = this.props,
            dateEnv = _a.dateEnv,
            dateAlignment = _a.dateAlignment;
        var runningCount = 0;
        var start = date;
        var end;

        if (dateAlignment) {
          start = dateEnv.startOf(start, dateAlignment);
        }

        start = startOfDay(start);
        start = this.skipHiddenDays(start, direction);
        end = start;

        do {
          end = addDays(end, 1);

          if (!this.isHiddenDay(end)) {
            runningCount += 1;
          }
        } while (runningCount < dayCount);

        return {
          start: start,
          end: end
        };
      }; // Builds a normalized range object for the "visible" range,
      // which is a way to define the currentRange and activeRange at the same time.


      DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
        var props = this.props;
        var input = props.visibleRangeInput;
        var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
        var range = this.refineRange(simpleInput);

        if (range && (range.start == null || range.end == null)) {
          return null;
        }

        return range;
      }; // Computes the range that will represent the element/cells for *rendering*,
      // but which may have voided days/times.
      // not responsible for trimming hidden days.


      DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
        return currentRange;
      }; // Compute the duration value that should be added/substracted to the current date
      // when a prev/next operation happens.


      DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
        var dateIncrement = this.props.dateIncrement;
        var customAlignment;

        if (dateIncrement) {
          return dateIncrement;
        }

        if (customAlignment = this.props.dateAlignment) {
          return createDuration(1, customAlignment);
        }

        if (fallback) {
          return fallback;
        }

        return createDuration({
          days: 1
        });
      };

      DateProfileGenerator.prototype.refineRange = function (rangeInput) {
        if (rangeInput) {
          var range = parseRange(rangeInput, this.props.dateEnv);

          if (range) {
            range = computeVisibleDayRange(range);
          }

          return range;
        }

        return null;
      };
      /* Hidden Days
      ------------------------------------------------------------------------------------------------------------------*/
      // Initializes internal variables related to calculating hidden days-of-week


      DateProfileGenerator.prototype.initHiddenDays = function () {
        var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden

        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)

        var dayCnt = 0;
        var i;

        if (this.props.weekends === false) {
          hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        }

        for (i = 0; i < 7; i += 1) {
          if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
            dayCnt += 1;
          }
        }

        if (!dayCnt) {
          throw new Error('invalid hiddenDays'); // all days were hidden? bad.
        }

        this.isHiddenDayHash = isHiddenDayHash;
      }; // Remove days from the beginning and end of the range that are computed as hidden.
      // If the whole range is trimmed off, returns null


      DateProfileGenerator.prototype.trimHiddenDays = function (range) {
        var start = range.start,
            end = range.end;

        if (start) {
          start = this.skipHiddenDays(start);
        }

        if (end) {
          end = this.skipHiddenDays(end, -1, true);
        }

        if (start == null || end == null || start < end) {
          return {
            start: start,
            end: end
          };
        }

        return null;
      }; // Is the current day hidden?
      // `day` is a day-of-week index (0-6), or a Date (used for UTC)


      DateProfileGenerator.prototype.isHiddenDay = function (day) {
        if (day instanceof Date) {
          day = day.getUTCDay();
        }

        return this.isHiddenDayHash[day];
      }; // Incrementing the current day until it is no longer a hidden day, returning a copy.
      // DOES NOT CONSIDER validRange!
      // If the initial value of `date` is not a hidden day, don't do anything.
      // Pass `isExclusive` as `true` if you are dealing with an end date.
      // `inc` defaults to `1` (increment one day forward each time)


      DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {
        if (inc === void 0) {
          inc = 1;
        }

        if (isExclusive === void 0) {
          isExclusive = false;
        }

        while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
          date = addDays(date, inc);
        }

        return date;
      };

      return DateProfileGenerator;
    }();

    function reduceViewType(viewType, action) {
      switch (action.type) {
        case 'CHANGE_VIEW_TYPE':
          viewType = action.viewType;
      }

      return viewType;
    }

    function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
      var _a;

      switch (action.type) {
        case 'SET_OPTION':
          return __assign(__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));

        default:
          return dynamicOptionOverrides;
      }
    }

    function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
      var dp;

      switch (action.type) {
        case 'CHANGE_VIEW_TYPE':
          return dateProfileGenerator.build(action.dateMarker || currentDate);

        case 'CHANGE_DATE':
          return dateProfileGenerator.build(action.dateMarker);

        case 'PREV':
          dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);

          if (dp.isValid) {
            return dp;
          }

          break;

        case 'NEXT':
          dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);

          if (dp.isValid) {
            return dp;
          }

          break;
      }

      return currentDateProfile;
    }

    function initEventSources(calendarOptions, dateProfile, context) {
      var activeRange = dateProfile ? dateProfile.activeRange : null;
      return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
    }

    function reduceEventSources(eventSources, action, dateProfile, context) {
      var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?

      switch (action.type) {
        case 'ADD_EVENT_SOURCES':
          // already parsed
          return addSources(eventSources, action.sources, activeRange, context);

        case 'REMOVE_EVENT_SOURCE':
          return removeSource(eventSources, action.sourceId);

        case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

        case 'NEXT':
        case 'CHANGE_DATE':
        case 'CHANGE_VIEW_TYPE':
          if (dateProfile) {
            return fetchDirtySources(eventSources, activeRange, context);
          }

          return eventSources;

        case 'FETCH_EVENT_SOURCES':
          return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?
          arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);

        case 'RECEIVE_EVENTS':
        case 'RECEIVE_EVENT_ERROR':
          return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);

        case 'REMOVE_ALL_EVENT_SOURCES':
          return {};

        default:
          return eventSources;
      }
    }

    function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
      var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?

      return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
    }

    function computeEventSourcesLoading(eventSources) {
      for (var sourceId in eventSources) {
        if (eventSources[sourceId].isFetching) {
          return true;
        }
      }

      return false;
    }

    function addSources(eventSourceHash, sources, fetchRange, context) {
      var hash = {};

      for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
        var source = sources_1[_i];
        hash[source.sourceId] = source;
      }

      if (fetchRange) {
        hash = fetchDirtySources(hash, fetchRange, context);
      }

      return __assign(__assign({}, eventSourceHash), hash);
    }

    function removeSource(eventSourceHash, sourceId) {
      return filterHash(eventSourceHash, function (eventSource) {
        return eventSource.sourceId !== sourceId;
      });
    }

    function fetchDirtySources(sourceHash, fetchRange, context) {
      return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {
        return isSourceDirty(eventSource, fetchRange, context);
      }), fetchRange, false, context);
    }

    function isSourceDirty(eventSource, fetchRange, context) {
      if (!doesSourceNeedRange(eventSource, context)) {
        return !eventSource.latestFetchId;
      }

      return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
      fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
    }

    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
      var nextSources = {};

      for (var sourceId in prevSources) {
        var source = prevSources[sourceId];

        if (sourceIdHash[sourceId]) {
          nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
        } else {
          nextSources[sourceId] = source;
        }
      }

      return nextSources;
    }

    function fetchSource(eventSource, fetchRange, isRefetch, context) {
      var options = context.options,
          calendarApi = context.calendarApi;
      var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
      var fetchId = guid();
      sourceDef.fetch({
        eventSource: eventSource,
        range: fetchRange,
        isRefetch: isRefetch,
        context: context
      }, function (res) {
        var rawEvents = res.rawEvents;

        if (options.eventSourceSuccess) {
          rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;
        }

        if (eventSource.success) {
          rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;
        }

        context.dispatch({
          type: 'RECEIVE_EVENTS',
          sourceId: eventSource.sourceId,
          fetchId: fetchId,
          fetchRange: fetchRange,
          rawEvents: rawEvents
        });
      }, function (error) {
        console.warn(error.message, error);

        if (options.eventSourceFailure) {
          options.eventSourceFailure.call(calendarApi, error);
        }

        if (eventSource.failure) {
          eventSource.failure(error);
        }

        context.dispatch({
          type: 'RECEIVE_EVENT_ERROR',
          sourceId: eventSource.sourceId,
          fetchId: fetchId,
          fetchRange: fetchRange,
          error: error
        });
      });
      return __assign(__assign({}, eventSource), {
        isFetching: true,
        latestFetchId: fetchId
      });
    }

    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
      var _a;

      var eventSource = sourceHash[sourceId];

      if (eventSource && // not already removed
      fetchId === eventSource.latestFetchId) {
        return __assign(__assign({}, sourceHash), (_a = {}, _a[sourceId] = __assign(__assign({}, eventSource), {
          isFetching: false,
          fetchRange: fetchRange
        }), _a));
      }

      return sourceHash;
    }

    function excludeStaticSources(eventSources, context) {
      return filterHash(eventSources, function (eventSource) {
        return doesSourceNeedRange(eventSource, context);
      });
    }

    function parseInitialSources(rawOptions, context) {
      var refiners = buildEventSourceRefiners(context);
      var rawSources = [].concat(rawOptions.eventSources || []);
      var sources = []; // parsed

      if (rawOptions.initialEvents) {
        rawSources.unshift(rawOptions.initialEvents);
      }

      if (rawOptions.events) {
        rawSources.unshift(rawOptions.events);
      }

      for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {
        var rawSource = rawSources_1[_i];
        var source = parseEventSource(rawSource, context, refiners);

        if (source) {
          sources.push(source);
        }
      }

      return sources;
    }

    function doesSourceNeedRange(eventSource, context) {
      var defs = context.pluginHooks.eventSourceDefs;
      return !defs[eventSource.sourceDefId].ignoreRange;
    }

    function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
      switch (action.type) {
        case 'RECEIVE_EVENTS':
          // raw
          return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);

        case 'ADD_EVENTS':
          // already parsed, but not expanded
          return addEvent(eventStore, action.eventStore, // new ones
          dateProfile ? dateProfile.activeRange : null, context);

        case 'RESET_EVENTS':
          return action.eventStore;

        case 'MERGE_EVENTS':
          // already parsed and expanded
          return mergeEventStores(eventStore, action.eventStore);

        case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

        case 'NEXT':
        case 'CHANGE_DATE':
        case 'CHANGE_VIEW_TYPE':
          if (dateProfile) {
            return expandRecurring(eventStore, dateProfile.activeRange, context);
          }

          return eventStore;

        case 'REMOVE_EVENTS':
          return excludeSubEventStore(eventStore, action.eventStore);

        case 'REMOVE_EVENT_SOURCE':
          return excludeEventsBySourceId(eventStore, action.sourceId);

        case 'REMOVE_ALL_EVENT_SOURCES':
          return filterEventStoreDefs(eventStore, function (eventDef) {
            return !eventDef.sourceId // only keep events with no source id
            ;
          });

        case 'REMOVE_ALL_EVENTS':
          return createEmptyEventStore();

        default:
          return eventStore;
      }
    }

    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
      if (eventSource && // not already removed
      fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
      ) {
        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);

        if (fetchRange) {
          subset = expandRecurring(subset, fetchRange, context);
        }

        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
      }

      return eventStore;
    }

    function transformRawEvents(rawEvents, eventSource, context) {
      var calEachTransform = context.options.eventDataTransform;
      var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;

      if (sourceEachTransform) {
        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
      }

      if (calEachTransform) {
        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
      }

      return rawEvents;
    }

    function transformEachRawEvent(rawEvents, func) {
      var refinedEvents;

      if (!func) {
        refinedEvents = rawEvents;
      } else {
        refinedEvents = [];

        for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
          var rawEvent = rawEvents_1[_i];
          var refinedEvent = func(rawEvent);

          if (refinedEvent) {
            refinedEvents.push(refinedEvent);
          } else if (refinedEvent == null) {
            refinedEvents.push(rawEvent);
          } // if a different falsy value, do nothing

        }
      }

      return refinedEvents;
    }

    function addEvent(eventStore, subset, expandRange, context) {
      if (expandRange) {
        subset = expandRecurring(subset, expandRange, context);
      }

      return mergeEventStores(eventStore, subset);
    }

    function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
      var defs = eventStore.defs;
      var instances = mapHash(eventStore.instances, function (instance) {
        var def = defs[instance.defId];

        if (def.allDay || def.recurringDef) {
          return instance; // isn't dependent on timezone
        }

        return __assign(__assign({}, instance), {
          range: {
            start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
            end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
          },
          forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,
          forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo
        });
      });
      return {
        defs: defs,
        instances: instances
      };
    }

    function excludeEventsBySourceId(eventStore, sourceId) {
      return filterEventStoreDefs(eventStore, function (eventDef) {
        return eventDef.sourceId !== sourceId;
      });
    } // QUESTION: why not just return instances? do a general object-property-exclusion util

    function reduceDateSelection(currentSelection, action) {
      switch (action.type) {
        case 'UNSELECT_DATES':
          return null;

        case 'SELECT_DATES':
          return action.selection;

        default:
          return currentSelection;
      }
    }

    function reduceSelectedEvent(currentInstanceId, action) {
      switch (action.type) {
        case 'UNSELECT_EVENT':
          return '';

        case 'SELECT_EVENT':
          return action.eventInstanceId;

        default:
          return currentInstanceId;
      }
    }

    function reduceEventDrag(currentDrag, action) {
      var newDrag;

      switch (action.type) {
        case 'UNSET_EVENT_DRAG':
          return null;

        case 'SET_EVENT_DRAG':
          newDrag = action.state;
          return {
            affectedEvents: newDrag.affectedEvents,
            mutatedEvents: newDrag.mutatedEvents,
            isEvent: newDrag.isEvent
          };

        default:
          return currentDrag;
      }
    }

    function reduceEventResize(currentResize, action) {
      var newResize;

      switch (action.type) {
        case 'UNSET_EVENT_RESIZE':
          return null;

        case 'SET_EVENT_RESIZE':
          newResize = action.state;
          return {
            affectedEvents: newResize.affectedEvents,
            mutatedEvents: newResize.mutatedEvents,
            isEvent: newResize.isEvent
          };

        default:
          return currentResize;
      }
    }

    function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
      var viewsWithButtons = [];
      var headerToolbar = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;
      var footerToolbar = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;
      return {
        headerToolbar: headerToolbar,
        footerToolbar: footerToolbar,
        viewsWithButtons: viewsWithButtons
      };
    }

    function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {
      return mapHash(sectionStrHash, function (sectionStr) {
        return parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons);
      });
    }
    /*
    BAD: querying icons and text here. should be done at render time
    */


    function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {
      var isRtl = calendarOptions.direction === 'rtl';
      var calendarCustomButtons = calendarOptions.customButtons || {};
      var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
      var calendarButtonText = calendarOptions.buttonText || {};
      var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];
      return sectionSubstrs.map(function (buttonGroupStr) {
        return buttonGroupStr.split(',').map(function (buttonName) {
          if (buttonName === 'title') {
            return {
              buttonName: buttonName
            };
          }

          var customButtonProps;
          var viewSpec;
          var buttonClick;
          var buttonIcon; // only one of these will be set

          var buttonText; // "

          if (customButtonProps = calendarCustomButtons[buttonName]) {
            buttonClick = function (ev) {
              if (customButtonProps.click) {
                customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?
              }
            };

            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
          } else if (viewSpec = viewSpecs[buttonName]) {
            viewsWithButtons.push(buttonName);

            buttonClick = function () {
              calendarApi.changeView(buttonName);
            };

            (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
          } else if (calendarApi[buttonName]) {
            // a calendarApi method
            buttonClick = function () {
              calendarApi[buttonName]();
            };

            (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); //            ^ everything else is considered default
          }

          return {
            buttonName: buttonName,
            buttonClick: buttonClick,
            buttonIcon: buttonIcon,
            buttonText: buttonText
          };
        });
      });
    }

    var eventSourceDef$2 = {
      ignoreRange: true,
      parseMeta: function (refined) {
        if (Array.isArray(refined.events)) {
          return refined.events;
        }

        return null;
      },
      fetch: function (arg, success) {
        success({
          rawEvents: arg.eventSource.meta
        });
      }
    };
    var arrayEventSourcePlugin = createPlugin({
      eventSourceDefs: [eventSourceDef$2]
    });
    var eventSourceDef$1 = {
      parseMeta: function (refined) {
        if (typeof refined.events === 'function') {
          return refined.events;
        }

        return null;
      },
      fetch: function (arg, success, failure) {
        var dateEnv = arg.context.dateEnv;
        var func = arg.eventSource.meta;
        unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {
          success({
            rawEvents: rawEvents
          }); // needs an object response
        }, failure);
      }
    };
    var funcEventSourcePlugin = createPlugin({
      eventSourceDefs: [eventSourceDef$1]
    });

    function requestJson(method, url, params, successCallback, failureCallback) {
      method = method.toUpperCase();
      var body = null;

      if (method === 'GET') {
        url = injectQueryStringParams(url, params);
      } else {
        body = encodeParams(params);
      }

      var xhr = new XMLHttpRequest();
      xhr.open(method, url, true);

      if (method !== 'GET') {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      }

      xhr.onload = function () {
        if (xhr.status >= 200 && xhr.status < 400) {
          var parsed = false;
          var res = void 0;

          try {
            res = JSON.parse(xhr.responseText);
            parsed = true;
          } catch (err) {// will handle parsed=false
          }

          if (parsed) {
            successCallback(res, xhr);
          } else {
            failureCallback('Failure parsing JSON', xhr);
          }
        } else {
          failureCallback('Request failed', xhr);
        }
      };

      xhr.onerror = function () {
        failureCallback('Request failed', xhr);
      };

      xhr.send(body);
    }

    function injectQueryStringParams(url, params) {
      return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);
    }

    function encodeParams(params) {
      var parts = [];

      for (var key in params) {
        parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
      }

      return parts.join('&');
    }

    var JSON_FEED_EVENT_SOURCE_REFINERS = {
      method: String,
      extraParams: identity,
      startParam: String,
      endParam: String,
      timeZoneParam: String
    };
    var eventSourceDef = {
      parseMeta: function (refined) {
        if (refined.url && (refined.format === 'json' || !refined.format)) {
          return {
            url: refined.url,
            format: 'json',
            method: (refined.method || 'GET').toUpperCase(),
            extraParams: refined.extraParams,
            startParam: refined.startParam,
            endParam: refined.endParam,
            timeZoneParam: refined.timeZoneParam
          };
        }

        return null;
      },
      fetch: function (arg, success, failure) {
        var meta = arg.eventSource.meta;
        var requestParams = buildRequestParams(meta, arg.range, arg.context);
        requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {
          success({
            rawEvents: rawEvents,
            xhr: xhr
          });
        }, function (errorMessage, xhr) {
          failure({
            message: errorMessage,
            xhr: xhr
          });
        });
      }
    };
    var jsonFeedEventSourcePlugin = createPlugin({
      eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
      eventSourceDefs: [eventSourceDef]
    });

    function buildRequestParams(meta, range, context) {
      var dateEnv = context.dateEnv,
          options = context.options;
      var startParam;
      var endParam;
      var timeZoneParam;
      var customRequestParams;
      var params = {};
      startParam = meta.startParam;

      if (startParam == null) {
        startParam = options.startParam;
      }

      endParam = meta.endParam;

      if (endParam == null) {
        endParam = options.endParam;
      }

      timeZoneParam = meta.timeZoneParam;

      if (timeZoneParam == null) {
        timeZoneParam = options.timeZoneParam;
      } // retrieve any outbound GET/POST data from the options


      if (typeof meta.extraParams === 'function') {
        // supplied as a function that returns a key/value object
        customRequestParams = meta.extraParams();
      } else {
        // probably supplied as a straight key/value object
        customRequestParams = meta.extraParams || {};
      }

      __assign(params, customRequestParams);

      params[startParam] = dateEnv.formatIso(range.start);
      params[endParam] = dateEnv.formatIso(range.end);

      if (dateEnv.timeZone !== 'local') {
        params[timeZoneParam] = dateEnv.timeZone;
      }

      return params;
    }

    var SIMPLE_RECURRING_REFINERS = {
      daysOfWeek: identity,
      startTime: createDuration,
      endTime: createDuration,
      duration: createDuration,
      startRecur: identity,
      endRecur: identity
    };
    var recurring = {
      parse: function (refined, dateEnv) {
        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
          var recurringData = {
            daysOfWeek: refined.daysOfWeek || null,
            startTime: refined.startTime || null,
            endTime: refined.endTime || null,
            startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
            endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
          };
          var duration = void 0;

          if (refined.duration) {
            duration = refined.duration;
          }

          if (!duration && refined.startTime && refined.endTime) {
            duration = subtractDurations(refined.endTime, refined.startTime);
          }

          return {
            allDayGuess: Boolean(!refined.startTime && !refined.endTime),
            duration: duration,
            typeData: recurringData // doesn't need endTime anymore but oh well

          };
        }

        return null;
      },
      expand: function (typeData, framingRange, dateEnv) {
        var clippedFramingRange = intersectRanges(framingRange, {
          start: typeData.startRecur,
          end: typeData.endRecur
        });

        if (clippedFramingRange) {
          return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
        }

        return [];
      }
    };
    var simpleRecurringEventsPlugin = createPlugin({
      recurringTypes: [recurring],
      eventRefiners: SIMPLE_RECURRING_REFINERS
    });

    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
      var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
      var dayMarker = startOfDay(framingRange.start);
      var endMarker = framingRange.end;
      var instanceStarts = [];

      while (dayMarker < endMarker) {
        var instanceStart // if everyday, or this particular day-of-week
        = void 0; // if everyday, or this particular day-of-week

        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
          if (startTime) {
            instanceStart = dateEnv.add(dayMarker, startTime);
          } else {
            instanceStart = dayMarker;
          }

          instanceStarts.push(instanceStart);
        }

        dayMarker = addDays(dayMarker, 1);
      }

      return instanceStarts;
    }

    var changeHandlerPlugin = createPlugin({
      optionChangeHandlers: {
        events: function (events, context) {
          handleEventSources([events], context);
        },
        eventSources: handleEventSources
      }
    });
    /*
    BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out
    */

    function handleEventSources(inputs, context) {
      var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
      var newInputs = [];

      for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
        var input = inputs_1[_i];
        var inputFound = false;

        for (var i = 0; i < unfoundSources.length; i += 1) {
          if (unfoundSources[i]._raw === input) {
            unfoundSources.splice(i, 1); // delete

            inputFound = true;
            break;
          }
        }

        if (!inputFound) {
          newInputs.push(input);
        }
      }

      for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {
        var unfoundSource = unfoundSources_1[_a];
        context.dispatch({
          type: 'REMOVE_EVENT_SOURCE',
          sourceId: unfoundSource.sourceId
        });
      }

      for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {
        var newInput = newInputs_1[_b];
        context.calendarApi.addEventSource(newInput);
      }
    }

    function handleDateProfile(dateProfile, context) {
      context.emitter.trigger('datesSet', __assign(__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {
        view: context.viewApi
      }));
    }

    function handleEventStore(eventStore, context) {
      var emitter = context.emitter;

      if (emitter.hasHandlers('eventsSet')) {
        emitter.trigger('eventsSet', buildEventApis(eventStore, context));
      }
    }
    /*
    this array is exposed on the root namespace so that UMD plugins can add to it.
    see the rollup-bundles script.
    */


    var globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({
      isLoadingFuncs: [function (state) {
        return computeEventSourcesLoading(state.eventSources);
      }],
      contentTypeHandlers: {
        html: function () {
          return {
            render: injectHtml
          };
        },
        domNodes: function () {
          return {
            render: injectDomNodes
          };
        }
      },
      propSetHandlers: {
        dateProfile: handleDateProfile,
        eventStore: handleEventStore
      }
    })];

    function injectHtml(el, html) {
      el.innerHTML = html;
    }

    function injectDomNodes(el, domNodes) {
      var oldNodes = Array.prototype.slice.call(el.childNodes); // TODO: use array util

      var newNodes = Array.prototype.slice.call(domNodes); // TODO: use array util

      if (!isArraysEqual(oldNodes, newNodes)) {
        for (var _i = 0, newNodes_1 = newNodes; _i < newNodes_1.length; _i++) {
          var newNode = newNodes_1[_i];
          el.appendChild(newNode);
        }

        oldNodes.forEach(removeElement);
      }
    }

    var DelayedRunner = function () {
      function DelayedRunner(drainedOption) {
        this.drainedOption = drainedOption;
        this.isRunning = false;
        this.isDirty = false;
        this.pauseDepths = {};
        this.timeoutId = 0;
      }

      DelayedRunner.prototype.request = function (delay) {
        this.isDirty = true;

        if (!this.isPaused()) {
          this.clearTimeout();

          if (delay == null) {
            this.tryDrain();
          } else {
            this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce
            this.tryDrain.bind(this), delay);
          }
        }
      };

      DelayedRunner.prototype.pause = function (scope) {
        if (scope === void 0) {
          scope = '';
        }

        var pauseDepths = this.pauseDepths;
        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
        this.clearTimeout();
      };

      DelayedRunner.prototype.resume = function (scope, force) {
        if (scope === void 0) {
          scope = '';
        }

        var pauseDepths = this.pauseDepths;

        if (scope in pauseDepths) {
          if (force) {
            delete pauseDepths[scope];
          } else {
            pauseDepths[scope] -= 1;
            var depth = pauseDepths[scope];

            if (depth <= 0) {
              delete pauseDepths[scope];
            }
          }

          this.tryDrain();
        }
      };

      DelayedRunner.prototype.isPaused = function () {
        return Object.keys(this.pauseDepths).length;
      };

      DelayedRunner.prototype.tryDrain = function () {
        if (!this.isRunning && !this.isPaused()) {
          this.isRunning = true;

          while (this.isDirty) {
            this.isDirty = false;
            this.drained(); // might set isDirty to true again
          }

          this.isRunning = false;
        }
      };

      DelayedRunner.prototype.clear = function () {
        this.clearTimeout();
        this.isDirty = false;
        this.pauseDepths = {};
      };

      DelayedRunner.prototype.clearTimeout = function () {
        if (this.timeoutId) {
          clearTimeout(this.timeoutId);
          this.timeoutId = 0;
        }
      };

      DelayedRunner.prototype.drained = function () {
        if (this.drainedOption) {
          this.drainedOption();
        }
      };

      return DelayedRunner;
    }();

    var TaskRunner = function () {
      function TaskRunner(runTaskOption, drainedOption) {
        this.runTaskOption = runTaskOption;
        this.drainedOption = drainedOption;
        this.queue = [];
        this.delayedRunner = new DelayedRunner(this.drain.bind(this));
      }

      TaskRunner.prototype.request = function (task, delay) {
        this.queue.push(task);
        this.delayedRunner.request(delay);
      };

      TaskRunner.prototype.pause = function (scope) {
        this.delayedRunner.pause(scope);
      };

      TaskRunner.prototype.resume = function (scope, force) {
        this.delayedRunner.resume(scope, force);
      };

      TaskRunner.prototype.drain = function () {
        var queue = this.queue;

        while (queue.length) {
          var completedTasks = [];
          var task = void 0;

          while (task = queue.shift()) {
            this.runTask(task);
            completedTasks.push(task);
          }

          this.drained(completedTasks);
        } // keep going, in case new tasks were added in the drained handler

      };

      TaskRunner.prototype.runTask = function (task) {
        if (this.runTaskOption) {
          this.runTaskOption(task);
        }
      };

      TaskRunner.prototype.drained = function (completedTasks) {
        if (this.drainedOption) {
          this.drainedOption(completedTasks);
        }
      };

      return TaskRunner;
    }(); // Computes what the title at the top of the calendarApi should be for this view


    function buildTitle(dateProfile, viewOptions, dateEnv) {
      var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after

      if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
        range = dateProfile.currentRange;
      } else {
        // for day units or smaller, use the actual day range
        range = dateProfile.activeRange;
      }

      return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
        isEndExclusive: dateProfile.isRangeAllDay,
        defaultSeparator: viewOptions.titleRangeSeparator
      });
    } // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.


    function buildTitleFormat(dateProfile) {
      var currentRangeUnit = dateProfile.currentRangeUnit;

      if (currentRangeUnit === 'year') {
        return {
          year: 'numeric'
        };
      }

      if (currentRangeUnit === 'month') {
        return {
          year: 'numeric',
          month: 'long'
        }; // like "September 2014"
      }

      var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);

      if (days !== null && days > 1) {
        // multi-day range. shorter, like "Sep 9 - 10 2014"
        return {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        };
      } // one day. longer, like "September 9 2014"


      return {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      };
    } // in future refactor, do the redux-style function(state=initial) for initial-state
    // also, whatever is happening in constructor, have it happen in action queue too


    var CalendarDataManager = function () {
      function CalendarDataManager(props) {
        var _this = this;

        this.computeOptionsData = memoize(this._computeOptionsData);
        this.computeCurrentViewData = memoize(this._computeCurrentViewData);
        this.organizeRawLocales = memoize(organizeRawLocales);
        this.buildLocale = memoize(buildLocale);
        this.buildPluginHooks = buildBuildPluginHooks();
        this.buildDateEnv = memoize(buildDateEnv);
        this.buildTheme = memoize(buildTheme);
        this.parseToolbars = memoize(parseToolbars);
        this.buildViewSpecs = memoize(buildViewSpecs);
        this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
        this.buildViewApi = memoize(buildViewApi);
        this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
        this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
        this.buildEventUiBases = memoize(buildEventUiBases);
        this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
        this.buildTitle = memoize(buildTitle);
        this.emitter = new Emitter();
        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
        this.currentCalendarOptionsInput = {};
        this.currentCalendarOptionsRefined = {};
        this.currentViewOptionsInput = {};
        this.currentViewOptionsRefined = {};
        this.currentCalendarOptionsRefiners = {};

        this.getCurrentData = function () {
          return _this.data;
        };

        this.dispatch = function (action) {
          _this.actionRunner.request(action); // protects against recursive calls to _handleAction

        };

        this.props = props;
        this.actionRunner.pause();
        var dynamicOptionOverrides = {};
        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
        var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up
        // TODO: not DRY

        props.calendarApi.currentDataManager = this;
        this.emitter.setThisContext(props.calendarApi);
        this.emitter.setOptions(currentViewData.options);
        var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
        var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);

        if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
          currentDate = dateProfile.currentRange.start;
        }

        var calendarContext = {
          dateEnv: optionsData.dateEnv,
          options: optionsData.calendarOptions,
          pluginHooks: optionsData.pluginHooks,
          calendarApi: props.calendarApi,
          dispatch: this.dispatch,
          emitter: this.emitter,
          getCurrentData: this.getCurrentData
        }; // needs to be after setThisContext

        for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {
          var callback = _a[_i];
          callback(calendarContext);
        } // NOT DRY


        var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
        var initialState = {
          dynamicOptionOverrides: dynamicOptionOverrides,
          currentViewType: currentViewType,
          currentDate: currentDate,
          dateProfile: dateProfile,
          businessHours: this.parseContextBusinessHours(calendarContext),
          eventSources: eventSources,
          eventUiBases: {},
          eventStore: createEmptyEventStore(),
          renderableEventStore: createEmptyEventStore(),
          dateSelection: null,
          eventSelection: '',
          eventDrag: null,
          eventResize: null,
          selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
        };

        var contextAndState = __assign(__assign({}, calendarContext), initialState);

        for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {
          var reducer = _c[_b];

          __assign(initialState, reducer(null, null, contextAndState));
        }

        if (computeIsLoading(initialState, calendarContext)) {
          this.emitter.trigger('loading', true); // NOT DRY
        }

        this.state = initialState;
        this.updateData();
        this.actionRunner.resume();
      }

      CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {
        var props = this.props;
        props.optionOverrides = append ? __assign(__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;
        this.actionRunner.request({
          type: 'NOTHING'
        });
      };

      CalendarDataManager.prototype._handleAction = function (action) {
        var _a = this,
            props = _a.props,
            state = _a.state,
            emitter = _a.emitter;

        var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
        var currentViewType = reduceViewType(state.currentViewType, action);
        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up
        // TODO: not DRY

        props.calendarApi.currentDataManager = this;
        emitter.setThisContext(props.calendarApi);
        emitter.setOptions(currentViewData.options);
        var calendarContext = {
          dateEnv: optionsData.dateEnv,
          options: optionsData.calendarOptions,
          pluginHooks: optionsData.pluginHooks,
          calendarApi: props.calendarApi,
          dispatch: this.dispatch,
          emitter: emitter,
          getCurrentData: this.getCurrentData
        };
        var currentDate = state.currentDate,
            dateProfile = state.dateProfile;

        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
          // hack
          dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
        }

        currentDate = reduceCurrentDate(currentDate, action);
        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);

        if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator
        action.type === 'NEXT' || // "
        !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
          currentDate = dateProfile.currentRange.start;
        }

        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
        var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
        var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading

        var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state
        eventStore;

        var _b = this.buildViewUiProps(calendarContext),
            eventUiSingleBase = _b.eventUiSingleBase,
            selectionConfig = _b.selectionConfig; // will memoize obj


        var eventUiBySource = this.buildEventUiBySource(eventSources);
        var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
        var newState = {
          dynamicOptionOverrides: dynamicOptionOverrides,
          currentViewType: currentViewType,
          currentDate: currentDate,
          dateProfile: dateProfile,
          eventSources: eventSources,
          eventStore: eventStore,
          renderableEventStore: renderableEventStore,
          selectionConfig: selectionConfig,
          eventUiBases: eventUiBases,
          businessHours: this.parseContextBusinessHours(calendarContext),
          dateSelection: reduceDateSelection(state.dateSelection, action),
          eventSelection: reduceSelectedEvent(state.eventSelection, action),
          eventDrag: reduceEventDrag(state.eventDrag, action),
          eventResize: reduceEventResize(state.eventResize, action)
        };

        var contextAndState = __assign(__assign({}, calendarContext), newState);

        for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {
          var reducer = _c[_i];

          __assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value

        }

        var wasLoading = computeIsLoading(state, calendarContext);
        var isLoading = computeIsLoading(newState, calendarContext); // TODO: use propSetHandlers in plugin system

        if (!wasLoading && isLoading) {
          emitter.trigger('loading', true);
        } else if (wasLoading && !isLoading) {
          emitter.trigger('loading', false);
        }

        this.state = newState;

        if (props.onAction) {
          props.onAction(action);
        }
      };

      CalendarDataManager.prototype.updateData = function () {
        var _a = this,
            props = _a.props,
            state = _a.state;

        var oldData = this.data;
        var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
        var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);

        var data = this.data = __assign(__assign(__assign({
          viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),
          calendarApi: props.calendarApi,
          dispatch: this.dispatch,
          emitter: this.emitter,
          getCurrentData: this.getCurrentData
        }, optionsData), currentViewData), state);

        var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
        var oldCalendarOptions = oldData && oldData.calendarOptions;
        var newCalendarOptions = optionsData.calendarOptions;

        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
          if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
            // hack
            state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
            state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
          }

          for (var optionName in changeHandlers) {
            if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
              changeHandlers[optionName](newCalendarOptions[optionName], data);
            }
          }
        }

        if (props.onData) {
          props.onData(data);
        }
      };

      CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {
        // TODO: blacklist options that are handled by optionChangeHandlers
        var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),
            refinedOptions = _a.refinedOptions,
            pluginHooks = _a.pluginHooks,
            localeDefaults = _a.localeDefaults,
            availableLocaleData = _a.availableLocaleData,
            extra = _a.extra;

        warnUnknownOptions(extra);
        var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
        var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);
        var theme = this.buildTheme(refinedOptions, pluginHooks);
        var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);
        return {
          calendarOptions: refinedOptions,
          pluginHooks: pluginHooks,
          dateEnv: dateEnv,
          viewSpecs: viewSpecs,
          theme: theme,
          toolbarConfig: toolbarConfig,
          localeDefaults: localeDefaults,
          availableRawLocales: availableLocaleData.map
        };
      }; // always called from behind a memoizer


      CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {
        var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),
            locales = _a.locales,
            locale = _a.locale;

        var availableLocaleData = this.organizeRawLocales(locales);
        var availableRawLocales = availableLocaleData.map;
        var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
        var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);

        var refiners = this.currentCalendarOptionsRefiners = __assign(__assign(__assign(__assign(__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);

        var extra = {};
        var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);
        var refined = {};
        var currentRaw = this.currentCalendarOptionsInput;
        var currentRefined = this.currentCalendarOptionsRefined;
        var anyChanges = false;

        for (var optionName in raw) {
          if (optionName !== 'plugins') {
            // because plugins is special-cased
            if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {
              refined[optionName] = currentRefined[optionName];
            } else if (refiners[optionName]) {
              refined[optionName] = refiners[optionName](raw[optionName]);
              anyChanges = true;
            } else {
              extra[optionName] = currentRaw[optionName];
            }
          }
        }

        if (anyChanges) {
          this.currentCalendarOptionsInput = raw;
          this.currentCalendarOptionsRefined = refined;
        }

        return {
          rawOptions: this.currentCalendarOptionsInput,
          refinedOptions: this.currentCalendarOptionsRefined,
          pluginHooks: pluginHooks,
          availableLocaleData: availableLocaleData,
          localeDefaults: localeDefaults,
          extra: extra
        };
      };

      CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
        var viewSpec = optionsData.viewSpecs[viewType];

        if (!viewSpec) {
          throw new Error("viewType \"" + viewType + "\" is not available. Please make sure you've loaded all neccessary plugins");
        }

        var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),
            refinedOptions = _a.refinedOptions,
            extra = _a.extra;

        warnUnknownOptions(extra);
        var dateProfileGenerator = this.buildDateProfileGenerator({
          dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
          duration: viewSpec.duration,
          durationUnit: viewSpec.durationUnit,
          usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
          dateEnv: optionsData.dateEnv,
          calendarApi: this.props.calendarApi,
          slotMinTime: refinedOptions.slotMinTime,
          slotMaxTime: refinedOptions.slotMaxTime,
          showNonCurrentDates: refinedOptions.showNonCurrentDates,
          dayCount: refinedOptions.dayCount,
          dateAlignment: refinedOptions.dateAlignment,
          dateIncrement: refinedOptions.dateIncrement,
          hiddenDays: refinedOptions.hiddenDays,
          weekends: refinedOptions.weekends,
          nowInput: refinedOptions.now,
          validRangeInput: refinedOptions.validRange,
          visibleRangeInput: refinedOptions.visibleRange,
          monthMode: refinedOptions.monthMode,
          fixedWeekCount: refinedOptions.fixedWeekCount
        });
        var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
        return {
          viewSpec: viewSpec,
          options: refinedOptions,
          dateProfileGenerator: dateProfileGenerator,
          viewApi: viewApi
        };
      };

      CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
        var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);

        var refiners = __assign(__assign(__assign(__assign(__assign(__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);

        var refined = {};
        var currentRaw = this.currentViewOptionsInput;
        var currentRefined = this.currentViewOptionsRefined;
        var anyChanges = false;
        var extra = {};

        for (var optionName in raw) {
          if (raw[optionName] === currentRaw[optionName]) {
            refined[optionName] = currentRefined[optionName];
          } else {
            if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {
              if (optionName in this.currentCalendarOptionsRefined) {
                // might be an "extra" prop
                refined[optionName] = this.currentCalendarOptionsRefined[optionName];
              }
            } else if (refiners[optionName]) {
              refined[optionName] = refiners[optionName](raw[optionName]);
            } else {
              extra[optionName] = raw[optionName];
            }

            anyChanges = true;
          }
        }

        if (anyChanges) {
          this.currentViewOptionsInput = raw;
          this.currentViewOptionsRefined = refined;
        }

        return {
          rawOptions: this.currentViewOptionsInput,
          refinedOptions: this.currentViewOptionsRefined,
          extra: extra
        };
      };

      return CalendarDataManager;
    }();

    function buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
      var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
      return new DateEnv({
        calendarSystem: 'gregory',
        timeZone: timeZone,
        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
        locale: locale,
        weekNumberCalculation: weekNumberCalculation,
        firstDay: firstDay,
        weekText: weekText,
        cmdFormatter: pluginHooks.cmdFormatter,
        defaultSeparator: defaultSeparator
      });
    }

    function buildTheme(options, pluginHooks) {
      var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
      return new ThemeClass(options);
    }

    function buildDateProfileGenerator(props) {
      var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
      return new DateProfileGeneratorClass(props);
    }

    function buildViewApi(type, getCurrentData, dateEnv) {
      return new ViewApi(type, getCurrentData, dateEnv);
    }

    function buildEventUiBySource(eventSources) {
      return mapHash(eventSources, function (eventSource) {
        return eventSource.ui;
      });
    }

    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
      var eventUiBases = {
        '': eventUiSingleBase
      };

      for (var defId in eventDefs) {
        var def = eventDefs[defId];

        if (def.sourceId && eventUiBySource[def.sourceId]) {
          eventUiBases[defId] = eventUiBySource[def.sourceId];
        }
      }

      return eventUiBases;
    }

    function buildViewUiProps(calendarContext) {
      var options = calendarContext.options;
      return {
        eventUiSingleBase: createEventUi({
          display: options.eventDisplay,
          editable: options.editable,
          startEditable: options.eventStartEditable,
          durationEditable: options.eventDurationEditable,
          constraint: options.eventConstraint,
          overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,
          allow: options.eventAllow,
          backgroundColor: options.eventBackgroundColor,
          borderColor: options.eventBorderColor,
          textColor: options.eventTextColor,
          color: options.eventColor // classNames: options.eventClassNames // render hook will handle this

        }, calendarContext),
        selectionConfig: createEventUi({
          constraint: options.selectConstraint,
          overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,
          allow: options.selectAllow
        }, calendarContext)
      };
    }

    function computeIsLoading(state, context) {
      for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {
        var isLoadingFunc = _a[_i];

        if (isLoadingFunc(state)) {
          return true;
        }
      }

      return false;
    }

    function parseContextBusinessHours(calendarContext) {
      return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
    }

    function warnUnknownOptions(options, viewName) {
      for (var optionName in options) {
        console.warn("Unknown option '" + optionName + "'" + (viewName ? " for view '" + viewName + "'" : ''));
      }
    } // TODO: move this to react plugin?


    (function (_super) {
      __extends(CalendarDataProvider, _super);

      function CalendarDataProvider(props) {
        var _this = _super.call(this, props) || this;

        _this.handleData = function (data) {
          if (!_this.dataManager) {
            // still within initial run, before assignment in constructor
            // eslint-disable-next-line react/no-direct-mutation-state
            _this.state = data; // can't use setState yet
          } else {
            _this.setState(data);
          }
        };

        _this.dataManager = new CalendarDataManager({
          optionOverrides: props.optionOverrides,
          calendarApi: props.calendarApi,
          onData: _this.handleData
        });
        return _this;
      }

      CalendarDataProvider.prototype.render = function () {
        return this.props.children(this.state);
      };

      CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {
        var newOptionOverrides = this.props.optionOverrides;

        if (newOptionOverrides !== prevProps.optionOverrides) {
          // prevent recursive handleData
          this.dataManager.resetOptions(newOptionOverrides);
        }
      };

      return CalendarDataProvider;
    })(Component); // HELPERS

    var SegHierarchy = function () {
      function SegHierarchy() {
        // settings
        this.strictOrder = false;
        this.allowReslicing = false;
        this.maxCoord = -1; // -1 means no max

        this.maxStackCnt = -1; // -1 means no max

        this.levelCoords = []; // ordered

        this.entriesByLevel = []; // parallel with levelCoords

        this.stackCnts = {}; // TODO: use better technique!?
      }

      SegHierarchy.prototype.addSegs = function (inputs) {
        var hiddenEntries = [];

        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
          var input = inputs_1[_i];
          this.insertEntry(input, hiddenEntries);
        }

        return hiddenEntries;
      };

      SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {
        var insertion = this.findInsertion(entry);

        if (this.isInsertionValid(insertion, entry)) {
          this.insertEntryAt(entry, insertion);
          return 1;
        }

        return this.handleInvalidInsertion(insertion, entry, hiddenEntries);
      };

      SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {
        return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
      }; // returns number of new entries inserted


      SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {
        if (this.allowReslicing && insertion.touchingEntry) {
          return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
        }

        hiddenEntries.push(entry);
        return 0;
      };

      SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {
        var partCnt = 0;
        var splitHiddenEntries = [];
        var entrySpan = entry.span;
        var barrierSpan = barrier.span;

        if (entrySpan.start < barrierSpan.start) {
          partCnt += this.insertEntry({
            index: entry.index,
            thickness: entry.thickness,
            span: {
              start: entrySpan.start,
              end: barrierSpan.start
            }
          }, splitHiddenEntries);
        }

        if (entrySpan.end > barrierSpan.end) {
          partCnt += this.insertEntry({
            index: entry.index,
            thickness: entry.thickness,
            span: {
              start: barrierSpan.end,
              end: entrySpan.end
            }
          }, splitHiddenEntries);
        }

        if (partCnt) {
          hiddenEntries.push.apply(hiddenEntries, __spreadArray([{
            index: entry.index,
            thickness: entry.thickness,
            span: intersectSpans(barrierSpan, entrySpan) // guaranteed to intersect

          }], splitHiddenEntries));
          return partCnt;
        }

        hiddenEntries.push(entry);
        return 0;
      };

      SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {
        var _a = this,
            entriesByLevel = _a.entriesByLevel,
            levelCoords = _a.levelCoords;

        if (insertion.lateral === -1) {
          // create a new level
          insertAt(levelCoords, insertion.level, insertion.levelCoord);
          insertAt(entriesByLevel, insertion.level, [entry]);
        } else {
          // insert into existing level
          insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
        }

        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
      };

      SegHierarchy.prototype.findInsertion = function (newEntry) {
        var _a = this,
            levelCoords = _a.levelCoords,
            entriesByLevel = _a.entriesByLevel,
            strictOrder = _a.strictOrder,
            stackCnts = _a.stackCnts;

        var levelCnt = levelCoords.length;
        var candidateCoord = 0;
        var touchingLevel = -1;
        var touchingLateral = -1;
        var touchingEntry = null;
        var stackCnt = 0;

        for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
          var trackingCoord = levelCoords[trackingLevel]; // if the current level is past the placed entry, we have found a good empty space and can stop.
          // if strictOrder, keep finding more lateral intersections.

          if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {
            break;
          }

          var trackingEntries = entriesByLevel[trackingLevel];
          var trackingEntry = void 0;
          var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end

          var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one

          while ( // loop through entries that horizontally intersect
          (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
          trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry
          ) {
            var trackingEntryBottom = trackingCoord + trackingEntry.thickness; // intersects into the top of the candidate?

            if (trackingEntryBottom > candidateCoord) {
              candidateCoord = trackingEntryBottom;
              touchingEntry = trackingEntry;
              touchingLevel = trackingLevel;
              touchingLateral = lateralIndex;
            } // butts up against top of candidate? (will happen if just intersected as well)


            if (trackingEntryBottom === candidateCoord) {
              // accumulate the highest possible stackCnt of the trackingEntries that butt up
              stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
            }

            lateralIndex += 1;
          }
        } // the destination level will be after touchingEntry's level. find it


        var destLevel = 0;

        if (touchingEntry) {
          destLevel = touchingLevel + 1;

          while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
            destLevel += 1;
          }
        } // if adding to an existing level, find where to insert


        var destLateral = -1;

        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
          destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
        }

        return {
          touchingLevel: touchingLevel,
          touchingLateral: touchingLateral,
          touchingEntry: touchingEntry,
          stackCnt: stackCnt,
          levelCoord: candidateCoord,
          level: destLevel,
          lateral: destLateral
        };
      }; // sorted by levelCoord (lowest to highest)


      SegHierarchy.prototype.toRects = function () {
        var _a = this,
            entriesByLevel = _a.entriesByLevel,
            levelCoords = _a.levelCoords;

        var levelCnt = entriesByLevel.length;
        var rects = [];

        for (var level = 0; level < levelCnt; level += 1) {
          var entries = entriesByLevel[level];
          var levelCoord = levelCoords[level];

          for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            rects.push(__assign(__assign({}, entry), {
              levelCoord: levelCoord
            }));
          }
        }

        return rects;
      };

      return SegHierarchy;
    }();

    function getEntrySpanEnd(entry) {
      return entry.span.end;
    }

    function buildEntryKey(entry) {
      return entry.index + ':' + entry.span.start;
    } // returns groups with entries sorted by input order

    function intersectSpans(span0, span1) {
      var start = Math.max(span0.start, span1.start);
      var end = Math.min(span0.end, span1.end);

      if (start < end) {
        return {
          start: start,
          end: end
        };
      }

      return null;
    } // general util
    // ---------------------------------------------------------------------------------------------------------------------


    function insertAt(arr, index, item) {
      arr.splice(index, 0, item);
    }

    function binarySearch(a, searchVal, getItemVal) {
      var startIndex = 0;
      var endIndex = a.length; // exclusive

      if (!endIndex || searchVal < getItemVal(a[startIndex])) {
        // no items OR before first item
        return [0, 0];
      }

      if (searchVal > getItemVal(a[endIndex - 1])) {
        // after last item
        return [endIndex, 0];
      }

      while (startIndex < endIndex) {
        var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
        var middleVal = getItemVal(a[middleIndex]);

        if (searchVal < middleVal) {
          endIndex = middleIndex;
        } else if (searchVal > middleVal) {
          startIndex = middleIndex + 1;
        } else {
          // equal!
          return [middleIndex, 1];
        }
      }

      return [startIndex, 0];
    }

    var Interaction = function () {
      function Interaction(settings) {
        this.component = settings.component;
        this.isHitComboAllowed = settings.isHitComboAllowed || null;
      }

      Interaction.prototype.destroy = function () {};

      return Interaction;
    }();

    function parseInteractionSettings(component, input) {
      return {
        component: component,
        el: input.el,
        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
        isHitComboAllowed: input.isHitComboAllowed || null
      };
    }


    var interactionSettingsStore = {};

    var ToolbarSection = function (_super) {
      __extends(ToolbarSection, _super);

      function ToolbarSection() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      ToolbarSection.prototype.render = function () {
        var _this = this;

        var children = this.props.widgetGroups.map(function (widgetGroup) {
          return _this.renderWidgetGroup(widgetGroup);
        });
        return createElement.apply(void 0, __spreadArray(['div', {
          className: 'fc-toolbar-chunk'
        }], children));
      };

      ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {
        var props = this.props;
        var theme = this.context.theme;
        var children = [];
        var isOnlyButtons = true;

        for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {
          var widget = widgetGroup_1[_i];
          var buttonName = widget.buttonName,
              buttonClick = widget.buttonClick,
              buttonText = widget.buttonText,
              buttonIcon = widget.buttonIcon;

          if (buttonName === 'title') {
            isOnlyButtons = false;
            children.push(createElement("h2", {
              className: "fc-toolbar-title"
            }, props.title));
          } else {
            var ariaAttrs = buttonIcon ? {
              'aria-label': buttonName
            } : {};
            var buttonClasses = ["fc-" + buttonName + "-button", theme.getClass('button')];

            if (buttonName === props.activeButton) {
              buttonClasses.push(theme.getClass('buttonActive'));
            }

            var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';
            children.push(createElement("button", __assign({
              disabled: isDisabled,
              className: buttonClasses.join(' '),
              onClick: buttonClick,
              type: "button"
            }, ariaAttrs), buttonText || (buttonIcon ? createElement("span", {
              className: buttonIcon
            }) : '')));
          }
        }

        if (children.length > 1) {
          var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';
          return createElement.apply(void 0, __spreadArray(['div', {
            className: groupClassName
          }], children));
        }

        return children[0];
      };

      return ToolbarSection;
    }(BaseComponent);

    var Toolbar = function (_super) {
      __extends(Toolbar, _super);

      function Toolbar() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      Toolbar.prototype.render = function () {
        var _a = this.props,
            model = _a.model,
            extraClassName = _a.extraClassName;
        var forceLtr = false;
        var startContent;
        var endContent;
        var centerContent = model.center;

        if (model.left) {
          forceLtr = true;
          startContent = model.left;
        } else {
          startContent = model.start;
        }

        if (model.right) {
          forceLtr = true;
          endContent = model.right;
        } else {
          endContent = model.end;
        }

        var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];
        return createElement("div", {
          className: classNames.join(' ')
        }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));
      };

      Toolbar.prototype.renderSection = function (key, widgetGroups) {
        var props = this.props;
        return createElement(ToolbarSection, {
          key: key,
          widgetGroups: widgetGroups,
          title: props.title,
          activeButton: props.activeButton,
          isTodayEnabled: props.isTodayEnabled,
          isPrevEnabled: props.isPrevEnabled,
          isNextEnabled: props.isNextEnabled
        });
      };

      return Toolbar;
    }(BaseComponent); // TODO: do function component?


    var ViewContainer = function (_super) {
      __extends(ViewContainer, _super);

      function ViewContainer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.state = {
          availableWidth: null
        };

        _this.handleEl = function (el) {
          _this.el = el;
          setRef(_this.props.elRef, el);

          _this.updateAvailableWidth();
        };

        _this.handleResize = function () {
          _this.updateAvailableWidth();
        };

        return _this;
      }

      ViewContainer.prototype.render = function () {
        var _a = this,
            props = _a.props,
            state = _a.state;

        var aspectRatio = props.aspectRatio;
        var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height
        : 'fc-view-harness-passive' // let the view do the height
        ];
        var height = '';
        var paddingBottom = '';

        if (aspectRatio) {
          if (state.availableWidth !== null) {
            height = state.availableWidth / aspectRatio;
          } else {
            // while waiting to know availableWidth, we can't set height to *zero*
            // because will cause lots of unnecessary scrollbars within scrollgrid.
            // BETTER: don't start rendering ANYTHING yet until we know container width
            // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)
            paddingBottom = 1 / aspectRatio * 100 + "%";
          }
        } else {
          height = props.height || '';
        }

        return createElement("div", {
          ref: this.handleEl,
          onClick: props.onClick,
          className: classNames.join(' '),
          style: {
            height: height,
            paddingBottom: paddingBottom
          }
        }, props.children);
      };

      ViewContainer.prototype.componentDidMount = function () {
        this.context.addResizeHandler(this.handleResize);
      };

      ViewContainer.prototype.componentWillUnmount = function () {
        this.context.removeResizeHandler(this.handleResize);
      };

      ViewContainer.prototype.updateAvailableWidth = function () {
        if (this.el && // needed. but why?
        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth
        ) {
          this.setState({
            availableWidth: this.el.offsetWidth
          });
        }
      };

      return ViewContainer;
    }(BaseComponent);
    /*
    Detects when the user clicks on an event within a DateComponent
    */


    var EventClicking = function (_super) {
      __extends(EventClicking, _super);

      function EventClicking(settings) {
        var _this = _super.call(this, settings) || this;

        _this.handleSegClick = function (ev, segEl) {
          var component = _this.component;
          var context = component.context;
          var seg = getElSeg(segEl);

          if (seg && // might be the <div> surrounding the more link
          component.isValidSegDownEl(ev.target)) {
            // our way to simulate a link click for elements that can't be <a> tags
            // grab before trigger fired in case trigger trashes DOM thru rerendering
            var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');
            var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
            context.emitter.trigger('eventClick', {
              el: segEl,
              event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),
              jsEvent: ev,
              view: context.viewApi
            });

            if (url && !ev.defaultPrevented) {
              window.location.href = url;
            }
          }
        };

        _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events
        _this.handleSegClick);
        return _this;
      }

      return EventClicking;
    }(Interaction);
    /*
    Triggers events and adds/removes core classNames when the user's pointer
    enters/leaves event-elements of a component.
    */


    var EventHovering = function (_super) {
      __extends(EventHovering, _super);

      function EventHovering(settings) {
        var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it


        _this.handleEventElRemove = function (el) {
          if (el === _this.currentSegEl) {
            _this.handleSegLeave(null, _this.currentSegEl);
          }
        };

        _this.handleSegEnter = function (ev, segEl) {
          if (getElSeg(segEl)) {
            // TODO: better way to make sure not hovering over more+ link or its wrapper
            _this.currentSegEl = segEl;

            _this.triggerEvent('eventMouseEnter', ev, segEl);
          }
        };

        _this.handleSegLeave = function (ev, segEl) {
          if (_this.currentSegEl) {
            _this.currentSegEl = null;

            _this.triggerEvent('eventMouseLeave', ev, segEl);
          }
        };

        _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events
        _this.handleSegEnter, _this.handleSegLeave);
        return _this;
      }

      EventHovering.prototype.destroy = function () {
        this.removeHoverListeners();
      };

      EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {
        var component = this.component;
        var context = component.context;
        var seg = getElSeg(segEl);

        if (!ev || component.isValidSegDownEl(ev.target)) {
          context.emitter.trigger(publicEvName, {
            el: segEl,
            event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),
            jsEvent: ev,
            view: context.viewApi
          });
        }
      };

      return EventHovering;
    }(Interaction);

    var CalendarContent = function (_super) {
      __extends(CalendarContent, _super);

      function CalendarContent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.buildViewContext = memoize(buildViewContext);
        _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
        _this.buildToolbarProps = memoize(buildToolbarProps);
        _this.handleNavLinkClick = buildDelegationHandler('a[data-navlink]', _this._handleNavLinkClick.bind(_this));
        _this.headerRef = createRef();
        _this.footerRef = createRef();
        _this.interactionsStore = {}; // Component Registration
        // -----------------------------------------------------------------------------------------------------------------

        _this.registerInteractiveComponent = function (component, settingsInput) {
          var settings = parseInteractionSettings(component, settingsInput);
          var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];
          var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);
          var interactions = interactionClasses.map(function (TheInteractionClass) {
            return new TheInteractionClass(settings);
          });
          _this.interactionsStore[component.uid] = interactions;
          interactionSettingsStore[component.uid] = settings;
        };

        _this.unregisterInteractiveComponent = function (component) {
          for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener.destroy();
          }

          delete _this.interactionsStore[component.uid];
          delete interactionSettingsStore[component.uid];
        }; // Resizing
        // -----------------------------------------------------------------------------------------------------------------


        _this.resizeRunner = new DelayedRunner(function () {
          _this.props.emitter.trigger('_resize', true); // should window resizes be considered "forced" ?


          _this.props.emitter.trigger('windowResize', {
            view: _this.props.viewApi
          });
        });

        _this.handleWindowResize = function (ev) {
          var options = _this.props.options;

          if (options.handleWindowResize && ev.target === window // avoid jqui events
          ) {
            _this.resizeRunner.request(options.windowResizeDelay);
          }
        };

        return _this;
      }
      /*
      renders INSIDE of an outer div
      */


      CalendarContent.prototype.render = function () {
        var props = this.props;
        var toolbarConfig = props.toolbarConfig,
            options = props.options;
        var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????
        props.viewTitle);
        var viewVGrow = false;
        var viewHeight = '';
        var viewAspectRatio;

        if (props.isHeightAuto || props.forPrint) {
          viewHeight = '';
        } else if (options.height != null) {
          viewVGrow = true;
        } else if (options.contentHeight != null) {
          viewHeight = options.contentHeight;
        } else {
          viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall
        }

        var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
        return createElement(ViewContextType.Provider, {
          value: viewContext
        }, toolbarConfig.headerToolbar && createElement(Toolbar, __assign({
          ref: this.headerRef,
          extraClassName: "fc-header-toolbar",
          model: toolbarConfig.headerToolbar
        }, toolbarProps)), createElement(ViewContainer, {
          liquid: viewVGrow,
          height: viewHeight,
          aspectRatio: viewAspectRatio,
          onClick: this.handleNavLinkClick
        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footerToolbar && createElement(Toolbar, __assign({
          ref: this.footerRef,
          extraClassName: "fc-footer-toolbar",
          model: toolbarConfig.footerToolbar
        }, toolbarProps)));
      };

      CalendarContent.prototype.componentDidMount = function () {
        var props = this.props;
        this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (CalendarInteractionClass) {
          return new CalendarInteractionClass(props);
        });
        window.addEventListener('resize', this.handleWindowResize);
        var propSetHandlers = props.pluginHooks.propSetHandlers;

        for (var propName in propSetHandlers) {
          propSetHandlers[propName](props[propName], props);
        }
      };

      CalendarContent.prototype.componentDidUpdate = function (prevProps) {
        var props = this.props;
        var propSetHandlers = props.pluginHooks.propSetHandlers;

        for (var propName in propSetHandlers) {
          if (props[propName] !== prevProps[propName]) {
            propSetHandlers[propName](props[propName], props);
          }
        }
      };

      CalendarContent.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this.handleWindowResize);
        this.resizeRunner.clear();

        for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {
          var interaction = _a[_i];
          interaction.destroy();
        }

        this.props.emitter.trigger('_unmount');
      };

      CalendarContent.prototype._handleNavLinkClick = function (ev, anchorEl) {
        var _a = this.props,
            dateEnv = _a.dateEnv,
            options = _a.options,
            calendarApi = _a.calendarApi;
        var navLinkOptions = anchorEl.getAttribute('data-navlink');
        navLinkOptions = navLinkOptions ? JSON.parse(navLinkOptions) : {};
        var dateMarker = dateEnv.createMarker(navLinkOptions.date);
        var viewType = navLinkOptions.type;
        var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;

        if (typeof customAction === 'function') {
          customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
        } else {
          if (typeof customAction === 'string') {
            viewType = customAction;
          }

          calendarApi.zoomTo(dateMarker, viewType);
        }
      };

      CalendarContent.prototype.buildAppendContent = function () {
        var props = this.props;
        var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {
          return buildAppendContent(props);
        });
        return createElement.apply(void 0, __spreadArray([Fragment, {}], children));
      };

      CalendarContent.prototype.renderView = function (props) {
        var pluginHooks = props.pluginHooks;
        var viewSpec = props.viewSpec;
        var viewProps = {
          dateProfile: props.dateProfile,
          businessHours: props.businessHours,
          eventStore: props.renderableEventStore,
          eventUiBases: props.eventUiBases,
          dateSelection: props.dateSelection,
          eventSelection: props.eventSelection,
          eventDrag: props.eventDrag,
          eventResize: props.eventResize,
          isHeightAuto: props.isHeightAuto,
          forPrint: props.forPrint
        };
        var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);

        for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
          var transformer = transformers_1[_i];

          __assign(viewProps, transformer.transform(viewProps, props));
        }

        var ViewComponent = viewSpec.component;
        return createElement(ViewComponent, __assign({}, viewProps));
      };

      return CalendarContent;
    }(PureComponent);

    function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
      // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid
      var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason

      var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
      var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
      return {
        title: title,
        activeButton: viewSpec.type,
        isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
        isPrevEnabled: prevInfo.isValid,
        isNextEnabled: nextInfo.isValid
      };
    } // Plugin
    // -----------------------------------------------------------------------------------------------------------------


    function buildViewPropTransformers(theClasses) {
      return theClasses.map(function (TheClass) {
        return new TheClass();
      });
    }

    var CalendarRoot = function (_super) {
      __extends(CalendarRoot, _super);

      function CalendarRoot() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.state = {
          forPrint: false
        };

        _this.handleBeforePrint = function () {
          _this.setState({
            forPrint: true
          });
        };

        _this.handleAfterPrint = function () {
          _this.setState({
            forPrint: false
          });
        };

        return _this;
      }

      CalendarRoot.prototype.render = function () {
        var props = this.props;
        var options = props.options;
        var forPrint = this.state.forPrint;
        var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';
        var height = !isHeightAuto && options.height != null ? options.height : '';
        var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', "fc-direction-" + options.direction, props.theme.getClass('root')];

        if (!getCanVGrowWithinCell()) {
          classNames.push('fc-liquid-hack');
        }

        return props.children(classNames, height, isHeightAuto, forPrint);
      };

      CalendarRoot.prototype.componentDidMount = function () {
        var emitter = this.props.emitter;
        emitter.on('_beforeprint', this.handleBeforePrint);
        emitter.on('_afterprint', this.handleAfterPrint);
      };

      CalendarRoot.prototype.componentWillUnmount = function () {
        var emitter = this.props.emitter;
        emitter.off('_beforeprint', this.handleBeforePrint);
        emitter.off('_afterprint', this.handleAfterPrint);
      };

      return CalendarRoot;
    }(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined


    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
      // if more than one week row, or if there are a lot of columns with not much space,
      // put just the day numbers will be in each cell
      if (!datesRepDistinctDays || dayCnt > 10) {
        return createFormatter({
          weekday: 'short'
        }); // "Sat"
      }

      if (dayCnt > 1) {
        return createFormatter({
          weekday: 'short',
          month: 'numeric',
          day: 'numeric',
          omitCommas: true
        }); // "Sat 11/12"
      }

      return createFormatter({
        weekday: 'long'
      }); // "Saturday"
    }

    var CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no

    function renderInner$1(hookProps) {
      return hookProps.text;
    }

    var TableDateCell = function (_super) {
      __extends(TableDateCell, _super);

      function TableDateCell() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TableDateCell.prototype.render = function () {
        var _a = this.context,
            dateEnv = _a.dateEnv,
            options = _a.options,
            theme = _a.theme,
            viewApi = _a.viewApi;
        var props = this.props;
        var date = props.date,
            dateProfile = props.dateProfile;
        var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
        var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
        var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink

        var navLinkAttrs = options.navLinks && !dayMeta.isDisabled && props.colCnt > 1 ? {
          'data-navlink': buildNavLinkData(date),
          tabIndex: 0
        } : {};

        var hookProps = __assign(__assign(__assign({
          date: dateEnv.toDate(date),
          view: viewApi
        }, props.extraHookProps), {
          text: text
        }), dayMeta);

        return createElement(RenderHook, {
          hookProps: hookProps,
          classNames: options.dayHeaderClassNames,
          content: options.dayHeaderContent,
          defaultContent: renderInner$1,
          didMount: options.dayHeaderDidMount,
          willUnmount: options.dayHeaderWillUnmount
        }, function (rootElRef, customClassNames, innerElRef, innerContent) {
          return createElement("th", __assign({
            ref: rootElRef,
            className: classNames.concat(customClassNames).join(' '),
            "data-date": !dayMeta.isDisabled ? formatDayString(date) : undefined,
            colSpan: props.colSpan
          }, props.extraDataAttrs), createElement("div", {
            className: "fc-scrollgrid-sync-inner"
          }, !dayMeta.isDisabled && createElement("a", __assign({
            ref: innerElRef,
            className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')
          }, navLinkAttrs), innerContent)));
        });
      };

      return TableDateCell;
    }(BaseComponent);

    var TableDowCell = function (_super) {
      __extends(TableDowCell, _super);

      function TableDowCell() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TableDowCell.prototype.render = function () {
        var props = this.props;
        var _a = this.context,
            dateEnv = _a.dateEnv,
            theme = _a.theme,
            viewApi = _a.viewApi,
            options = _a.options;
        var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT

        var dateMeta = {
          dow: props.dow,
          isDisabled: false,
          isFuture: false,
          isPast: false,
          isToday: false,
          isOther: false
        };
        var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);
        var text = dateEnv.format(date, props.dayHeaderFormat);

        var hookProps = __assign(__assign(__assign(__assign({
          // TODO: make this public?
          date: date
        }, dateMeta), {
          view: viewApi
        }), props.extraHookProps), {
          text: text
        });

        return createElement(RenderHook, {
          hookProps: hookProps,
          classNames: options.dayHeaderClassNames,
          content: options.dayHeaderContent,
          defaultContent: renderInner$1,
          didMount: options.dayHeaderDidMount,
          willUnmount: options.dayHeaderWillUnmount
        }, function (rootElRef, customClassNames, innerElRef, innerContent) {
          return createElement("th", __assign({
            ref: rootElRef,
            className: classNames.concat(customClassNames).join(' '),
            colSpan: props.colSpan
          }, props.extraDataAttrs), createElement("div", {
            className: "fc-scrollgrid-sync-inner"
          }, createElement("a", {
            className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),
            ref: innerElRef
          }, innerContent)));
        });
      };

      return TableDowCell;
    }(BaseComponent);

    var NowTimer = function (_super) {
      __extends(NowTimer, _super);

      function NowTimer(props, context) {
        var _this = _super.call(this, props, context) || this;

        _this.initialNowDate = getNow(context.options.now, context.dateEnv);
        _this.initialNowQueriedMs = new Date().valueOf();
        _this.state = _this.computeTiming().currentState;
        return _this;
      }

      NowTimer.prototype.render = function () {
        var _a = this,
            props = _a.props,
            state = _a.state;

        return props.children(state.nowDate, state.todayRange);
      };

      NowTimer.prototype.componentDidMount = function () {
        this.setTimeout();
      };

      NowTimer.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.unit !== this.props.unit) {
          this.clearTimeout();
          this.setTimeout();
        }
      };

      NowTimer.prototype.componentWillUnmount = function () {
        this.clearTimeout();
      };

      NowTimer.prototype.computeTiming = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
        var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
        var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
        var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf(); // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)
        // ensure no longer than a day

        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);
        return {
          currentState: {
            nowDate: currentUnitStart,
            todayRange: buildDayRange(currentUnitStart)
          },
          nextState: {
            nowDate: nextUnitStart,
            todayRange: buildDayRange(nextUnitStart)
          },
          waitMs: waitMs
        };
      };

      NowTimer.prototype.setTimeout = function () {
        var _this = this;

        var _a = this.computeTiming(),
            nextState = _a.nextState,
            waitMs = _a.waitMs;

        this.timeoutId = setTimeout(function () {
          _this.setState(nextState, function () {
            _this.setTimeout();
          });
        }, waitMs);
      };

      NowTimer.prototype.clearTimeout = function () {
        if (this.timeoutId) {
          clearTimeout(this.timeoutId);
        }
      };

      NowTimer.contextType = ViewContextType;
      return NowTimer;
    }(Component);

    function buildDayRange(date) {
      var start = startOfDay(date);
      var end = addDays(start, 1);
      return {
        start: start,
        end: end
      };
    }

    var DayHeader = function (_super) {
      __extends(DayHeader, _super);

      function DayHeader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
        return _this;
      }

      DayHeader.prototype.render = function () {
        var context = this.context;
        var _a = this.props,
            dates = _a.dates,
            dateProfile = _a.dateProfile,
            datesRepDistinctDays = _a.datesRepDistinctDays,
            renderIntro = _a.renderIntro;
        var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
        return createElement(NowTimer, {
          unit: "day"
        }, function (nowDate, todayRange) {
          return createElement("tr", null, renderIntro && renderIntro('day'), dates.map(function (date) {
            return datesRepDistinctDays ? createElement(TableDateCell, {
              key: date.toISOString(),
              date: date,
              dateProfile: dateProfile,
              todayRange: todayRange,
              colCnt: dates.length,
              dayHeaderFormat: dayHeaderFormat
            }) : createElement(TableDowCell, {
              key: date.getUTCDay(),
              dow: date.getUTCDay(),
              dayHeaderFormat: dayHeaderFormat
            });
          }));
        });
      };

      return DayHeader;
    }(BaseComponent);

    function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
      return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
    }

    var DaySeriesModel = function () {
      function DaySeriesModel(range, dateProfileGenerator) {
        var date = range.start;
        var end = range.end;
        var indices = [];
        var dates = [];
        var dayIndex = -1;

        while (date < end) {
          // loop each day from start to end
          if (dateProfileGenerator.isHiddenDay(date)) {
            indices.push(dayIndex + 0.5); // mark that it's between indices
          } else {
            dayIndex += 1;
            indices.push(dayIndex);
            dates.push(date);
          }

          date = addDays(date, 1);
        }

        this.dates = dates;
        this.indices = indices;
        this.cnt = dates.length;
      }

      DaySeriesModel.prototype.sliceRange = function (range) {
        var firstIndex = this.getDateDayIndex(range.start); // inclusive first index

        var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index

        var clippedFirstIndex = Math.max(0, firstIndex);
        var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices

        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell

        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell

        if (clippedFirstIndex <= clippedLastIndex) {
          return {
            firstIndex: clippedFirstIndex,
            lastIndex: clippedLastIndex,
            isStart: firstIndex === clippedFirstIndex,
            isEnd: lastIndex === clippedLastIndex
          };
        }

        return null;
      }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.
      // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
      // If before the first offset, returns a negative number.
      // If after the last offset, returns an offset past the last cell offset.
      // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.


      DaySeriesModel.prototype.getDateDayIndex = function (date) {
        var indices = this.indices;
        var dayOffset = Math.floor(diffDays(this.dates[0], date));

        if (dayOffset < 0) {
          return indices[0] - 1;
        }

        if (dayOffset >= indices.length) {
          return indices[indices.length - 1] + 1;
        }

        return indices[dayOffset];
      };

      return DaySeriesModel;
    }();

    var DayTableModel = function () {
      function DayTableModel(daySeries, breakOnWeeks) {
        var dates = daySeries.dates;
        var daysPerRow;
        var firstDay;
        var rowCnt;

        if (breakOnWeeks) {
          // count columns until the day-of-week repeats
          firstDay = dates[0].getUTCDay();

          for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
            if (dates[daysPerRow].getUTCDay() === firstDay) {
              break;
            }
          }

          rowCnt = Math.ceil(dates.length / daysPerRow);
        } else {
          rowCnt = 1;
          daysPerRow = dates.length;
        }

        this.rowCnt = rowCnt;
        this.colCnt = daysPerRow;
        this.daySeries = daySeries;
        this.cells = this.buildCells();
        this.headerDates = this.buildHeaderDates();
      }

      DayTableModel.prototype.buildCells = function () {
        var rows = [];

        for (var row = 0; row < this.rowCnt; row += 1) {
          var cells = [];

          for (var col = 0; col < this.colCnt; col += 1) {
            cells.push(this.buildCell(row, col));
          }

          rows.push(cells);
        }

        return rows;
      };

      DayTableModel.prototype.buildCell = function (row, col) {
        var date = this.daySeries.dates[row * this.colCnt + col];
        return {
          key: date.toISOString(),
          date: date
        };
      };

      DayTableModel.prototype.buildHeaderDates = function () {
        var dates = [];

        for (var col = 0; col < this.colCnt; col += 1) {
          dates.push(this.cells[0][col].date);
        }

        return dates;
      };

      DayTableModel.prototype.sliceRange = function (range) {
        var colCnt = this.colCnt;
        var seriesSeg = this.daySeries.sliceRange(range);
        var segs = [];

        if (seriesSeg) {
          var firstIndex = seriesSeg.firstIndex,
              lastIndex = seriesSeg.lastIndex;
          var index = firstIndex;

          while (index <= lastIndex) {
            var row = Math.floor(index / colCnt);
            var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
            segs.push({
              row: row,
              firstCol: index % colCnt,
              lastCol: (nextIndex - 1) % colCnt,
              isStart: seriesSeg.isStart && index === firstIndex,
              isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
            });
            index = nextIndex;
          }
        }

        return segs;
      };

      return DayTableModel;
    }();

    var Slicer = function () {
      function Slicer() {
        this.sliceBusinessHours = memoize(this._sliceBusinessHours);
        this.sliceDateSelection = memoize(this._sliceDateSpan);
        this.sliceEventStore = memoize(this._sliceEventStore);
        this.sliceEventDrag = memoize(this._sliceInteraction);
        this.sliceEventResize = memoize(this._sliceInteraction);
        this.forceDayIfListItem = false; // hack
      }

      Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {
        var extraArgs = [];

        for (var _i = 4; _i < arguments.length; _i++) {
          extraArgs[_i - 4] = arguments[_i];
        }

        var eventUiBases = props.eventUiBases;
        var eventSegs = this.sliceEventStore.apply(this, __spreadArray([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));
        return {
          dateSelectionSegs: this.sliceDateSelection.apply(this, __spreadArray([props.dateSelection, eventUiBases, context], extraArgs)),
          businessHourSegs: this.sliceBusinessHours.apply(this, __spreadArray([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),
          fgEventSegs: eventSegs.fg,
          bgEventSegs: eventSegs.bg,
          eventDrag: this.sliceEventDrag.apply(this, __spreadArray([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),
          eventResize: this.sliceEventResize.apply(this, __spreadArray([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),
          eventSelection: props.eventSelection
        }; // TODO: give interactionSegs?
      };

      Slicer.prototype.sliceNowDate = function ( // does not memoize
      date, context) {
        var extraArgs = [];

        for (var _i = 2; _i < arguments.length; _i++) {
          extraArgs[_i - 2] = arguments[_i];
        }

        return this._sliceDateSpan.apply(this, __spreadArray([{
          range: {
            start: date,
            end: addMs(date, 1)
          },
          allDay: false
        }, {}, context], extraArgs));
      };

      Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {
        var extraArgs = [];

        for (var _i = 4; _i < arguments.length; _i++) {
          extraArgs[_i - 4] = arguments[_i];
        }

        if (!businessHours) {
          return [];
        }

        return this._sliceEventStore.apply(this, __spreadArray([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;
      };

      Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {
        var extraArgs = [];

        for (var _i = 4; _i < arguments.length; _i++) {
          extraArgs[_i - 4] = arguments[_i];
        }

        if (eventStore) {
          var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
          return {
            bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
            fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
          };
        }

        return {
          bg: [],
          fg: []
        };
      };

      Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {
        var extraArgs = [];

        for (var _i = 4; _i < arguments.length; _i++) {
          extraArgs[_i - 4] = arguments[_i];
        }

        if (!interaction) {
          return null;
        }

        var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
        return {
          segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
          affectedInstances: interaction.affectedEvents.instances,
          isEvent: interaction.isEvent
        };
      };

      Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {
        var extraArgs = [];

        for (var _i = 3; _i < arguments.length; _i++) {
          extraArgs[_i - 3] = arguments[_i];
        }

        if (!dateSpan) {
          return [];
        }

        var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
        var segs = this.sliceRange.apply(this, __spreadArray([dateSpan.range], extraArgs));

        for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {
          var seg = segs_1[_a];
          seg.eventRange = eventRange;
        }

        return segs;
      };
      /*
      "complete" seg means it has component and eventRange
      */


      Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {
        var segs = [];

        for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
          var eventRange = eventRanges_1[_i];
          segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));
        }

        return segs;
      };
      /*
      "complete" seg means it has component and eventRange
      */


      Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {
        var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day

        if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {
          dateRange = {
            start: dateRange.start,
            end: addDays(dateRange.start, 1)
          };
        }

        var segs = this.sliceRange.apply(this, __spreadArray([dateRange], extraArgs));

        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
          var seg = segs_2[_i];
          seg.eventRange = eventRange;
          seg.isStart = eventRange.isStart && seg.isStart;
          seg.isEnd = eventRange.isEnd && seg.isEnd;
        }

        return segs;
      };

      return Slicer;
    }();
    /*
    for incorporating slotMinTime/slotMaxTime if appropriate
    TODO: should be part of DateProfile!
    TimelineDateProfile already does this btw
    */


    function computeActiveRange(dateProfile, isComponentAllDay) {
      var range = dateProfile.activeRange;

      if (isComponentAllDay) {
        return range;
      }

      return {
        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day

      };
    } // high-level segmenting-aware tester functions

    var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;

    var Scroller = function (_super) {
      __extends(Scroller, _super);

      function Scroller() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.handleEl = function (el) {
          _this.el = el;
          setRef(_this.props.elRef, el);
        };

        return _this;
      }

      Scroller.prototype.render = function () {
        var props = this.props;
        var liquid = props.liquid,
            liquidIsAbsolute = props.liquidIsAbsolute;
        var isAbsolute = liquid && liquidIsAbsolute;
        var className = ['fc-scroller'];

        if (liquid) {
          if (liquidIsAbsolute) {
            className.push('fc-scroller-liquid-absolute');
          } else {
            className.push('fc-scroller-liquid');
          }
        }

        return createElement("div", {
          ref: this.handleEl,
          className: className.join(' '),
          style: {
            overflowX: props.overflowX,
            overflowY: props.overflowY,
            left: isAbsolute && -(props.overcomeLeft || 0) || '',
            right: isAbsolute && -(props.overcomeRight || 0) || '',
            bottom: isAbsolute && -(props.overcomeBottom || 0) || '',
            marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',
            marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',
            marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',
            maxHeight: props.maxHeight || ''
          }
        }, props.children);
      };

      Scroller.prototype.needsXScrolling = function () {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
          return false;
        } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.
        // much more reliable to see if children are taller than the scroller, even tho doesn't account for
        // inner-child margins and absolute positioning


        var el = this.el;
        var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
        var children = el.children;

        for (var i = 0; i < children.length; i += 1) {
          var childEl = children[i];

          if (childEl.getBoundingClientRect().width > realClientWidth) {
            return true;
          }
        }

        return false;
      };

      Scroller.prototype.needsYScrolling = function () {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
          return false;
        } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.
        // much more reliable to see if children are taller than the scroller, even tho doesn't account for
        // inner-child margins and absolute positioning


        var el = this.el;
        var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
        var children = el.children;

        for (var i = 0; i < children.length; i += 1) {
          var childEl = children[i];

          if (childEl.getBoundingClientRect().height > realClientHeight) {
            return true;
          }
        }

        return false;
      };

      Scroller.prototype.getXScrollbarWidth = function () {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
          return 0;
        }

        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?
      };

      Scroller.prototype.getYScrollbarWidth = function () {
        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
          return 0;
        }

        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?
      };

      return Scroller;
    }(BaseComponent);
    /*
    TODO: somehow infer OtherArgs from masterCallback?
    TODO: infer RefType from masterCallback if provided
    */


    var RefMap = function () {
      function RefMap(masterCallback) {
        var _this = this;

        this.masterCallback = masterCallback;
        this.currentMap = {};
        this.depths = {};
        this.callbackMap = {};

        this.handleValue = function (val, key) {
          var _a = _this,
              depths = _a.depths,
              currentMap = _a.currentMap;
          var removed = false;
          var added = false;

          if (val !== null) {
            // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore
            removed = key in currentMap;
            currentMap[key] = val;
            depths[key] = (depths[key] || 0) + 1;
            added = true;
          } else {
            depths[key] -= 1;

            if (!depths[key]) {
              delete currentMap[key];
              delete _this.callbackMap[key];
              removed = true;
            }
          }

          if (_this.masterCallback) {
            if (removed) {
              _this.masterCallback(null, String(key));
            }

            if (added) {
              _this.masterCallback(val, String(key));
            }
          }
        };
      }

      RefMap.prototype.createRef = function (key) {
        var _this = this;

        var refCallback = this.callbackMap[key];

        if (!refCallback) {
          refCallback = this.callbackMap[key] = function (val) {
            _this.handleValue(val, String(key));
          };
        }

        return refCallback;
      }; // TODO: check callers that don't care about order. should use getAll instead
      // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
      // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"


      RefMap.prototype.collect = function (startIndex, endIndex, step) {
        return collectFromHash(this.currentMap, startIndex, endIndex, step);
      };

      RefMap.prototype.getAll = function () {
        return hashValuesToArray(this.currentMap);
      };

      return RefMap;
    }();

    function computeShrinkWidth(chunkEls) {
      var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');
      var largestWidth = 0;

      for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {
        var shrinkCell = shrinkCells_1[_i];
        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
      }

      return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits
    }

    function getSectionHasLiquidHeight(props, sectionConfig) {
      return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)
    }

    function getAllowYScrolling(props, sectionConfig) {
      return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
      getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars
    } // TODO: ONLY use `arg`. force out internal function to use same API


    function renderChunkContent(sectionConfig, chunkConfig, arg) {
      var expandRows = arg.expandRows;
      var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : createElement('table', {
        className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),
        style: {
          minWidth: arg.tableMinWidth,
          width: arg.clientWidth,
          height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height

        }
      }, arg.tableColGroupNode, createElement('tbody', {}, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
      return content;
    }

    function isColPropsEqual(cols0, cols1) {
      return isArraysEqual(cols0, cols1, isPropsEqual);
    }

    function renderMicroColGroup(cols, shrinkWidth) {
      var colNodes = [];
      /*
      for ColProps with spans, it would have been great to make a single <col span="">
      HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.
      SOLUTION: making individual <col> elements makes Chrome behave.
      */

      for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
        var colProps = cols_1[_i];
        var span = colProps.span || 1;

        for (var i = 0; i < span; i += 1) {
          colNodes.push(createElement("col", {
            style: {
              width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',
              minWidth: colProps.minWidth || ''
            }
          }));
        }
      }

      return createElement.apply(void 0, __spreadArray(['colgroup', {}], colNodes));
    }

    function sanitizeShrinkWidth(shrinkWidth) {
      /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth
      4 accounts for 2 2-pixel borders. TODO: better solution? */
      return shrinkWidth == null ? 4 : shrinkWidth;
    }

    function hasShrinkWidth(cols) {
      for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {
        var col = cols_2[_i];

        if (col.width === 'shrink') {
          return true;
        }
      }

      return false;
    }

    function getScrollGridClassNames(liquid, context) {
      var classNames = ['fc-scrollgrid', context.theme.getClass('table')];

      if (liquid) {
        classNames.push('fc-scrollgrid-liquid');
      }

      return classNames;
    }

    function getSectionClassNames(sectionConfig, wholeTableVGrow) {
      var classNames = ['fc-scrollgrid-section', "fc-scrollgrid-section-" + sectionConfig.type, sectionConfig.className // used?
      ];

      if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
        classNames.push('fc-scrollgrid-section-liquid');
      }

      if (sectionConfig.isSticky) {
        classNames.push('fc-scrollgrid-section-sticky');
      }

      return classNames;
    }

    function renderScrollShim(arg) {
      return createElement("div", {
        className: "fc-scrollgrid-sticky-shim",
        style: {
          width: arg.clientWidth,
          minWidth: arg.tableMinWidth
        }
      });
    }

    function getStickyHeaderDates(options) {
      var stickyHeaderDates = options.stickyHeaderDates;

      if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {
        stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';
      }

      return stickyHeaderDates;
    }

    function getStickyFooterScrollbar(options) {
      var stickyFooterScrollbar = options.stickyFooterScrollbar;

      if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {
        stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';
      }

      return stickyFooterScrollbar;
    }

    var SimpleScrollGrid = function (_super) {
      __extends(SimpleScrollGrid, _super);

      function SimpleScrollGrid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.processCols = memoize(function (a) {
          return a;
        }, isColPropsEqual); // so we get same `cols` props every time
        // yucky to memoize VNodes, but much more efficient for consumers

        _this.renderMicroColGroup = memoize(renderMicroColGroup);
        _this.scrollerRefs = new RefMap();
        _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));
        _this.state = {
          shrinkWidth: null,
          forceYScrollbars: false,
          scrollerClientWidths: {},
          scrollerClientHeights: {}
        }; // TODO: can do a really simple print-view. dont need to join rows

        _this.handleSizing = function () {
          _this.setState(__assign({
            shrinkWidth: _this.computeShrinkWidth()
          }, _this.computeScrollerDims()));
        };

        return _this;
      }

      SimpleScrollGrid.prototype.render = function () {
        var _a = this,
            props = _a.props,
            state = _a.state,
            context = _a.context;

        var sectionConfigs = props.sections || [];
        var cols = this.processCols(props.cols);
        var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
        var classNames = getScrollGridClassNames(props.liquid, context);

        if (props.collapsibleWidth) {
          classNames.push('fc-scrollgrid-collapsible');
        } // TODO: make DRY


        var configCnt = sectionConfigs.length;
        var configI = 0;
        var currentConfig;
        var headSectionNodes = [];
        var bodySectionNodes = [];
        var footSectionNodes = [];

        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {
          headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode));
          configI += 1;
        }

        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {
          bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode));
          configI += 1;
        }

        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {
          footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode));
          configI += 1;
        } // firefox bug: when setting height on table and there is a thead or tfoot,
        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)
        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.
        // if so, use a simpler dom structure, jam everything into a lone tbody.


        var isBuggy = !getCanVGrowWithinCell();
        return createElement('table', {
          className: classNames.join(' '),
          style: {
            height: props.height
          }
        }, Boolean(!isBuggy && headSectionNodes.length) && createElement.apply(void 0, __spreadArray(['thead', {}], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && createElement.apply(void 0, __spreadArray(['tbody', {}], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && createElement.apply(void 0, __spreadArray(['tfoot', {}], footSectionNodes)), isBuggy && createElement.apply(void 0, __spreadArray(__spreadArray(__spreadArray(['tbody', {}], headSectionNodes), bodySectionNodes), footSectionNodes)));
      };

      SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode) {
        if ('outerContent' in sectionConfig) {
          return createElement(Fragment, {
            key: sectionConfig.key
          }, sectionConfig.outerContent);
        }

        return createElement("tr", {
          key: sectionConfig.key,
          className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')
        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk));
      };

      SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig) {
        if ('outerContent' in chunkConfig) {
          return chunkConfig.outerContent;
        }

        var props = this.props;
        var _a = this.state,
            forceYScrollbars = _a.forceYScrollbars,
            scrollerClientWidths = _a.scrollerClientWidths,
            scrollerClientHeights = _a.scrollerClientHeights;
        var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?

        var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?
        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars

        var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';
        var sectionKey = sectionConfig.key;
        var content = renderChunkContent(sectionConfig, chunkConfig, {
          tableColGroupNode: microColGroupNode,
          tableMinWidth: '',
          clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,
          clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,
          expandRows: sectionConfig.expandRows,
          syncRowHeights: false,
          rowSyncHeights: [],
          reportRowHeightChange: function () {}
        });
        return createElement("td", {
          ref: chunkConfig.elRef
        }, createElement("div", {
          className: "fc-scroller-harness" + (isLiquid ? ' fc-scroller-harness-liquid' : '')
        }, createElement(Scroller, {
          ref: this.scrollerRefs.createRef(sectionKey),
          elRef: this.scrollerElRefs.createRef(sectionKey),
          overflowY: overflowY,
          overflowX: !props.liquid ? 'visible' : 'hidden'
          /* natural height? */
          ,
          maxHeight: sectionConfig.maxHeight,
          liquid: isLiquid,
          liquidIsAbsolute // because its within a harness
          : true
        }, content)));
      };

      SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {
        var section = getSectionByKey(this.props.sections, key);

        if (section) {
          setRef(section.chunk.scrollerElRef, scrollerEl);
        }
      };

      SimpleScrollGrid.prototype.componentDidMount = function () {
        this.handleSizing();
        this.context.addResizeHandler(this.handleSizing);
      };

      SimpleScrollGrid.prototype.componentDidUpdate = function () {
        // TODO: need better solution when state contains non-sizing things
        this.handleSizing();
      };

      SimpleScrollGrid.prototype.componentWillUnmount = function () {
        this.context.removeResizeHandler(this.handleSizing);
      };

      SimpleScrollGrid.prototype.computeShrinkWidth = function () {
        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
      };

      SimpleScrollGrid.prototype.computeScrollerDims = function () {
        var scrollbarWidth = getScrollbarWidths();

        var _a = this,
            scrollerRefs = _a.scrollerRefs,
            scrollerElRefs = _a.scrollerElRefs;

        var forceYScrollbars = false;
        var scrollerClientWidths = {};
        var scrollerClientHeights = {};

        for (var sectionKey in scrollerRefs.currentMap) {
          var scroller = scrollerRefs.currentMap[sectionKey];

          if (scroller && scroller.needsYScrolling()) {
            forceYScrollbars = true;
            break;
          }
        }

        for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {
          var section = _b[_i];
          var sectionKey = section.key;
          var scrollerEl = scrollerElRefs.currentMap[sectionKey];

          if (scrollerEl) {
            var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders

            scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future
            : 0));
            scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
          }
        }

        return {
          forceYScrollbars: forceYScrollbars,
          scrollerClientWidths: scrollerClientWidths,
          scrollerClientHeights: scrollerClientHeights
        };
      };

      return SimpleScrollGrid;
    }(BaseComponent);

    SimpleScrollGrid.addStateEquality({
      scrollerClientWidths: isPropsEqual,
      scrollerClientHeights: isPropsEqual
    });

    function getSectionByKey(sections, key) {
      for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {
        var section = sections_1[_i];

        if (section.key === key) {
          return section;
        }
      }

      return null;
    }

    var EventRoot = function (_super) {
      __extends(EventRoot, _super);

      function EventRoot() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.elRef = createRef();
        return _this;
      }

      EventRoot.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var options = context.options;
        var seg = props.seg;
        var eventRange = seg.eventRange;
        var ui = eventRange.ui;
        var hookProps = {
          event: new EventApi(context, eventRange.def, eventRange.instance),
          view: context.viewApi,
          timeText: props.timeText,
          textColor: ui.textColor,
          backgroundColor: ui.backgroundColor,
          borderColor: ui.borderColor,
          isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
          isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
          isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
          isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
          isStart: Boolean(seg.isStart),
          isEnd: Boolean(seg.isEnd),
          isPast: Boolean(props.isPast),
          isFuture: Boolean(props.isFuture),
          isToday: Boolean(props.isToday),
          isSelected: Boolean(props.isSelected),
          isDragging: Boolean(props.isDragging),
          isResizing: Boolean(props.isResizing)
        };
        var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);
        return createElement(RenderHook, {
          hookProps: hookProps,
          classNames: options.eventClassNames,
          content: options.eventContent,
          defaultContent: props.defaultContent,
          didMount: options.eventDidMount,
          willUnmount: options.eventWillUnmount,
          elRef: this.elRef
        }, function (rootElRef, customClassNames, innerElRef, innerContent) {
          return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);
        });
      };

      EventRoot.prototype.componentDidMount = function () {
        setElSeg(this.elRef.current, this.props.seg);
      };
      /*
      need to re-assign seg to the element if seg changes, even if the element is the same
      */


      EventRoot.prototype.componentDidUpdate = function (prevProps) {
        var seg = this.props.seg;

        if (seg !== prevProps.seg) {
          setElSeg(this.elRef.current, seg);
        }
      };

      return EventRoot;
    }(BaseComponent); // should not be a purecomponent


    var StandardEvent = function (_super) {
      __extends(StandardEvent, _super);

      function StandardEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      StandardEvent.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var seg = props.seg;
        var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;
        var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
        return createElement(EventRoot, {
          seg: seg,
          timeText: timeText,
          disableDragging: props.disableDragging,
          disableResizing: props.disableResizing,
          defaultContent: props.defaultContent || renderInnerContent$1,
          isDragging: props.isDragging,
          isResizing: props.isResizing,
          isDateSelecting: props.isDateSelecting,
          isSelected: props.isSelected,
          isPast: props.isPast,
          isFuture: props.isFuture,
          isToday: props.isToday
        }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {
          return createElement("a", __assign({
            className: props.extraClassNames.concat(classNames).join(' '),
            style: {
              borderColor: hookProps.borderColor,
              backgroundColor: hookProps.backgroundColor
            },
            ref: rootElRef
          }, getSegAnchorAttrs$1(seg)), createElement("div", {
            className: "fc-event-main",
            ref: innerElRef,
            style: {
              color: hookProps.textColor
            }
          }, innerContent), hookProps.isStartResizable && createElement("div", {
            className: "fc-event-resizer fc-event-resizer-start"
          }), hookProps.isEndResizable && createElement("div", {
            className: "fc-event-resizer fc-event-resizer-end"
          }));
        });
      };

      return StandardEvent;
    }(BaseComponent);

    function renderInnerContent$1(innerProps) {
      return createElement("div", {
        className: "fc-event-main-frame"
      }, innerProps.timeText && createElement("div", {
        className: "fc-event-time"
      }, innerProps.timeText), createElement("div", {
        className: "fc-event-title-container"
      }, createElement("div", {
        className: "fc-event-title fc-sticky"
      }, innerProps.event.title || createElement(Fragment, null, "\u00A0"))));
    }

    function getSegAnchorAttrs$1(seg) {
      var url = seg.eventRange.def.url;
      return url ? {
        href: url
      } : {};
    }

    var DAY_NUM_FORMAT = createFormatter({
      day: 'numeric'
    });

    var DayCellContent = function (_super) {
      __extends(DayCellContent, _super);

      function DayCellContent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      DayCellContent.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var options = context.options;
        var hookProps = refineDayCellHookProps({
          date: props.date,
          dateProfile: props.dateProfile,
          todayRange: props.todayRange,
          showDayNumber: props.showDayNumber,
          extraProps: props.extraHookProps,
          viewApi: context.viewApi,
          dateEnv: context.dateEnv
        });
        return createElement(ContentHook, {
          hookProps: hookProps,
          content: options.dayCellContent,
          defaultContent: props.defaultContent
        }, props.children);
      };

      return DayCellContent;
    }(BaseComponent);

    function refineDayCellHookProps(raw) {
      var date = raw.date,
          dateEnv = raw.dateEnv;
      var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);
      return __assign(__assign(__assign({
        date: dateEnv.toDate(date),
        view: raw.viewApi
      }, dayMeta), {
        dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''
      }), raw.extraProps);
    }

    var DayCellRoot = function (_super) {
      __extends(DayCellRoot, _super);

      function DayCellRoot() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);
        _this.normalizeClassNames = buildClassNameNormalizer();
        return _this;
      }

      DayCellRoot.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var options = context.options;
        var hookProps = this.refineHookProps({
          date: props.date,
          dateProfile: props.dateProfile,
          todayRange: props.todayRange,
          showDayNumber: props.showDayNumber,
          extraProps: props.extraHookProps,
          viewApi: context.viewApi,
          dateEnv: context.dateEnv
        });
        var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled
        : this.normalizeClassNames(options.dayCellClassNames, hookProps));
        var dataAttrs = hookProps.isDisabled ? {} : {
          'data-date': formatDayString(props.date)
        };
        return createElement(MountHook, {
          hookProps: hookProps,
          didMount: options.dayCellDidMount,
          willUnmount: options.dayCellWillUnmount,
          elRef: props.elRef
        }, function (rootElRef) {
          return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);
        });
      };

      return DayCellRoot;
    }(BaseComponent);

    function renderFill(fillType) {
      return createElement("div", {
        className: "fc-" + fillType
      });
    }

    var BgEvent = function (props) {
      return createElement(EventRoot, {
        defaultContent: renderInnerContent$2,
        seg: props.seg
        /* uselesss i think */
        ,
        timeText: "",
        disableDragging: true,
        disableResizing: true,
        isDragging: false,
        isResizing: false,
        isDateSelecting: false,
        isSelected: false,
        isPast: props.isPast,
        isFuture: props.isFuture,
        isToday: props.isToday
      }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {
        return createElement("div", {
          ref: rootElRef,
          className: ['fc-bg-event'].concat(classNames).join(' '),
          style: {
            backgroundColor: hookProps.backgroundColor
          }
        }, innerContent);
      });
    };

    function renderInnerContent$2(props) {
      var title = props.event.title;
      return title && createElement("div", {
        className: "fc-event-title"
      }, props.event.title);
    }

    var WeekNumberRoot = function (props) {
      return createElement(ViewContextType.Consumer, null, function (context) {
        var dateEnv = context.dateEnv,
            options = context.options;
        var date = props.date;
        var format = options.weekNumberFormat || props.defaultFormat;
        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?

        var text = dateEnv.format(date, format);
        var hookProps = {
          num: num,
          text: text,
          date: date
        };
        return createElement(RenderHook, {
          hookProps: hookProps,
          classNames: options.weekNumberClassNames,
          content: options.weekNumberContent,
          defaultContent: renderInner,
          didMount: options.weekNumberDidMount,
          willUnmount: options.weekNumberWillUnmount
        }, props.children);
      });
    };

    function renderInner(innerProps) {
      return innerProps.text;
    }

    var PADDING_FROM_VIEWPORT = 10;

    var Popover = function (_super) {
      __extends(Popover, _super);

      function Popover() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.handleRootEl = function (el) {
          _this.rootEl = el;

          if (_this.props.elRef) {
            setRef(_this.props.elRef, el);
          }
        }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature


        _this.handleDocumentMousedown = function (ev) {
          // only hide the popover if the click happened outside the popover
          var target = getEventTargetViaRoot(ev);

          if (!_this.rootEl.contains(target)) {
            _this.handleCloseClick();
          }
        };

        _this.handleCloseClick = function () {
          var onClose = _this.props.onClose;

          if (onClose) {
            onClose();
          }
        };

        return _this;
      }

      Popover.prototype.render = function () {
        var theme = this.context.theme;
        var props = this.props;
        var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);
        return createPortal(createElement("div", __assign({
          className: classNames.join(' ')
        }, props.extraAttrs, {
          ref: this.handleRootEl
        }), createElement("div", {
          className: 'fc-popover-header ' + theme.getClass('popoverHeader')
        }, createElement("span", {
          className: "fc-popover-title"
        }, props.title), createElement("span", {
          className: 'fc-popover-close ' + theme.getIconClass('close'),
          onClick: this.handleCloseClick
        })), createElement("div", {
          className: 'fc-popover-body ' + theme.getClass('popoverContent')
        }, props.children)), props.parentEl);
      };

      Popover.prototype.componentDidMount = function () {
        document.addEventListener('mousedown', this.handleDocumentMousedown);
        this.updateSize();
      };

      Popover.prototype.componentWillUnmount = function () {
        document.removeEventListener('mousedown', this.handleDocumentMousedown);
      };

      Popover.prototype.updateSize = function () {
        var isRtl = this.context.isRtl;
        var _a = this.props,
            alignmentEl = _a.alignmentEl,
            alignGridTop = _a.alignGridTop;
        var rootEl = this.rootEl;
        var alignmentRect = computeClippedClientRect(alignmentEl);

        if (alignmentRect) {
          var popoverDims = rootEl.getBoundingClientRect(); // position relative to viewport

          var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;
          var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left; // constrain

          popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
          popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
          popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
          var origin_1 = rootEl.offsetParent.getBoundingClientRect();
          applyStyle(rootEl, {
            top: popoverTop - origin_1.top,
            left: popoverLeft - origin_1.left
          });
        }
      };

      return Popover;
    }(BaseComponent);

    var MorePopover = function (_super) {
      __extends(MorePopover, _super);

      function MorePopover() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.handleRootEl = function (rootEl) {
          _this.rootEl = rootEl;

          if (rootEl) {
            _this.context.registerInteractiveComponent(_this, {
              el: rootEl,
              useEventCenter: false
            });
          } else {
            _this.context.unregisterInteractiveComponent(_this);
          }
        };

        return _this;
      }

      MorePopover.prototype.render = function () {
        var _a = this.context,
            options = _a.options,
            dateEnv = _a.dateEnv;
        var props = this.props;
        var startDate = props.startDate,
            todayRange = props.todayRange,
            dateProfile = props.dateProfile;
        var title = dateEnv.format(startDate, options.dayPopoverFormat);
        return createElement(DayCellRoot, {
          date: startDate,
          dateProfile: dateProfile,
          todayRange: todayRange,
          elRef: this.handleRootEl
        }, function (rootElRef, dayClassNames, dataAttrs) {
          return createElement(Popover, {
            elRef: rootElRef,
            title: title,
            extraClassNames: ['fc-more-popover'].concat(dayClassNames),
            extraAttrs: dataAttrs
            /* TODO: make these time-based when not whole-day? */
            ,
            parentEl: props.parentEl,
            alignmentEl: props.alignmentEl,
            alignGridTop: props.alignGridTop,
            onClose: props.onClose
          }, createElement(DayCellContent, {
            date: startDate,
            dateProfile: dateProfile,
            todayRange: todayRange
          }, function (innerElRef, innerContent) {
            return innerContent && createElement("div", {
              className: "fc-more-popover-misc",
              ref: innerElRef
            }, innerContent);
          }), props.children);
        });
      };

      MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
        var _a = this,
            rootEl = _a.rootEl,
            props = _a.props;

        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
          return {
            dateProfile: props.dateProfile,
            dateSpan: __assign({
              allDay: true,
              range: {
                start: props.startDate,
                end: props.endDate
              }
            }, props.extraDateSpan),
            dayEl: rootEl,
            rect: {
              left: 0,
              top: 0,
              right: elWidth,
              bottom: elHeight
            },
            layer: 1 // important when comparing with hits from other components

          };
        }

        return null;
      };

      return MorePopover;
    }(DateComponent);

    var MoreLinkRoot = function (_super) {
      __extends(MoreLinkRoot, _super);

      function MoreLinkRoot() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.linkElRef = createRef();
        _this.state = {
          isPopoverOpen: false
        };

        _this.handleClick = function (ev) {
          var _a = _this,
              props = _a.props,
              context = _a.context;
          var moreLinkClick = context.options.moreLinkClick;
          var date = computeRange(props).start;

          function buildPublicSeg(seg) {
            var _a = seg.eventRange,
                def = _a.def,
                instance = _a.instance,
                range = _a.range;
            return {
              event: new EventApi(context, def, instance),
              start: context.dateEnv.toDate(range.start),
              end: context.dateEnv.toDate(range.end),
              isStart: seg.isStart,
              isEnd: seg.isEnd
            };
          }

          if (typeof moreLinkClick === 'function') {
            moreLinkClick = moreLinkClick({
              date: date,
              allDay: Boolean(props.allDayDate),
              allSegs: props.allSegs.map(buildPublicSeg),
              hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
              jsEvent: ev,
              view: context.viewApi
            });
          }

          if (!moreLinkClick || moreLinkClick === 'popover') {
            _this.setState({
              isPopoverOpen: true
            });
          } else if (typeof moreLinkClick === 'string') {
            // a view name
            context.calendarApi.zoomTo(date, moreLinkClick);
          }
        };

        _this.handlePopoverClose = function () {
          _this.setState({
            isPopoverOpen: false
          });
        };

        return _this;
      }

      MoreLinkRoot.prototype.render = function () {
        var _this = this;

        var props = this.props;
        return createElement(ViewContextType.Consumer, null, function (context) {
          var viewApi = context.viewApi,
              options = context.options,
              calendarApi = context.calendarApi;
          var moreLinkText = options.moreLinkText;
          var moreCnt = props.moreCnt;
          var range = computeRange(props);
          var hookProps = {
            num: moreCnt,
            shortText: "+" + moreCnt,
            text: typeof moreLinkText === 'function' ? moreLinkText.call(calendarApi, moreCnt) : "+" + moreCnt + " " + moreLinkText,
            view: viewApi
          };
          return createElement(Fragment, null, Boolean(props.moreCnt) && createElement(RenderHook, {
            elRef: _this.linkElRef,
            hookProps: hookProps,
            classNames: options.moreLinkClassNames,
            content: options.moreLinkContent,
            defaultContent: props.defaultContent || renderMoreLinkInner,
            didMount: options.moreLinkDidMount,
            willUnmount: options.moreLinkWillUnmount
          }, function (rootElRef, customClassNames, innerElRef, innerContent) {
            return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick);
          }), _this.state.isPopoverOpen && createElement(MorePopover, {
            startDate: range.start,
            endDate: range.end,
            dateProfile: props.dateProfile,
            todayRange: props.todayRange,
            extraDateSpan: props.extraDateSpan,
            parentEl: _this.parentEl,
            alignmentEl: props.alignmentElRef.current,
            alignGridTop: props.alignGridTop,
            onClose: _this.handlePopoverClose
          }, props.popoverContent()));
        });
      };

      MoreLinkRoot.prototype.componentDidMount = function () {
        this.updateParentEl();
      };

      MoreLinkRoot.prototype.componentDidUpdate = function () {
        this.updateParentEl();
      };

      MoreLinkRoot.prototype.updateParentEl = function () {
        if (this.linkElRef.current) {
          this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');
        }
      };

      return MoreLinkRoot;
    }(BaseComponent);

    function renderMoreLinkInner(props) {
      return props.text;
    }

    function computeRange(props) {
      if (props.allDayDate) {
        return {
          start: props.allDayDate,
          end: addDays(props.allDayDate, 1)
        };
      }

      var hiddenSegs = props.hiddenSegs;
      return {
        start: computeEarliestSegStart(hiddenSegs),
        end: computeLatestSegEnd(hiddenSegs)
      };
    }

    function computeEarliestSegStart(segs) {
      return segs.reduce(pickEarliestStart).eventRange.range.start;
    }

    function pickEarliestStart(seg0, seg1) {
      return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
    }

    function computeLatestSegEnd(segs) {
      return segs.reduce(pickLatestEnd).eventRange.range.end;
    }

    function pickLatestEnd(seg0, seg1) {
      return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
    } // exports

    /*!
    FullCalendar v5.9.0
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */

    var Calendar$1 = function (_super) {
      __extends(Calendar, _super);

      function Calendar(el, optionOverrides) {
        if (optionOverrides === void 0) {
          optionOverrides = {};
        }

        var _this = _super.call(this) || this;

        _this.isRendering = false;
        _this.isRendered = false;
        _this.currentClassNames = [];
        _this.customContentRenderId = 0; // will affect custom generated classNames?

        _this.handleAction = function (action) {
          // actions we know we want to render immediately
          switch (action.type) {
            case 'SET_EVENT_DRAG':
            case 'SET_EVENT_RESIZE':
              _this.renderRunner.tryDrain();

          }
        };

        _this.handleData = function (data) {
          _this.currentData = data;

          _this.renderRunner.request(data.calendarOptions.rerenderDelay);
        };

        _this.handleRenderRequest = function () {
          if (_this.isRendering) {
            _this.isRendered = true;
            var currentData_1 = _this.currentData;
            render(createElement(CalendarRoot, {
              options: currentData_1.calendarOptions,
              theme: currentData_1.theme,
              emitter: currentData_1.emitter
            }, function (classNames, height, isHeightAuto, forPrint) {
              _this.setClassNames(classNames);

              _this.setHeight(height);

              return createElement(CustomContentRenderContext.Provider, {
                value: _this.customContentRenderId
              }, createElement(CalendarContent, __assign({
                isHeightAuto: isHeightAuto,
                forPrint: forPrint
              }, currentData_1)));
            }), _this.el);
          } else if (_this.isRendered) {
            _this.isRendered = false;
            unmountComponentAtNode(_this.el);

            _this.setClassNames([]);

            _this.setHeight('');
          }

          flushToDom();
        };

        _this.el = el;
        _this.renderRunner = new DelayedRunner(_this.handleRenderRequest);
        new CalendarDataManager({
          optionOverrides: optionOverrides,
          calendarApi: _this,
          onAction: _this.handleAction,
          onData: _this.handleData
        });
        return _this;
      }

      Object.defineProperty(Calendar.prototype, "view", {
        get: function () {
          return this.currentData.viewApi;
        } // for public API
        ,
        enumerable: false,
        configurable: true
      });

      Calendar.prototype.render = function () {
        var wasRendering = this.isRendering;

        if (!wasRendering) {
          this.isRendering = true;
        } else {
          this.customContentRenderId += 1;
        }

        this.renderRunner.request();

        if (wasRendering) {
          this.updateSize();
        }
      };

      Calendar.prototype.destroy = function () {
        if (this.isRendering) {
          this.isRendering = false;
          this.renderRunner.request();
        }
      };

      Calendar.prototype.updateSize = function () {
        _super.prototype.updateSize.call(this);

        flushToDom();
      };

      Calendar.prototype.batchRendering = function (func) {
        this.renderRunner.pause('batchRendering');
        func();
        this.renderRunner.resume('batchRendering');
      };

      Calendar.prototype.pauseRendering = function () {
        this.renderRunner.pause('pauseRendering');
      };

      Calendar.prototype.resumeRendering = function () {
        this.renderRunner.resume('pauseRendering', true);
      };

      Calendar.prototype.resetOptions = function (optionOverrides, append) {
        this.currentDataManager.resetOptions(optionOverrides, append);
      };

      Calendar.prototype.setClassNames = function (classNames) {
        if (!isArraysEqual(classNames, this.currentClassNames)) {
          var classList = this.el.classList;

          for (var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++) {
            var className = _a[_i];
            classList.remove(className);
          }

          for (var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++) {
            var className = classNames_1[_b];
            classList.add(className);
          }

          this.currentClassNames = classNames;
        }
      };

      Calendar.prototype.setHeight = function (height) {
        applyStyleProp(this.el, 'height', height);
      };

      return Calendar;
    }(CalendarApi);

    /* node_modules/svelte-fullcalendar/src/FullCalendar.svelte generated by Svelte v3.41.0 */
    const file$z = "node_modules/svelte-fullcalendar/src/FullCalendar.svelte";

    function create_fragment$F(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", /*classes*/ ctx[0]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$z, 63, 0, 1109);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[6](div);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*classes*/ 1) {
    				attr_dev(div, "class", /*classes*/ ctx[0]);
    			}

    			if (dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FullCalendar', slots, []);
    	let { class: classes = null } = $$props;
    	let { style = null } = $$props;
    	let { options } = $$props;

    	function getAPI() {
    		return calendar;
    	}

    	let calendarEl;
    	let calendar;

    	onMount(async () => {
    		if (!options || !options.plugins || !options.plugins.length || !calendarEl) return;
    		initCalendar();
    	});

    	onDestroy(() => {
    		if (calendar) calendar.destroy();
    	});

    	function initCalendar() {
    		$$invalidate(5, calendar = new Calendar$1(calendarEl, options));
    		calendar.render();
    	}

    	function updateCalendarOptions() {
    		calendar.pauseRendering();
    		calendar.resetOptions(options);
    		calendar.resumeRendering();
    	}

    	const writable_props = ['class', 'style', 'options'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FullCalendar> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			calendarEl = $$value;
    			$$invalidate(2, calendarEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('class' in $$props) $$invalidate(0, classes = $$props.class);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('options' in $$props) $$invalidate(3, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		Calendar: Calendar$1,
    		classes,
    		style,
    		options,
    		getAPI,
    		calendarEl,
    		calendar,
    		initCalendar,
    		updateCalendarOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('options' in $$props) $$invalidate(3, options = $$props.options);
    		if ('calendarEl' in $$props) $$invalidate(2, calendarEl = $$props.calendarEl);
    		if ('calendar' in $$props) $$invalidate(5, calendar = $$props.calendar);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options, calendarEl, calendar*/ 44) {
    			{
    				if (options && options.plugins && options.plugins.length && calendarEl && !calendar) initCalendar();
    				if (options && options.plugins && options.plugins.length && calendar) updateCalendarOptions();
    			}
    		}
    	};

    	return [classes, style, calendarEl, options, getAPI, calendar, div_binding];
    }

    class FullCalendar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			class: 0,
    			style: 1,
    			options: 3,
    			getAPI: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FullCalendar",
    			options,
    			id: create_fragment$F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*options*/ ctx[3] === undefined && !('options' in props)) {
    			console.warn("<FullCalendar> was created without expected prop 'options'");
    		}
    	}

    	get class() {
    		throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getAPI() {
    		return this.$$.ctx[4];
    	}

    	set getAPI(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css_248z$1 = "";
    styleInject(css_248z$1);

    /*!
    FullCalendar v5.9.0
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */
    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
    ----------------------------------------------------------------------------------------------------------------------*/
    // It is a manager for a Table subcomponent, which does most of the heavy lifting.
    // It is responsible for managing width/height.

    var TableView = function (_super) {
      __extends(TableView, _super);

      function TableView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.headerElRef = createRef();
        return _this;
      }

      TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var sections = [];
        var stickyHeaderDates = getStickyHeaderDates(context.options);

        if (headerRowContent) {
          sections.push({
            type: 'header',
            key: 'header',
            isSticky: stickyHeaderDates,
            chunk: {
              elRef: this.headerElRef,
              tableClassName: 'fc-col-header',
              rowContent: headerRowContent
            }
          });
        }

        sections.push({
          type: 'body',
          key: 'body',
          liquid: true,
          chunk: {
            content: bodyContent
          }
        });
        return createElement(ViewRoot, {
          viewSpec: context.viewSpec
        }, function (rootElRef, classNames) {
          return createElement("div", {
            ref: rootElRef,
            className: ['fc-daygrid'].concat(classNames).join(' ')
          }, createElement(SimpleScrollGrid, {
            liquid: !props.isHeightAuto && !props.forPrint,
            collapsibleWidth: props.forPrint,
            cols: []
            /* TODO: make optional? */
            ,
            sections: sections
          }));
        });
      };

      TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {
        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;

        if (!ScrollGrid) {
          throw new Error('No ScrollGrid implementation');
        }

        var _a = this,
            props = _a.props,
            context = _a.context;

        var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
        var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
        var sections = [];

        if (headerRowContent) {
          sections.push({
            type: 'header',
            key: 'header',
            isSticky: stickyHeaderDates,
            chunks: [{
              key: 'main',
              elRef: this.headerElRef,
              tableClassName: 'fc-col-header',
              rowContent: headerRowContent
            }]
          });
        }

        sections.push({
          type: 'body',
          key: 'body',
          liquid: true,
          chunks: [{
            key: 'main',
            content: bodyContent
          }]
        });

        if (stickyFooterScrollbar) {
          sections.push({
            type: 'footer',
            key: 'footer',
            isSticky: true,
            chunks: [{
              key: 'main',
              content: renderScrollShim
            }]
          });
        }

        return createElement(ViewRoot, {
          viewSpec: context.viewSpec
        }, function (rootElRef, classNames) {
          return createElement("div", {
            ref: rootElRef,
            className: ['fc-daygrid'].concat(classNames).join(' ')
          }, createElement(ScrollGrid, {
            liquid: !props.isHeightAuto && !props.forPrint,
            collapsibleWidth: props.forPrint,
            colGroups: [{
              cols: [{
                span: colCnt,
                minWidth: dayMinWidth
              }]
            }],
            sections: sections
          }));
        });
      };

      return TableView;
    }(DateComponent);

    function splitSegsByRow(segs, rowCnt) {
      var byRow = [];

      for (var i = 0; i < rowCnt; i += 1) {
        byRow[i] = [];
      }

      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        byRow[seg.row].push(seg);
      }

      return byRow;
    }

    function splitSegsByFirstCol(segs, colCnt) {
      var byCol = [];

      for (var i = 0; i < colCnt; i += 1) {
        byCol[i] = [];
      }

      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
        var seg = segs_2[_i];
        byCol[seg.firstCol].push(seg);
      }

      return byCol;
    }

    function splitInteractionByRow(ui, rowCnt) {
      var byRow = [];

      if (!ui) {
        for (var i = 0; i < rowCnt; i += 1) {
          byRow[i] = null;
        }
      } else {
        for (var i = 0; i < rowCnt; i += 1) {
          byRow[i] = {
            affectedInstances: ui.affectedInstances,
            isEvent: ui.isEvent,
            segs: []
          };
        }

        for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {
          var seg = _a[_i];
          byRow[seg.row].segs.push(seg);
        }
      }

      return byRow;
    }

    var TableCellTop = function (_super) {
      __extends(TableCellTop, _super);

      function TableCellTop() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TableCellTop.prototype.render = function () {
        var props = this.props;
        var navLinkAttrs = this.context.options.navLinks ? {
          'data-navlink': buildNavLinkData(props.date),
          tabIndex: 0
        } : {};
        return createElement(DayCellContent, {
          date: props.date,
          dateProfile: props.dateProfile,
          todayRange: props.todayRange,
          showDayNumber: props.showDayNumber,
          extraHookProps: props.extraHookProps,
          defaultContent: renderTopInner
        }, function (innerElRef, innerContent) {
          return (innerContent || props.forceDayTop) && createElement("div", {
            className: "fc-daygrid-day-top",
            ref: innerElRef
          }, createElement("a", __assign({
            className: "fc-daygrid-day-number"
          }, navLinkAttrs), innerContent || createElement(Fragment, null, "\u00A0")));
        });
      };

      return TableCellTop;
    }(BaseComponent);

    function renderTopInner(props) {
      return props.dayNumberText;
    }

    var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
      hour: 'numeric',
      minute: '2-digit',
      omitZeroMinute: true,
      meridiem: 'narrow'
    });

    function hasListItemDisplay(seg) {
      var display = seg.eventRange.ui.display;
      return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
      seg.isStart && // "
      seg.isEnd // "
      ;
    }

    var TableBlockEvent = function (_super) {
      __extends(TableBlockEvent, _super);

      function TableBlockEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TableBlockEvent.prototype.render = function () {
        var props = this.props;
        return createElement(StandardEvent, __assign({}, props, {
          extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],
          defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,
          defaultDisplayEventEnd: props.defaultDisplayEventEnd,
          disableResizing: !props.seg.eventRange.def.allDay
        }));
      };

      return TableBlockEvent;
    }(BaseComponent);

    var TableListItemEvent = function (_super) {
      __extends(TableListItemEvent, _super);

      function TableListItemEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TableListItemEvent.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
        var timeText = buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);
        return createElement(EventRoot, {
          seg: props.seg,
          timeText: timeText,
          defaultContent: renderInnerContent,
          isDragging: props.isDragging,
          isResizing: false,
          isDateSelecting: false,
          isSelected: props.isSelected,
          isPast: props.isPast,
          isFuture: props.isFuture,
          isToday: props.isToday
        }, function (rootElRef, classNames, innerElRef, innerContent) {
          return (// we don't use styles!
            createElement("a", __assign({
              className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),
              ref: rootElRef
            }, getSegAnchorAttrs(props.seg)), innerContent)
          );
        });
      };

      return TableListItemEvent;
    }(BaseComponent);

    function renderInnerContent(innerProps) {
      return createElement(Fragment, null, createElement("div", {
        className: "fc-daygrid-event-dot",
        style: {
          borderColor: innerProps.borderColor || innerProps.backgroundColor
        }
      }), innerProps.timeText && createElement("div", {
        className: "fc-event-time"
      }, innerProps.timeText), createElement("div", {
        className: "fc-event-title"
      }, innerProps.event.title || createElement(Fragment, null, "\u00A0")));
    }

    function getSegAnchorAttrs(seg) {
      var url = seg.eventRange.def.url;
      return url ? {
        href: url
      } : {};
    }

    var TableCellMoreLink = function (_super) {
      __extends(TableCellMoreLink, _super);

      function TableCellMoreLink() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.compileSegs = memoize(compileSegs);
        return _this;
      }

      TableCellMoreLink.prototype.render = function () {
        var props = this.props;

        var _a = this.compileSegs(props.singlePlacements),
            allSegs = _a.allSegs,
            invisibleSegs = _a.invisibleSegs;

        return createElement(MoreLinkRoot, {
          dateProfile: props.dateProfile,
          todayRange: props.todayRange,
          allDayDate: props.allDayDate,
          moreCnt: props.moreCnt,
          allSegs: allSegs,
          hiddenSegs: invisibleSegs,
          alignmentElRef: props.alignmentElRef,
          alignGridTop: props.alignGridTop,
          extraDateSpan: props.extraDateSpan,
          popoverContent: function () {
            var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
            return createElement(Fragment, null, allSegs.map(function (seg) {
              var instanceId = seg.eventRange.instance.instanceId;
              return createElement("div", {
                className: "fc-daygrid-event-harness",
                key: instanceId,
                style: {
                  visibility: isForcedInvisible[instanceId] ? 'hidden' : ''
                }
              }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, __assign({
                seg: seg,
                isDragging: false,
                isSelected: instanceId === props.eventSelection,
                defaultDisplayEventEnd: false
              }, getSegMeta(seg, props.todayRange))) : createElement(TableBlockEvent, __assign({
                seg: seg,
                isDragging: false,
                isResizing: false,
                isDateSelecting: false,
                isSelected: instanceId === props.eventSelection,
                defaultDisplayEventEnd: false
              }, getSegMeta(seg, props.todayRange))));
            }));
          }
        }, function (rootElRef, classNames, innerElRef, innerContent, handleClick) {
          return createElement("a", {
            ref: rootElRef,
            className: ['fc-daygrid-more-link'].concat(classNames).join(' '),
            onClick: handleClick
          }, innerContent);
        });
      };

      return TableCellMoreLink;
    }(BaseComponent);

    function compileSegs(singlePlacements) {
      var allSegs = [];
      var invisibleSegs = [];

      for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {
        var placement = singlePlacements_1[_i];
        allSegs.push(placement.seg);

        if (!placement.isVisible) {
          invisibleSegs.push(placement.seg);
        }
      }

      return {
        allSegs: allSegs,
        invisibleSegs: invisibleSegs
      };
    }

    var DEFAULT_WEEK_NUM_FORMAT = createFormatter({
      week: 'narrow'
    });

    var TableCell = function (_super) {
      __extends(TableCell, _super);

      function TableCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.rootElRef = createRef();

        _this.handleRootEl = function (el) {
          setRef(_this.rootElRef, el);
          setRef(_this.props.elRef, el);
        };

        return _this;
      }

      TableCell.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context,
            rootElRef = _a.rootElRef;

        var options = context.options;
        var date = props.date,
            dateProfile = props.dateProfile;
        var navLinkAttrs = options.navLinks ? {
          'data-navlink': buildNavLinkData(date, 'week'),
          tabIndex: 0
        } : {};
        return createElement(DayCellRoot, {
          date: date,
          dateProfile: dateProfile,
          todayRange: props.todayRange,
          showDayNumber: props.showDayNumber,
          extraHookProps: props.extraHookProps,
          elRef: this.handleRootEl
        }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {
          return createElement("td", __assign({
            ref: dayElRef,
            className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')
          }, rootDataAttrs, props.extraDataAttrs), createElement("div", {
            className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner",
            ref: props.innerElRef
            /* different from hook system! RENAME */

          }, props.showWeekNumber && createElement(WeekNumberRoot, {
            date: date,
            defaultFormat: DEFAULT_WEEK_NUM_FORMAT
          }, function (weekElRef, weekClassNames, innerElRef, innerContent) {
            return createElement("a", __assign({
              ref: weekElRef,
              className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')
            }, navLinkAttrs), innerContent);
          }), !isDisabled && createElement(TableCellTop, {
            date: date,
            dateProfile: dateProfile,
            showDayNumber: props.showDayNumber,
            forceDayTop: props.forceDayTop,
            todayRange: props.todayRange,
            extraHookProps: props.extraHookProps
          }), createElement("div", {
            className: "fc-daygrid-day-events",
            ref: props.fgContentElRef
          }, props.fgContent, createElement("div", {
            className: "fc-daygrid-day-bottom",
            style: {
              marginTop: props.moreMarginTop
            }
          }, createElement(TableCellMoreLink, {
            allDayDate: date,
            singlePlacements: props.singlePlacements,
            moreCnt: props.moreCnt,
            alignmentElRef: rootElRef,
            alignGridTop: !props.showDayNumber,
            extraDateSpan: props.extraDateSpan,
            dateProfile: props.dateProfile,
            eventSelection: props.eventSelection,
            eventDrag: props.eventDrag,
            eventResize: props.eventResize,
            todayRange: props.todayRange
          }))), createElement("div", {
            className: "fc-daygrid-day-bg"
          }, props.bgContent)));
        });
      };

      return TableCell;
    }(DateComponent);

    function computeFgSegPlacement(segs, // assumed already sorted
    dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {
      var hierarchy = new DayGridSegHierarchy();
      hierarchy.allowReslicing = true;
      hierarchy.strictOrder = strictOrder;

      if (dayMaxEvents === true || dayMaxEventRows === true) {
        hierarchy.maxCoord = maxContentHeight;
        hierarchy.hiddenConsumes = true;
      } else if (typeof dayMaxEvents === 'number') {
        hierarchy.maxStackCnt = dayMaxEvents;
      } else if (typeof dayMaxEventRows === 'number') {
        hierarchy.maxStackCnt = dayMaxEventRows;
        hierarchy.hiddenConsumes = true;
      } // create segInputs only for segs with known heights


      var segInputs = [];
      var unknownHeightSegs = [];

      for (var i = 0; i < segs.length; i += 1) {
        var seg = segs[i];
        var instanceId = seg.eventRange.instance.instanceId;
        var eventHeight = eventInstanceHeights[instanceId];

        if (eventHeight != null) {
          segInputs.push({
            index: i,
            thickness: eventHeight,
            span: {
              start: seg.firstCol,
              end: seg.lastCol + 1
            }
          });
        } else {
          unknownHeightSegs.push(seg);
        }
      }

      var hiddenEntries = hierarchy.addSegs(segInputs);
      var segRects = hierarchy.toRects();

      var _a = placeRects(segRects, segs, cells),
          singleColPlacements = _a.singleColPlacements,
          multiColPlacements = _a.multiColPlacements,
          leftoverMargins = _a.leftoverMargins;

      var moreCnts = [];
      var moreMarginTops = []; // add segs with unknown heights

      for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {
        var seg = unknownHeightSegs_1[_i];
        multiColPlacements[seg.firstCol].push({
          seg: seg,
          isVisible: false,
          isAbsolute: true,
          absoluteTop: 0,
          marginTop: 0
        });

        for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {
          singleColPlacements[col].push({
            seg: resliceSeg(seg, col, col + 1, cells),
            isVisible: false,
            isAbsolute: false,
            absoluteTop: 0,
            marginTop: 0
          });
        }
      } // add the hidden entries


      for (var col = 0; col < cells.length; col += 1) {
        moreCnts.push(0);
      }

      for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {
        var hiddenEntry = hiddenEntries_1[_b];
        var seg = segs[hiddenEntry.index];
        var hiddenSpan = hiddenEntry.span;
        multiColPlacements[hiddenSpan.start].push({
          seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
          isVisible: false,
          isAbsolute: true,
          absoluteTop: 0,
          marginTop: 0
        });

        for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
          moreCnts[col] += 1;
          singleColPlacements[col].push({
            seg: resliceSeg(seg, col, col + 1, cells),
            isVisible: false,
            isAbsolute: false,
            absoluteTop: 0,
            marginTop: 0
          });
        }
      } // deal with leftover margins


      for (var col = 0; col < cells.length; col += 1) {
        moreMarginTops.push(leftoverMargins[col]);
      }

      return {
        singleColPlacements: singleColPlacements,
        multiColPlacements: multiColPlacements,
        moreCnts: moreCnts,
        moreMarginTops: moreMarginTops
      };
    } // rects ordered by top coord, then left


    function placeRects(allRects, segs, cells) {
      var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
      var singleColPlacements = [];
      var multiColPlacements = [];
      var leftoverMargins = [];

      for (var col = 0; col < cells.length; col += 1) {
        var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements

        var singlePlacements = [];
        var currentHeight = 0;
        var currentMarginTop = 0;

        for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {
          var rect = rects_1[_i];
          var seg = segs[rect.index];
          singlePlacements.push({
            seg: resliceSeg(seg, col, col + 1, cells),
            isVisible: true,
            isAbsolute: false,
            absoluteTop: rect.levelCoord,
            marginTop: rect.levelCoord - currentHeight
          });
          currentHeight = rect.levelCoord + rect.thickness;
        } // compute mixed static/absolute segs in multiPlacements


        var multiPlacements = [];
        currentHeight = 0;
        currentMarginTop = 0;

        for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {
          var rect = rects_2[_a];
          var seg = segs[rect.index];
          var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?

          var isFirstCol = rect.span.start === col;
          currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg

          currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg

          if (isAbsolute) {
            currentMarginTop += rect.thickness;

            if (isFirstCol) {
              multiPlacements.push({
                seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                isVisible: true,
                isAbsolute: true,
                absoluteTop: rect.levelCoord,
                marginTop: 0
              });
            }
          } else if (isFirstCol) {
            multiPlacements.push({
              seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
              isVisible: true,
              isAbsolute: false,
              absoluteTop: rect.levelCoord,
              marginTop: currentMarginTop // claim the margin

            });
            currentMarginTop = 0;
          }
        }

        singleColPlacements.push(singlePlacements);
        multiColPlacements.push(multiPlacements);
        leftoverMargins.push(currentMarginTop);
      }

      return {
        singleColPlacements: singleColPlacements,
        multiColPlacements: multiColPlacements,
        leftoverMargins: leftoverMargins
      };
    }

    function groupRectsByEachCol(rects, colCnt) {
      var rectsByEachCol = [];

      for (var col = 0; col < colCnt; col += 1) {
        rectsByEachCol.push([]);
      }

      for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {
        var rect = rects_3[_i];

        for (var col = rect.span.start; col < rect.span.end; col += 1) {
          rectsByEachCol[col].push(rect);
        }
      }

      return rectsByEachCol;
    }

    function resliceSeg(seg, spanStart, spanEnd, cells) {
      if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
        return seg;
      }

      var eventRange = seg.eventRange;
      var origRange = eventRange.range;
      var slicedRange = intersectRanges(origRange, {
        start: cells[spanStart].date,
        end: addDays(cells[spanEnd - 1].date, 1)
      });
      return __assign(__assign({}, seg), {
        firstCol: spanStart,
        lastCol: spanEnd - 1,
        eventRange: {
          def: eventRange.def,
          ui: __assign(__assign({}, eventRange.ui), {
            durationEditable: false
          }),
          instance: eventRange.instance,
          range: slicedRange
        },
        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),
        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()
      });
    }

    var DayGridSegHierarchy = function (_super) {
      __extends(DayGridSegHierarchy, _super);

      function DayGridSegHierarchy() {
        var _this = _super !== null && _super.apply(this, arguments) || this; // config


        _this.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space

        _this.forceHidden = {};
        return _this;
      }

      DayGridSegHierarchy.prototype.addSegs = function (segInputs) {
        var _this = this;

        var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);

        var entriesByLevel = this.entriesByLevel;

        var excludeHidden = function (entry) {
          return !_this.forceHidden[buildEntryKey(entry)];
        }; // remove the forced-hidden segs


        for (var level = 0; level < entriesByLevel.length; level += 1) {
          entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
        }

        return hiddenSegs;
      };

      DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {
        var _a = this,
            entriesByLevel = _a.entriesByLevel,
            forceHidden = _a.forceHidden;

        var touchingEntry = insertion.touchingEntry,
            touchingLevel = insertion.touchingLevel,
            touchingLateral = insertion.touchingLateral;

        if (this.hiddenConsumes && touchingEntry) {
          var touchingEntryId = buildEntryKey(touchingEntry); // if not already hidden

          if (!forceHidden[touchingEntryId]) {
            if (this.allowReslicing) {
              var placeholderEntry = __assign(__assign({}, touchingEntry), {
                span: intersectSpans(touchingEntry.span, entry.span)
              });

              var placeholderEntryId = buildEntryKey(placeholderEntry);
              forceHidden[placeholderEntryId] = true;
              entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder

              this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it
            } else {
              forceHidden[touchingEntryId] = true;
              hiddenEntries.push(touchingEntry);
            }
          }
        }

        return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);
      };

      return DayGridSegHierarchy;
    }(SegHierarchy);

    var TableRow = function (_super) {
      __extends(TableRow, _super);

      function TableRow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.cellElRefs = new RefMap(); // the <td>

        _this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame

        _this.fgElRefs = new RefMap(); // the fc-daygrid-day-events

        _this.segHarnessRefs = new RefMap(); // indexed by "instanceId:firstCol"

        _this.rootElRef = createRef();
        _this.state = {
          framePositions: null,
          maxContentHeight: null,
          eventInstanceHeights: {}
        };
        return _this;
      }

      TableRow.prototype.render = function () {
        var _this = this;

        var _a = this,
            props = _a.props,
            state = _a.state,
            context = _a.context;

        var options = context.options;
        var colCnt = props.cells.length;
        var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
        var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
        var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
        var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);

        var _b = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),
            singleColPlacements = _b.singleColPlacements,
            multiColPlacements = _b.multiColPlacements,
            moreCnts = _b.moreCnts,
            moreMarginTops = _b.moreMarginTops;

        var isForcedInvisible = // TODO: messy way to compute this
        props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};
        return createElement("tr", {
          ref: this.rootElRef
        }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {
          var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);

          var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);

          return createElement(TableCell, {
            key: cell.key,
            elRef: _this.cellElRefs.createRef(cell.key),
            innerElRef: _this.frameElRefs.createRef(cell.key)
            /* FF <td> problem, but okay to use for left/right. TODO: rename prop */
            ,
            dateProfile: props.dateProfile,
            date: cell.date,
            showDayNumber: props.showDayNumbers,
            showWeekNumber: props.showWeekNumbers && col === 0,
            forceDayTop: props.showWeekNumbers
            /* even displaying weeknum for row, not necessarily day */
            ,
            todayRange: props.todayRange,
            eventSelection: props.eventSelection,
            eventDrag: props.eventDrag,
            eventResize: props.eventResize,
            extraHookProps: cell.extraHookProps,
            extraDataAttrs: cell.extraDataAttrs,
            extraClassNames: cell.extraClassNames,
            extraDateSpan: cell.extraDateSpan,
            moreCnt: moreCnts[col],
            moreMarginTop: moreMarginTops[col],
            singlePlacements: singleColPlacements[col],
            fgContentElRef: _this.fgElRefs.createRef(cell.key),
            fgContent: // Fragment scopes the keys
            createElement(Fragment, null, createElement(Fragment, null, normalFgNodes), createElement(Fragment, null, mirrorFgNodes)),
            bgContent: // Fragment scopes the keys
            createElement(Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))
          });
        }));
      };

      TableRow.prototype.componentDidMount = function () {
        this.updateSizing(true);
      };

      TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {
        var currentProps = this.props;
        this.updateSizing(!isPropsEqual(prevProps, currentProps));
      };

      TableRow.prototype.getHighlightSegs = function () {
        var props = this.props;

        if (props.eventDrag && props.eventDrag.segs.length) {
          // messy check
          return props.eventDrag.segs;
        }

        if (props.eventResize && props.eventResize.segs.length) {
          // messy check
          return props.eventResize.segs;
        }

        return props.dateSelectionSegs;
      };

      TableRow.prototype.getMirrorSegs = function () {
        var props = this.props;

        if (props.eventResize && props.eventResize.segs.length) {
          // messy check
          return props.eventResize.segs;
        }

        return [];
      };

      TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
        var context = this.context;
        var eventSelection = this.props.eventSelection;
        var framePositions = this.state.framePositions;
        var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1

        var isMirror = isDragging || isResizing || isDateSelecting;
        var nodes = [];

        if (framePositions) {
          for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {
            var placement = segPlacements_1[_i];
            var seg = placement.seg;
            var instanceId = seg.eventRange.instance.instanceId;
            var key = instanceId + ':' + col;
            var isVisible = placement.isVisible && !isForcedInvisible[instanceId];
            var isAbsolute = placement.isAbsolute;
            var left = '';
            var right = '';

            if (isAbsolute) {
              if (context.isRtl) {
                right = 0;
                left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
              } else {
                left = 0;
                right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
              }
            }
            /*
            known bug: events that are force to be list-item but span multiple days still take up space in later columns
            todo: in print view, for multi-day events, don't display title within non-start/end segs
            */


            nodes.push(createElement("div", {
              className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),
              key: key,
              ref: isMirror ? null : this.segHarnessRefs.createRef(key),
              style: {
                visibility: isVisible ? '' : 'hidden',
                marginTop: isAbsolute ? '' : placement.marginTop,
                top: isAbsolute ? placement.absoluteTop : '',
                left: left,
                right: right
              }
            }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, __assign({
              seg: seg,
              isDragging: isDragging,
              isSelected: instanceId === eventSelection,
              defaultDisplayEventEnd: defaultDisplayEventEnd
            }, getSegMeta(seg, todayRange))) : createElement(TableBlockEvent, __assign({
              seg: seg,
              isDragging: isDragging,
              isResizing: isResizing,
              isDateSelecting: isDateSelecting,
              isSelected: instanceId === eventSelection,
              defaultDisplayEventEnd: defaultDisplayEventEnd
            }, getSegMeta(seg, todayRange)))));
          }
        }

        return nodes;
      };

      TableRow.prototype.renderFillSegs = function (segs, fillType) {
        var isRtl = this.context.isRtl;
        var todayRange = this.props.todayRange;
        var framePositions = this.state.framePositions;
        var nodes = [];

        if (framePositions) {
          for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
            var seg = segs_1[_i];
            var leftRightCss = isRtl ? {
              right: 0,
              left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
            } : {
              left: 0,
              right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
            };
            nodes.push(createElement("div", {
              key: buildEventRangeKey(seg.eventRange),
              className: "fc-daygrid-bg-harness",
              style: leftRightCss
            }, fillType === 'bg-event' ? createElement(BgEvent, __assign({
              seg: seg
            }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
          }
        }

        return createElement.apply(void 0, __spreadArray([Fragment, {}], nodes));
      };

      TableRow.prototype.updateSizing = function (isExternalSizingChange) {
        var _a = this,
            props = _a.props,
            frameElRefs = _a.frameElRefs;

        if (!props.forPrint && props.clientWidth !== null // positioning ready?
        ) {
          if (isExternalSizingChange) {
            var frameEls = props.cells.map(function (cell) {
              return frameElRefs.currentMap[cell.key];
            });

            if (frameEls.length) {
              var originEl = this.rootElRef.current;
              this.setState({
                framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal
                false)
              });
            }
          }

          var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
          this.setState({
            eventInstanceHeights: this.queryEventInstanceHeights(),
            maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
          });
        }
      };

      TableRow.prototype.queryEventInstanceHeights = function () {
        var segElMap = this.segHarnessRefs.currentMap;
        var eventInstanceHeights = {}; // get the max height amongst instance segs

        for (var key in segElMap) {
          var height = Math.round(segElMap[key].getBoundingClientRect().height);
          var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key

          eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);
        }

        return eventInstanceHeights;
      };

      TableRow.prototype.computeMaxContentHeight = function () {
        var firstKey = this.props.cells[0].key;
        var cellEl = this.cellElRefs.currentMap[firstKey];
        var fcContainerEl = this.fgElRefs.currentMap[firstKey];
        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
      };

      TableRow.prototype.getCellEls = function () {
        var elMap = this.cellElRefs.currentMap;
        return this.props.cells.map(function (cell) {
          return elMap[cell.key];
        });
      };

      return TableRow;
    }(DateComponent);

    TableRow.addStateEquality({
      eventInstanceHeights: isPropsEqual
    });

    function buildMirrorPlacements(mirrorSegs, colPlacements) {
      if (!mirrorSegs.length) {
        return [];
      }

      var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?

      return mirrorSegs.map(function (seg) {
        return {
          seg: seg,
          isVisible: true,
          isAbsolute: true,
          absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
          marginTop: 0
        };
      });
    }

    function buildAbsoluteTopHash(colPlacements) {
      var topsByInstanceId = {};

      for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {
        var placements = colPlacements_1[_i];

        for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {
          var placement = placements_1[_a];
          topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
        }
      }

      return topsByInstanceId;
    }

    var Table = function (_super) {
      __extends(Table, _super);

      function Table() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.splitBusinessHourSegs = memoize(splitSegsByRow);
        _this.splitBgEventSegs = memoize(splitSegsByRow);
        _this.splitFgEventSegs = memoize(splitSegsByRow);
        _this.splitDateSelectionSegs = memoize(splitSegsByRow);
        _this.splitEventDrag = memoize(splitInteractionByRow);
        _this.splitEventResize = memoize(splitInteractionByRow);
        _this.rowRefs = new RefMap();

        _this.handleRootEl = function (rootEl) {
          _this.rootEl = rootEl;

          if (rootEl) {
            _this.context.registerInteractiveComponent(_this, {
              el: rootEl,
              isHitComboAllowed: _this.props.isHitComboAllowed
            });
          } else {
            _this.context.unregisterInteractiveComponent(_this);
          }
        };

        return _this;
      }

      Table.prototype.render = function () {
        var _this = this;

        var props = this.props;
        var dateProfile = props.dateProfile,
            dayMaxEventRows = props.dayMaxEventRows,
            dayMaxEvents = props.dayMaxEvents,
            expandRows = props.expandRows;
        var rowCnt = props.cells.length;
        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
        var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
        var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
        var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit
        // TODO: best place to normalize these options?

        if (limitViaBalanced && !expandRows) {
          limitViaBalanced = false;
          dayMaxEventRows = null;
          dayMaxEvents = null;
        }

        var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?
        ];
        return createElement("div", {
          className: classNames.join(' '),
          ref: this.handleRootEl,
          style: {
            // these props are important to give this wrapper correct dimensions for interactions
            // TODO: if we set it here, can we avoid giving to inner tables?
            width: props.clientWidth,
            minWidth: props.tableMinWidth
          }
        }, createElement(NowTimer, {
          unit: "day"
        }, function (nowDate, todayRange) {
          return createElement(Fragment, null, createElement("table", {
            className: "fc-scrollgrid-sync-table",
            style: {
              width: props.clientWidth,
              minWidth: props.tableMinWidth,
              height: expandRows ? props.clientHeight : ''
            }
          }, props.colGroupNode, createElement("tbody", null, props.cells.map(function (cells, row) {
            return createElement(TableRow, {
              ref: _this.rowRefs.createRef(row),
              key: cells.length ? cells[0].date.toISOString()
              /* best? or put key on cell? or use diff formatter? */
              : row // in case there are no cells (like when resource view is loading)
              ,
              showDayNumbers: rowCnt > 1,
              showWeekNumbers: props.showWeekNumbers,
              todayRange: todayRange,
              dateProfile: dateProfile,
              cells: cells,
              renderIntro: props.renderRowIntro,
              businessHourSegs: businessHourSegsByRow[row],
              eventSelection: props.eventSelection,
              bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)
              /* hack */
              ,
              fgEventSegs: fgEventSegsByRow[row],
              dateSelectionSegs: dateSelectionSegsByRow[row],
              eventDrag: eventDragByRow[row],
              eventResize: eventResizeByRow[row],
              dayMaxEvents: dayMaxEvents,
              dayMaxEventRows: dayMaxEventRows,
              clientWidth: props.clientWidth,
              clientHeight: props.clientHeight,
              forPrint: props.forPrint
            });
          }))));
        }));
      }; // Hit System
      // ----------------------------------------------------------------------------------------------------


      Table.prototype.prepareHits = function () {
        this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {
          return rowObj.getCellEls()[0];
        }), // first cell el in each row. TODO: not optimal
        false, true);
        this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row
        true, // horizontal
        false);
      };

      Table.prototype.queryHit = function (positionLeft, positionTop) {
        var _a = this,
            colPositions = _a.colPositions,
            rowPositions = _a.rowPositions;

        var col = colPositions.leftToIndex(positionLeft);
        var row = rowPositions.topToIndex(positionTop);

        if (row != null && col != null) {
          var cell = this.props.cells[row][col];
          return {
            dateProfile: this.props.dateProfile,
            dateSpan: __assign({
              range: this.getCellRange(row, col),
              allDay: true
            }, cell.extraDateSpan),
            dayEl: this.getCellEl(row, col),
            rect: {
              left: colPositions.lefts[col],
              right: colPositions.rights[col],
              top: rowPositions.tops[row],
              bottom: rowPositions.bottoms[row]
            },
            layer: 0
          };
        }

        return null;
      };

      Table.prototype.getCellEl = function (row, col) {
        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal
      };

      Table.prototype.getCellRange = function (row, col) {
        var start = this.props.cells[row][col].date;
        var end = addDays(start, 1);
        return {
          start: start,
          end: end
        };
      };

      return Table;
    }(DateComponent);

    function isSegAllDay(seg) {
      return seg.eventRange.def.allDay;
    }

    var DayTableSlicer = function (_super) {
      __extends(DayTableSlicer, _super);

      function DayTableSlicer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.forceDayIfListItem = true;
        return _this;
      }

      DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {
        return dayTableModel.sliceRange(dateRange);
      };

      return DayTableSlicer;
    }(Slicer);

    var DayTable = function (_super) {
      __extends(DayTable, _super);

      function DayTable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.slicer = new DayTableSlicer();
        _this.tableRef = createRef();
        return _this;
      }

      DayTable.prototype.render = function () {
        var _a = this,
            props = _a.props,
            context = _a.context;

        return createElement(Table, __assign({
          ref: this.tableRef
        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {
          dateProfile: props.dateProfile,
          cells: props.dayTableModel.cells,
          colGroupNode: props.colGroupNode,
          tableMinWidth: props.tableMinWidth,
          renderRowIntro: props.renderRowIntro,
          dayMaxEvents: props.dayMaxEvents,
          dayMaxEventRows: props.dayMaxEventRows,
          showWeekNumbers: props.showWeekNumbers,
          expandRows: props.expandRows,
          headerAlignElRef: props.headerAlignElRef,
          clientWidth: props.clientWidth,
          clientHeight: props.clientHeight,
          forPrint: props.forPrint
        }));
      };

      return DayTable;
    }(DateComponent);

    var DayTableView = function (_super) {
      __extends(DayTableView, _super);

      function DayTableView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.buildDayTableModel = memoize(buildDayTableModel);
        _this.headerRef = createRef();
        _this.tableRef = createRef();
        return _this;
      }

      DayTableView.prototype.render = function () {
        var _this = this;

        var _a = this.context,
            options = _a.options,
            dateProfileGenerator = _a.dateProfileGenerator;
        var props = this.props;
        var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
        var headerContent = options.dayHeaders && createElement(DayHeader, {
          ref: this.headerRef,
          dateProfile: props.dateProfile,
          dates: dayTableModel.headerDates,
          datesRepDistinctDays: dayTableModel.rowCnt === 1
        });

        var bodyContent = function (contentArg) {
          return createElement(DayTable, {
            ref: _this.tableRef,
            dateProfile: props.dateProfile,
            dayTableModel: dayTableModel,
            businessHours: props.businessHours,
            dateSelection: props.dateSelection,
            eventStore: props.eventStore,
            eventUiBases: props.eventUiBases,
            eventSelection: props.eventSelection,
            eventDrag: props.eventDrag,
            eventResize: props.eventResize,
            nextDayThreshold: options.nextDayThreshold,
            colGroupNode: contentArg.tableColGroupNode,
            tableMinWidth: contentArg.tableMinWidth,
            dayMaxEvents: options.dayMaxEvents,
            dayMaxEventRows: options.dayMaxEventRows,
            showWeekNumbers: options.weekNumbers,
            expandRows: !props.isHeightAuto,
            headerAlignElRef: _this.headerElRef,
            clientWidth: contentArg.clientWidth,
            clientHeight: contentArg.clientHeight,
            forPrint: props.forPrint
          });
        };

        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
      };

      return DayTableView;
    }(TableView);

    function buildDayTableModel(dateProfile, dateProfileGenerator) {
      var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
      return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
    }

    var TableDateProfileGenerator = function (_super) {
      __extends(TableDateProfileGenerator, _super);

      function TableDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
      } // Computes the date range that will be rendered.


      TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
        var dateEnv = this.props.dateEnv;

        var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);

        var start = renderRange.start;
        var end = renderRange.end;
        var endOfWeek; // year and month views should be aligned with weeks. this is already done for week

        if (/^(year|month)$/.test(currentRangeUnit)) {
          start = dateEnv.startOfWeek(start); // make end-of-week if not already

          endOfWeek = dateEnv.startOfWeek(end);

          if (endOfWeek.valueOf() !== end.valueOf()) {
            end = addWeeks(endOfWeek, 1);
          }
        } // ensure 6 weeks


        if (this.props.monthMode && this.props.fixedWeekCount) {
          var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
          diffWeeks(start, end));
          end = addWeeks(end, 6 - rowCnt);
        }

        return {
          start: start,
          end: end
        };
      };

      return TableDateProfileGenerator;
    }(DateProfileGenerator);

    var main = createPlugin({
      initialView: 'dayGridMonth',
      views: {
        dayGrid: {
          component: DayTableView,
          dateProfileGeneratorClass: TableDateProfileGenerator
        },
        dayGridDay: {
          type: 'dayGrid',
          duration: {
            days: 1
          }
        },
        dayGridWeek: {
          type: 'dayGrid',
          duration: {
            weeks: 1
          }
        },
        dayGridMonth: {
          type: 'dayGrid',
          duration: {
            months: 1
          },
          monthMode: true,
          fixedWeekCount: true
        }
      }
    });

    /* src/components/Calendar.svelte generated by Svelte v3.41.0 */

    function create_fragment$E(ctx) {
    	let fullcalendar;
    	let current;

    	fullcalendar = new FullCalendar({
    			props: { options: /*options*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(fullcalendar.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(fullcalendar, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fullcalendar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fullcalendar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fullcalendar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Calendar', slots, []);

    	const dates = [
    		{
    			"id": 3,
    			"status": "published",
    			"start": "2020-12-21",
    			"end": "2020-12-27",
    			"title": "In-game qualifiers",
    			"color": "#E91E63"
    		},
    		{
    			"id": 5,
    			"status": "published",
    			"start": "2020-12-08",
    			"end": "2020-12-21",
    			"title": "Registrations",
    			"color": "#FFC107"
    		},
    		{
    			"id": 6,
    			"status": "published",
    			"start": "2020-12-27",
    			"end": "2021-01-04",
    			"title": "Seeding",
    			"color": "#3F51B5"
    		},
    		{
    			"id": 7,
    			"status": "published",
    			"start": "2021-01-13",
    			"end": "2021-01-24",
    			"title": "Playoffs",
    			"color": "#00BCD4"
    		},
    		{
    			"id": 8,
    			"status": "published",
    			"start": "2021-01-30",
    			"end": "2021-02-26",
    			"title": "League Stage",
    			"color": "#9C27B0"
    		},
    		{
    			"id": 9,
    			"status": "published",
    			"start": "2021-03-12",
    			"end": "2021-03-14",
    			"title": "Finals",
    			"color": "#0b2742"
    		}
    	];

    	//const client = new RESTClient();
    	const options = {
    		initialView: 'dayGridMonth',
    		plugins: [main],
    		events: dates
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Calendar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		FullCalendar,
    		dayGridPlugin: main,
    		RESTClient,
    		moment,
    		dates,
    		options
    	});

    	return [options];
    }

    class Calendar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Calendar",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/pages/Schedule.svelte generated by Svelte v3.41.0 */
    const file$y = "src/pages/Schedule.svelte";

    function create_fragment$D(ctx) {
    	let link;
    	let t0;
    	let div0;
    	let h10;
    	let t2;
    	let video;
    	let t3;
    	let div2;
    	let div1;
    	let h11;
    	let t5;
    	let calendar;
    	let t6;
    	let insider;
    	let current;

    	video = new Video({
    			props: {
    				url: "https://www.youtube.com/watch?v=-gyBzQnsGT0",
    				thumb: "/images/day10_conquest_trailer_thumb_trailer.jpg"
    			},
    			$$inline: true
    		});

    	calendar = new Calendar({ $$inline: true });
    	insider = new Insider({ $$inline: true });

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			div0 = element("div");
    			h10 = element("h1");
    			h10.textContent = "Schedule";
    			t2 = space();
    			create_component(video.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			h11 = element("h1");
    			h11.textContent = "Tournament Calendar";
    			t5 = space();
    			create_component(calendar.$$.fragment);
    			t6 = space();
    			create_component(insider.$$.fragment);
    			attr_dev(link, "href", "https://fonts.googleapis.com/icon?family=Material+Icons");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$y, 6, 1, 196);
    			attr_dev(h10, "class", "title svelte-1wi9rn6");
    			add_location(h10, file$y, 11, 1, 346);
    			attr_dev(div0, "class", "top-section schedule-block svelte-1wi9rn6");
    			add_location(div0, file$y, 10, 0, 304);
    			attr_dev(h11, "class", "tournamnet-title");
    			add_location(h11, file$y, 17, 2, 620);
    			attr_dev(div1, "class", "calendar-box");
    			add_location(div1, file$y, 16, 1, 591);
    			attr_dev(div2, "class", "container");
    			add_location(div2, file$y, 15, 0, 566);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h10);
    			append_dev(div0, t2);
    			mount_component(video, div0, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h11);
    			append_dev(div1, t5);
    			mount_component(calendar, div1, null);
    			insert_dev(target, t6, anchor);
    			mount_component(insider, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			transition_in(calendar.$$.fragment, local);
    			transition_in(insider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			transition_out(calendar.$$.fragment, local);
    			transition_out(insider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(video);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			destroy_component(calendar);
    			if (detaching) detach_dev(t6);
    			destroy_component(insider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Schedule', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Schedule> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Calendar, Video, Insider });
    	return [];
    }

    class Schedule$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Schedule",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src/components/modal/VideoModal.svelte generated by Svelte v3.41.0 */

    const file$x = "src/components/modal/VideoModal.svelte";

    function create_fragment$C(ctx) {
    	let div1;
    	let div0;
    	let iframe;
    	let iframe_src_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			iframe = element("iframe");
    			attr_dev(iframe, "width", "420");
    			attr_dev(iframe, "height", "315");
    			if (!src_url_equal(iframe.src, iframe_src_value = "https://www.youtube.com/embed/tgbNymZ7vqY")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "class", "svelte-514za4");
    			add_location(iframe, file$x, 2, 2, 76);
    			attr_dev(div0, "class", "col-lg-12 col-xs-12 col-sm-12");
    			add_location(div0, file$x, 1, 1, 30);
    			attr_dev(div1, "class", "row no-gutters");
    			add_location(div1, file$x, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, iframe);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoModal', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoModal> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class VideoModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoModal",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /**
     * SSR Window 3.0.0
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */

    /* eslint-disable no-param-reassign */
    function isObject$2(obj) {
      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }

    function extend$2(target, src) {
      if (target === void 0) {
        target = {};
      }

      if (src === void 0) {
        src = {};
      }

      Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
          extend$2(target[key], src[key]);
        }
      });
    }

    var ssrDocument = {
      body: {},
      addEventListener: function () {},
      removeEventListener: function () {},
      activeElement: {
        blur: function () {},
        nodeName: ''
      },
      querySelector: function () {
        return null;
      },
      querySelectorAll: function () {
        return [];
      },
      getElementById: function () {
        return null;
      },
      createEvent: function () {
        return {
          initEvent: function () {}
        };
      },
      createElement: function () {
        return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute: function () {},
          getElementsByTagName: function () {
            return [];
          }
        };
      },
      createElementNS: function () {
        return {};
      },
      importNode: function () {
        return null;
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      }
    };

    function getDocument() {
      var doc = typeof document !== 'undefined' ? document : {};
      extend$2(doc, ssrDocument);
      return doc;
    }

    var ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ''
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      },
      history: {
        replaceState: function () {},
        pushState: function () {},
        go: function () {},
        back: function () {}
      },
      CustomEvent: function CustomEvent() {
        return this;
      },
      addEventListener: function () {},
      removeEventListener: function () {},
      getComputedStyle: function () {
        return {
          getPropertyValue: function () {
            return '';
          }
        };
      },
      Image: function () {},
      Date: function () {},
      screen: {},
      setTimeout: function () {},
      clearTimeout: function () {},
      matchMedia: function () {
        return {};
      },
      requestAnimationFrame: function (callback) {
        if (typeof setTimeout === 'undefined') {
          callback();
          return null;
        }

        return setTimeout(callback, 0);
      },
      cancelAnimationFrame: function (id) {
        if (typeof setTimeout === 'undefined') {
          return;
        }

        clearTimeout(id);
      }
    };

    function getWindow() {
      var win = typeof window !== 'undefined' ? window : {};
      extend$2(win, ssrWindow);
      return win;
    }

    /**
     * Dom7 3.0.0
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }
    /* eslint-disable no-proto */


    function makeReactive(obj) {
      var proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get: function get() {
          return proto;
        },
        set: function set(value) {
          proto.__proto__ = value;
        }
      });
    }

    var Dom7 = /*#__PURE__*/function (_Array) {
      _inheritsLoose(Dom7, _Array);

      function Dom7(items) {
        var _this;

        _this = _Array.call.apply(_Array, [this].concat(items)) || this;
        makeReactive(_assertThisInitialized(_this));
        return _this;
      }

      return Dom7;
    }( /*#__PURE__*/_wrapNativeSuper(Array));

    function arrayFlat(arr) {
      if (arr === void 0) {
        arr = [];
      }

      var res = [];
      arr.forEach(function (el) {
        if (Array.isArray(el)) {
          res.push.apply(res, arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }

    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }

    function arrayUnique(arr) {
      var uniqueArray = [];

      for (var i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }

    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      var a = [];
      var res = context.querySelectorAll(selector);

      for (var i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $(selector, context) {
      var window = getWindow();
      var document = getDocument();
      var arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          var tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (var i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $.fn = Dom7.prototype;

    function addClass() {
      for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
        classes[_key] = arguments[_key];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList;

        (_el$classList = el.classList).add.apply(_el$classList, classNames);
      });
      return this;
    }

    function removeClass() {
      for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList2;

        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
      });
      return this;
    }

    function toggleClass() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        classNames.forEach(function (className) {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass() {
      for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        classes[_key4] = arguments[_key4];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      return arrayFilter(this, function (el) {
        return classNames.filter(function (className) {
          return el.classList.contains(className);
        }).length > 0;
      }).length > 0;
    }

    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (var i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (var attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform(transform) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition$1(duration) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
      }

      return this;
    }

    function on() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          var _parents = $(target).parents(); // eslint-disable-line


          for (var k = 0; k < _parents.length; k += 1) {
            if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      var events = eventType.split(' ');
      var j;

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            var event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener: listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            var _event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

            el.dom7LiveListeners[_event].push({
              listener: listener,
              proxyListener: handleLiveEvent
            });

            el.addEventListener(_event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      var events = eventType.split(' ');

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          var handlers = void 0;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (var k = handlers.length - 1; k >= 0; k -= 1) {
              var handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger() {
      var window = getWindow();

      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var events = args[0].split(' ');
      var eventData = args[1];

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];

          if (window.CustomEvent) {
            var evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd$1(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles = this.styles();

          return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles2 = this.styles();

          return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        var window = getWindow();
        var document = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window ? window.scrollY : el.scrollTop;
        var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function styles() {
      var window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      var window = getWindow();
      var i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (var _prop in props) {
              this[i].style[_prop] = props[_prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach(function (el, index) {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      var result = arrayFilter(this, callback);
      return $(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var compareWith;
      var i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      var child = this[0];
      var i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      var length = this.length;

      if (index > length - 1) {
        return $([]);
      }

      if (index < 0) {
        var returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }

      return $([this[index]]);
    }

    function append() {
      var newChild;
      var document = getDocument();

      for (var k = 0; k < arguments.length; k += 1) {
        newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

        for (var i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (var j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend(newChild) {
      var document = getDocument();
      var i;
      var j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }

          return $([]);
        }

        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function nextAll(selector) {
      var nextEls = [];
      var el = this[0];
      if (!el) return $([]);

      while (el.nextElementSibling) {
        var _next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);

        el = _next;
      }

      return $(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        var el = this[0];

        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }

          return $([]);
        }

        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function prevAll(selector) {
      var prevEls = [];
      var el = this[0];
      if (!el) return $([]);

      while (el.previousElementSibling) {
        var _prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);

        el = _prev;
      }

      return $(prevEls);
    }

    function parent(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $(parents);
    }

    function parents(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var _parent = this[i].parentNode; // eslint-disable-line

        while (_parent) {
          if (selector) {
            if ($(_parent).is(selector)) parents.push(_parent);
          } else {
            parents.push(_parent);
          }

          _parent = _parent.parentNode;
        }
      }

      return $(parents);
    }

    function closest(selector) {
      var closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i += 1) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $(foundElements);
    }

    function children(selector) {
      var children = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var childNodes = this[i].children;

        for (var j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $(children);
    }

    function remove() {
      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    var Methods = {
      addClass: addClass,
      removeClass: removeClass,
      hasClass: hasClass,
      toggleClass: toggleClass,
      attr: attr,
      removeAttr: removeAttr,
      transform: transform,
      transition: transition$1,
      on: on,
      off: off,
      trigger: trigger,
      transitionEnd: transitionEnd$1,
      outerWidth: outerWidth,
      outerHeight: outerHeight,
      styles: styles,
      offset: offset,
      css: css,
      each: each,
      html: html,
      text: text,
      is: is,
      index: index,
      eq: eq,
      append: append,
      prepend: prepend,
      next: next,
      nextAll: nextAll,
      prev: prev,
      prevAll: prevAll,
      parent: parent,
      parents: parents,
      closest: closest,
      find: find,
      children: children,
      filter: filter,
      remove: remove
    };
    Object.keys(Methods).forEach(function (methodName) {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      var window = getWindow();
      var style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject$1(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend$1() {
      var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      var noExtend = ['__proto__', 'constructor', 'prototype'];

      for (var i = 1; i < arguments.length; i += 1) {
        var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
            return noExtend.indexOf(key) < 0;
          });

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function bindModuleMethods(instance, obj) {
      Object.keys(obj).forEach(function (key) {
        if (isObject$1(obj[key])) {
          Object.keys(obj[key]).forEach(function (subKey) {
            if (typeof obj[key][subKey] === 'function') {
              obj[key][subKey] = obj[key][subKey].bind(instance);
            }
          });
        }

        instance[key] = obj[key];
      });
    }

    function classesToSelector(classes) {
      if (classes === void 0) {
        classes = '';
      }

      return "." + classes.trim().replace(/([\.:\/])/g, '\\$1') // eslint-disable-line
      .replace(/ /g, '.');
    }

    function createElementIfNotDefined($container, params, createElements, checkProps) {
      var document = getDocument();

      if (createElements) {
        Object.keys(checkProps).forEach(function (key) {
          if (!params[key] && params.auto === true) {
            var element = document.createElement('div');
            element.className = checkProps[key];
            $container.append(element);
            params[key] = element;
          }
        });
      }

      return params;
    }

    var support;

    function calcSupport() {
      var window = getWindow();
      var document = getDocument();
      return {
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
        observer: function checkObserver() {
          return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
        }(),
        passiveListener: function checkPassiveListener() {
          var supportsPassive = false;

          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              }
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    var device;

    function calcDevice(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          userAgent = _ref.userAgent;

      var support = getSupport();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      var windows = platform === 'Win32';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!device) {
        device = calcDevice(overrides);
      }

      return device;
    }

    var browser;

    function calcBrowser() {
      var window = getWindow();

      function isSafari() {
        var ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isEdge: !!window.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    var supportsResizeObserver = function supportsResizeObserver() {
      var window = getWindow();
      return typeof window.ResizeObserver !== 'undefined';
    };

    var Resize = {
      name: 'resize',
      create: function create() {
        var swiper = this;
        extend$1(swiper, {
          resize: {
            observer: null,
            createObserver: function createObserver() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.resize.observer = new ResizeObserver(function (entries) {
                var width = swiper.width,
                    height = swiper.height;
                var newWidth = width;
                var newHeight = height;
                entries.forEach(function (_ref) {
                  var contentBoxSize = _ref.contentBoxSize,
                      contentRect = _ref.contentRect,
                      target = _ref.target;
                  if (target && target !== swiper.el) return;
                  newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                  newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });

                if (newWidth !== width || newHeight !== height) {
                  swiper.resize.resizeHandler();
                }
              });
              swiper.resize.observer.observe(swiper.el);
            },
            removeObserver: function removeObserver() {
              if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
                swiper.resize.observer.unobserve(swiper.el);
                swiper.resize.observer = null;
              }
            },
            resizeHandler: function resizeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('beforeResize');
              swiper.emit('resize');
            },
            orientationChangeHandler: function orientationChangeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('orientationchange');
            }
          }
        });
      },
      on: {
        init: function init(swiper) {
          var window = getWindow();

          if (swiper.params.resizeObserver && supportsResizeObserver()) {
            swiper.resize.createObserver();
            return;
          } // Emit resize


          window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

          window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
        destroy: function destroy(swiper) {
          var window = getWindow();
          swiper.resize.removeObserver();
          window.removeEventListener('resize', swiper.resize.resizeHandler);
          window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        }
      }
    };

    function _extends$2() {
      _extends$2 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends$2.apply(this, arguments);
    }
    var Observer = {
      attach: function attach(target, options) {
        if (options === void 0) {
          options = {};
        }

        var window = getWindow();
        var swiper = this;
        var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        var observer = new ObserverFunc(function (mutations) {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            swiper.emit('observerUpdate', mutations[0]);
            return;
          }

          var observerUpdate = function observerUpdate() {
            swiper.emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        swiper.observer.observers.push(observer);
      },
      init: function init() {
        var swiper = this;
        if (!swiper.support.observer || !swiper.params.observer) return;

        if (swiper.params.observeParents) {
          var containerParents = swiper.$el.parents();

          for (var i = 0; i < containerParents.length; i += 1) {
            swiper.observer.attach(containerParents[i]);
          }
        } // Observe container


        swiper.observer.attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        swiper.observer.attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.observer.observers.forEach(function (observer) {
          observer.disconnect();
        });
        swiper.observer.observers = [];
      }
    };
    var Observer$1 = {
      name: 'observer',
      params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          observer: _extends$2({}, Observer, {
            observers: []
          })
        });
      },
      on: {
        init: function init(swiper) {
          swiper.observer.init();
        },
        destroy: function destroy(swiper) {
          swiper.observer.destroy();
        }
      }
    };

    var modular = {
      useParams: function useParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            extend$1(instanceParams, module.params);
          }
        });
      },
      useModules: function useModules(modulesParams) {
        if (modulesParams === void 0) {
          modulesParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName];
          var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

          if (module.on && instance.on) {
            Object.keys(module.on).forEach(function (moduleEventName) {
              instance.on(moduleEventName, module.on[moduleEventName]);
            });
          } // Module create callback


          if (module.create) {
            module.create.bind(instance)(moduleParams);
          }
        });
      }
    };

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on: function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },
      once: function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },
      onAny: function onAny(handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },
      offAny: function offAny(handler) {
        var self = this;
        if (!self.eventsAnyListeners) return self;
        var index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },
      off: function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },
      emit: function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(function (eventHandler) {
              eventHandler.apply(context, [event].concat(data));
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }
    };

    function updateSize() {
      var swiper = this;
      var width;
      var height;
      var $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      extend$1(swiper, {
        width: width,
        height: height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      var swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      var params = swiper.params;
      var $wrapperEl = swiper.$wrapperEl,
          swiperSize = swiper.size,
          rtl = swiper.rtlTranslate,
          wrongRTL = swiper.wrongRTL;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      var slides = $wrapperEl.children("." + swiper.params.slideClass);
      var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      var snapGrid = [];
      var slidesGrid = [];
      var slidesSizesGrid = [];
      var offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      var offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      var previousSnapGridLength = swiper.snapGrid.length;
      var previousSlidesGridLength = swiper.slidesGrid.length;
      var spaceBetween = params.spaceBetween;
      var slidePosition = -offsetBefore;
      var prevSlideSize = 0;
      var index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      });
      var slidesNumberEvenToRows;

      if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }

        if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
      } // Calc slides


      var slideSize;
      var slidesPerColumn = params.slidesPerColumn;
      var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
      var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

      for (var i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        var slide = slides.eq(i);

        if (params.slidesPerColumn > 1) {
          // Set slides order
          var newSlideOrderIndex = void 0;
          var column = void 0;
          var row = void 0;

          if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
            var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
            var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
            var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
            row = Math.floor(slideIndexInGroup / columnsInGroup);
            column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
            newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
            slide.css({
              '-webkit-box-ordinal-group': newSlideOrderIndex,
              '-moz-box-ordinal-group': newSlideOrderIndex,
              '-ms-flex-order': newSlideOrderIndex,
              '-webkit-order': newSlideOrderIndex,
              order: newSlideOrderIndex
            });
          } else if (params.slidesPerColumnFill === 'column') {
            column = Math.floor(i / slidesPerColumn);
            row = i - column * slidesPerColumn;

            if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
              row += 1;

              if (row >= slidesPerColumn) {
                row = 0;
                column += 1;
              }
            }
          } else {
            row = Math.floor(i / slidesPerRow);
            column = i - row * slidesPerRow;
          }

          slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : '');
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          var slideStyles = getComputedStyle(slide[0]);
          var currentTransform = slide[0].style.transform;
          var currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            var width = getDirectionPropertyValue(slideStyles, 'width');
            var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              var _slide$ = slide[0],
                  clientWidth = _slide$.clientWidth,
                  offsetWidth = _slide$.offsetWidth;
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = slideSize + "px";
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      var newSlidesGrid;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      }

      if (params.setWrapperSize) {
        var _$wrapperEl$css;

        $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
      }

      if (params.slidesPerColumn > 1) {
        var _$wrapperEl$css2;

        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));

        if (params.centeredSlides) {
          newSlidesGrid = [];

          for (var _i = 0; _i < snapGrid.length; _i += 1) {
            var slidesGridItem = snapGrid[_i];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }

          snapGrid = newSlidesGrid;
        }
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        newSlidesGrid = [];

        for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
          var _slidesGridItem = snapGrid[_i2];
          if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

          if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(_slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        var _slides$filter$css;

        var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter(function (_, slideIndex) {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function (snap) {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;

        if (_allSlidesSize < swiperSize) {
          var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
          snapGrid.forEach(function (snap, snapIndex) {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach(function (snap, snapIndex) {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      extend$1(swiper, {
        slides: slides,
        snapGrid: snapGrid,
        slidesGrid: slidesGrid,
        slidesSizesGrid: slidesSizesGrid
      });

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight(speed) {
      var swiper = this;
      var activeSlides = [];
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var newHeight = 0;
      var i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      var getSlideByIndex = function getSlideByIndex(index) {
        if (isVirtual) {
          return swiper.slides.filter(function (el) {
            return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
          })[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(function (slide) {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            var index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          var height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
    }

    function updateSlidesOffset() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate) {
      if (translate === void 0) {
        translate = this && this.translate || 0;
      }

      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides,
          rtl = swiper.rtlTranslate;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      var offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (var i = 0; i < slides.length; i += 1) {
        var slide = slides[i];
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

        if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
          var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
          var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
          var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

          if (isVisible) {
            swiper.visibleSlides.push(slide);
            swiper.visibleSlidesIndexes.push(i);
            slides.eq(i).addClass(params.slideVisibleClass);
          }
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
      }

      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      var swiper = this;

      if (typeof translate === 'undefined') {
        var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      var params = swiper.params;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      var progress = swiper.progress,
          isBeginning = swiper.isBeginning,
          isEnd = swiper.isEnd;
      var wasBeginning = isBeginning;
      var wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      extend$1(swiper, {
        progress: progress,
        isBeginning: isBeginning,
        isEnd: isEnd
      });
      if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      var swiper = this;
      var slides = swiper.slides,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex,
          realIndex = swiper.realIndex;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
      var activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      var swiper = this;
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      var slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          params = swiper.params,
          previousIndex = swiper.activeIndex,
          previousRealIndex = swiper.realIndex,
          previousSnapIndex = swiper.snapIndex;
      var activeIndex = newActiveIndex;
      var snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      extend$1(swiper, {
        snapIndex: snapIndex,
        realIndex: realIndex,
        previousIndex: previousIndex,
        activeIndex: activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      var swiper = this;
      var params = swiper.params;
      var slide = $(e.target).closest("." + params.slideClass)[0];
      var slideFound = false;
      var slideIndex;

      if (slide) {
        for (var i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize: updateSize,
      updateSlides: updateSlides,
      updateAutoHeight: updateAutoHeight,
      updateSlidesOffset: updateSlidesOffset,
      updateSlidesProgress: updateSlidesProgress,
      updateProgress: updateProgress,
      updateSlidesClasses: updateSlidesClasses,
      updateActiveIndex: updateActiveIndex,
      updateClickedSlide: updateClickedSlide
    };

    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
      }

      var swiper = this;
      var params = swiper.params,
          rtl = swiper.rtlTranslate,
          translate = swiper.translate,
          $wrapperEl = swiper.$wrapperEl;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      var currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      var swiper = this;
      var rtl = swiper.rtlTranslate,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          wrapperEl = swiper.wrapperEl,
          progress = swiper.progress;
      var x = 0;
      var y = 0;
      var z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
        translate = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (translateBounds === void 0) {
        translateBounds = true;
      }

      var swiper = this;
      var params = swiper.params,
          wrapperEl = swiper.wrapperEl;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      var minTranslate = swiper.minTranslate();
      var maxTranslate = swiper.maxTranslate();
      var newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        var isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate: setTranslate,
      minTranslate: minTranslate,
      maxTranslate: maxTranslate,
      translateTo: translateTo
    };

    function setTransition(duration, byController) {
      var swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
          params = swiper.params,
          previousIndex = swiper.previousIndex;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit('transitionStart');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionStart');
          return;
        }

        swiper.emit('slideChangeTransitionStart');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionStart');
        } else {
          swiper.emit('slidePrevTransitionStart');
        }
      }
    }

    function transitionEnd(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
          previousIndex = swiper.previousIndex,
          params = swiper.params;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit('transitionEnd');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionEnd');
          return;
        }

        swiper.emit('slideChangeTransitionEnd');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionEnd');
        } else {
          swiper.emit('slidePrevTransitionEnd');
        }
      }
    }

    var transition = {
      setTransition: setTransition,
      transitionStart: transitionStart,
      transitionEnd: transitionEnd
    };

    function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + "] given.");
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        var indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        var isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      var swiper = this;
      var slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      var params = swiper.params,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          previousIndex = swiper.previousIndex,
          activeIndex = swiper.activeIndex,
          rtl = swiper.rtlTranslate,
          wrapperEl = swiper.wrapperEl,
          enabled = swiper.enabled;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      var translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          var normalizedTranslate = -Math.floor(translate * 100);
          var normalizedGird = Math.floor(slidesGrid[i] * 100);
          var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGird) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      var direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = -translate;

        if (rtl) {
          t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
          animating = swiper.animating,
          enabled = swiper.enabled;
      if (!enabled) return swiper;
      var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
          animating = swiper.animating,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      var translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      var normalizedTranslate = normalize(translate);
      var normalizedSnapGrid = snapGrid.map(function (val) {
        return normalize(val);
      });
      var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        snapGrid.forEach(function (snap) {
          if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
      }

      var prevIndex;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (threshold === void 0) {
        threshold = 0.5;
      }

      var swiper = this;
      var index = swiper.activeIndex;
      var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl;
      var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      var slideToIndex = swiper.clickedIndex;
      var realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
            nextTick(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
          nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo: slideTo,
      slideToLoop: slideToLoop,
      slideNext: slideNext,
      slidePrev: slidePrev,
      slideReset: slideReset,
      slideToClosest: slideToClosest,
      slideToClickedSlide: slideToClickedSlide
    };

    function loopCreate() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
      var slides = $wrapperEl.children("." + params.slideClass);

      if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (var i = 0; i < blankSlidesNum; i += 1) {
            var blankNode = $(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
            $wrapperEl.append(blankNode);
          }

          slides = $wrapperEl.children("." + params.slideClass);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      var prependSlides = [];
      var appendSlides = [];
      slides.each(function (el, index) {
        var slide = $(el);

        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }

        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }

        slide.attr('data-swiper-slide-index', index);
      });

      for (var _i = 0; _i < appendSlides.length; _i += 1) {
        $wrapperEl.append($(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
        $wrapperEl.prepend($(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      var swiper = this;
      swiper.emit('beforeLoopFix');
      var activeIndex = swiper.activeIndex,
          slides = swiper.slides,
          loopedSlides = swiper.loopedSlides,
          allowSlidePrev = swiper.allowSlidePrev,
          allowSlideNext = swiper.allowSlideNext,
          snapGrid = swiper.snapGrid,
          rtl = swiper.rtlTranslate;
      var newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      var snapTranslate = -snapGrid[activeIndex];
      var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;

        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (_slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          slides = swiper.slides;
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate: loopCreate,
      loopFix: loopFix,
      loopDestroy: loopDestroy
    };

    function setGrabCursor(moving) {
      var swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      var el = swiper.el;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      var swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper.el.style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor: setGrabCursor,
      unsetGrabCursor: unsetGrabCursor
    };

    function appendSlide(slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params;

      if (params.loop) {
        swiper.loopDestroy();
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }
    }

    function prependSlide(slides) {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;

      if (params.loop) {
        swiper.loopDestroy();
      }

      var newActiveIndex = activeIndex + 1;

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index, slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
      }

      var baseLength = swiper.slides.length;

      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }

      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }

      var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      var slidesBuffer = [];

      for (var i = baseLength - 1; i >= index; i -= 1) {
        var currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var _i = 0; _i < slides.length; _i += 1) {
          if (slides[_i]) $wrapperEl.append(slides[_i]);
        }

        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }

      for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
        $wrapperEl.append(slidesBuffer[_i2]);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeSlide(slidesIndexes) {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
      }

      var newActiveIndex = activeIndexBuffer;
      var indexToRemove;

      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (var i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }

        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeAllSlides() {
      var swiper = this;
      var slidesIndexes = [];

      for (var i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }

      swiper.removeSlide(slidesIndexes);
    }

    var manipulation = {
      appendSlide: appendSlide,
      prependSlide: prependSlide,
      addSlide: addSlide,
      removeSlide: removeSlide,
      removeAllSlides: removeAllSlides
    };

    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }

      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        var found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      var swiper = this;
      var document = getDocument();
      var window = getWindow();
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          enabled = swiper.enabled;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      var $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }

      var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass;
      var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      var startX = touches.currentX;
      var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      extend$1(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;

        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      var document = getDocument();
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;

        if (data.isTouched) {
          extend$1(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      var diffX = touches.currentX - touches.startX;
      var diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        var touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      var diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      var disableParentSwiper = true;
      var resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (params.freeMode) {
        // Velocity
        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now()
        });
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          $wrapperEl = swiper.$wrapperEl,
          slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      var touchEndTime = now();
      var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick(function () {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      var currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeModeMomentum) {
          if (data.velocities.length > 1) {
            var lastMoveEvent = data.velocities.pop();
            var velocityEvent = data.velocities.pop();
            var distance = lastMoveEvent.position - velocityEvent.position;
            var time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.


            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeModeMomentumVelocityRatio;
          data.velocities.length = 0;
          var momentumDuration = 1000 * params.freeModeMomentumRatio;
          var momentumDistance = swiper.velocity * momentumDuration;
          var newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          var doBounce = false;
          var afterBouncePosition;
          var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
          var needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeModeSticky) {
            var nextSlide;

            for (var j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            swiper.once('transitionEnd', function () {
              swiper.loopFix();
            });
          } // Fix duration


          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeModeSticky) {
              // If freeModeSticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeModeMomentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              swiper.emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(function () {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          swiper.emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        return;
      } // Find current slide


      var stopIndex = 0;
      var groupSize = swiper.slidesSizesGrid[0];

      for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + _increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + _increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size


      var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      var swiper = this;
      var params = swiper.params,
          el = swiper.el;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      var allowSlideNext = swiper.allowSlideNext,
          allowSlidePrev = swiper.allowSlidePrev,
          snapGrid = swiper.snapGrid; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      var swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      var swiper = this;
      var wrapperEl = swiper.wrapperEl,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        if (rtlTranslate) {
          swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
          swiper.translate = -wrapperEl.scrollLeft;
        }
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    var dummyEventAttached = false;

    function dummyEventListener() {}

    function attachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
            passive: false,
            capture: capture
          } : capture);
          el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }

          if (!dummyEventAttached) {
            document.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
          }
        }

        if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
          el.addEventListener('mousedown', swiper.onTouchStart, false);
          document.addEventListener('mousemove', swiper.onTouchMove, capture);
          document.addEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.addEventListener('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper.on('observerUpdate', onResize, true);
      }
    }

    function detachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }
        }

        if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
          el.removeEventListener('mousedown', swiper.onTouchStart, false);
          document.removeEventListener('mousemove', swiper.onTouchMove, capture);
          document.removeEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.removeEventListener('scroll', swiper.onScroll);
      } // Resize handler


      swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
    }

    var events = {
      attachEvents: attachEvents,
      detachEvents: detachEvents
    };

    function setBreakpoint() {
      var swiper = this;
      var activeIndex = swiper.activeIndex,
          initialized = swiper.initialized,
          _swiper$loopedSlides = swiper.loopedSlides,
          loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
          params = swiper.params,
          $el = swiper.$el;
      var breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];
          if (typeof paramValue === 'undefined') return;

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = params.slidesPerColumn > 1;
      var isMultiRow = breakpointParams.slidesPerColumn > 1;
      var wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");

        if (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column' || !breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column') {
          $el.addClass(params.containerModifierClass + "multirow-column");
        }

        swiper.emitContainerClasses();
      }

      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      var isEnabled = swiper.params.enabled;
      extend$1(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = 'window';
      }

      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      var breakpoint = false;
      var window = getWindow();
      var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      var points = Object.keys(breakpoints).map(function (point) {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          var minRatio = parseFloat(point.substr(1));
          var value = currentHeight * minRatio;
          return {
            value: value,
            point: point
          };
        }

        return {
          value: point,
          point: point
        };
      });
      points.sort(function (a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
      });

      for (var i = 0; i < points.length; i += 1) {
        var _points$i = points[i],
            point = _points$i.point,
            value = _points$i.value;

        if (base === 'window') {
          if (window.matchMedia("(min-width: " + value + "px)").matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint: setBreakpoint,
      getBreakpoint: getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      var resultClasses = [];
      entries.forEach(function (item) {
        if (typeof item === 'object') {
          Object.keys(item).forEach(function (classNames) {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      var swiper = this;
      var classNames = swiper.classNames,
          params = swiper.params,
          rtl = swiper.rtl,
          $el = swiper.$el,
          device = swiper.device,
          support = swiper.support; // prettier-ignore

      var suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': support.pointerEvents && !support.touch
      }, {
        'free-mode': params.freeMode
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'multirow': params.slidesPerColumn > 1
      }, {
        'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }], params.containerModifierClass);
      classNames.push.apply(classNames, suffixes);
      $el.addClass([].concat(classNames).join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      var swiper = this;
      var $el = swiper.$el,
          classNames = swiper.classNames;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses: addClasses,
      removeClasses: removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      var window = getWindow();
      var image;

      function onReady() {
        if (callback) callback();
      }

      var isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      var swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
        var imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage: loadImage,
      preloadImages: preloadImages
    };

    function checkOverflow() {
      var swiper = this;
      var params = swiper.params;
      var wasLocked = swiper.isLocked;
      var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

      if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      swiper.allowSlideNext = !swiper.isLocked;
      swiper.allowSlidePrev = !swiper.isLocked; // events

      if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        if (swiper.navigation) swiper.navigation.update();
      }
    }

    var checkOverflow$1 = {
      checkOverflow: checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'container',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: false,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Free mode
      freeMode: false,
      freeModeMomentum: true,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: true,
      freeModeMomentumBounceRatio: 1,
      freeModeMomentumVelocityRatio: 1,
      freeModeSticky: false,
      freeModeMinimumVelocity: 0.02,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: 'column',
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: false,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      watchSlidesVisibility: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-container-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var prototypes = {
      modular: modular,
      eventsEmitter: eventsEmitter,
      update: update,
      translate: translate,
      transition: transition,
      slide: slide,
      loop: loop,
      grabCursor: grabCursor,
      manipulation: manipulation,
      events: events,
      breakpoints: breakpoints,
      checkOverflow: checkOverflow$1,
      classes: classes,
      images: images
    };
    var extendedDefaults = {};

    var Swiper$3 = /*#__PURE__*/function () {
      function Swiper() {
        var el;
        var params;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          el = args[0];
          params = args[1];
        }

        if (!params) params = {};
        params = extend$1({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $(params.el).length > 1) {
          var swipers = [];
          $(params.el).each(function (containerEl) {
            var newParams = extend$1({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];

        if (typeof swiper.modules === 'undefined') {
          swiper.modules = {};
        }

        Object.keys(swiper.modules).forEach(function (moduleName) {
          var module = swiper.modules[moduleName];

          if (module.params) {
            var moduleParamName = Object.keys(module.params)[0];
            var moduleParams = module.params[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) return;

            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
              params[moduleParamName] = {
                auto: true
              };
            }

            if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

            if (params[moduleParamName] === true) {
              params[moduleParamName] = {
                enabled: true
              };
            }

            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
              params[moduleParamName].enabled = true;
            }

            if (!params[moduleParamName]) params[moduleParamName] = {
              enabled: false
            };
          }
        }); // Extend defaults with modules params

        var swiperParams = extend$1({}, defaults);
        swiper.useParams(swiperParams); // Extend defaults with passed params

        swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend$1({}, swiper.params);
        swiper.passedParams = extend$1({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(function (eventName) {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $; // Extend Swiper

        extend$1(swiper, {
          enabled: swiper.params.enabled,
          el: el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          // isDirection
          isHorizontal: function isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical: function isVertical() {
            return swiper.params.direction === 'vertical';
          },
          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            var desktop = ['mousedown', 'mousemove', 'mouseup'];

            if (swiper.support.pointerEvents) {
              desktop = ['pointerdown', 'pointermove', 'pointerup'];
            }

            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        }); // Install Modules

        swiper.useModules();
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      var _proto = Swiper.prototype;

      _proto.enable = function enable() {
        var swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      };

      _proto.disable = function disable() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      };

      _proto.setProgress = function setProgress(progress, speed) {
        var swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        var min = swiper.minTranslate();
        var max = swiper.maxTranslate();
        var current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      };

      _proto.emitContainerClasses = function emitContainerClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var classes = swiper.el.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', classes.join(' '));
      };

      _proto.getSlideClasses = function getSlideClasses(slideEl) {
        var swiper = this;
        return slideEl.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      };

      _proto.emitSlidesClasses = function emitSlidesClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var updates = [];
        swiper.slides.each(function (slideEl) {
          var classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl: slideEl,
            classNames: classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      };

      _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
        var swiper = this;
        var params = swiper.params,
            slides = swiper.slides,
            slidesGrid = swiper.slidesGrid,
            swiperSize = swiper.size,
            activeIndex = swiper.activeIndex;
        var spv = 1;

        if (params.centeredSlides) {
          var slideSize = slides[activeIndex].swiperSlideSize;
          var breakLoop;

          for (var i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
            if (slides[_i] && !breakLoop) {
              slideSize += slides[_i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
            if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
              spv += 1;
            }
          }
        }

        return spv;
      };

      _proto.update = function update() {
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var snapGrid = swiper.snapGrid,
            params = swiper.params; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        var translated;

        if (swiper.params.freeMode) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      };

      _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }

        var swiper = this;
        var currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(function (slideEl) {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      };

      _proto.mount = function mount(el) {
        var swiper = this;
        if (swiper.mounted) return true; // Find el

        var $el = $(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        var getWrapperSelector = function getWrapperSelector() {
          return "." + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
        };

        var getWrapper = function getWrapper() {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            var res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = function (options) {
              return $el.children(options);
            };

            return res;
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        var $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          var document = getDocument();
          var wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children("." + swiper.params.slideClass).each(function (slideEl) {
            $wrapperEl.append(slideEl);
          });
        }

        extend$1(swiper, {
          $el: $el,
          el: el,
          $wrapperEl: $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      };

      _proto.init = function init(el) {
        var swiper = this;
        if (swiper.initialized) return swiper;
        var mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      };

      _proto.destroy = function destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }

        if (cleanStyles === void 0) {
          cleanStyles = true;
        }

        var swiper = this;
        var params = swiper.params,
            $el = swiper.$el,
            $wrapperEl = swiper.$wrapperEl,
            slides = swiper.slides;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(function (eventName) {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      };

      Swiper.extendDefaults = function extendDefaults(newDefaults) {
        extend$1(extendedDefaults, newDefaults);
      };

      Swiper.installModule = function installModule(module) {
        if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
        var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
        Swiper.prototype.modules[name] = module;
      };

      Swiper.use = function use(module) {
        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Swiper.installModule(m);
          });
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      };

      _createClass(Swiper, null, [{
        key: "extendedDefaults",
        get: function get() {
          return extendedDefaults;
        }
      }, {
        key: "defaults",
        get: function get() {
          return defaults;
        }
      }]);

      return Swiper;
    }();

    Object.keys(prototypes).forEach(function (prototypeGroup) {
      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
        Swiper$3.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper$3.use([Resize, Observer$1]);
    var SwiperCore = Swiper$3;

    function _extends$1() {
      _extends$1 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends$1.apply(this, arguments);
    }
    var Navigation = {
      toggleEl: function toggleEl($el, disabled) {
        $el[disabled ? 'addClass' : 'removeClass'](this.params.navigation.disabledClass);
        if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
      },
      update: function update() {
        // Update Navigation Buttons
        var swiper = this;
        var params = swiper.params.navigation;
        var toggleEl = swiper.navigation.toggleEl;
        if (swiper.params.loop) return;
        var _swiper$navigation = swiper.navigation,
            $nextEl = _swiper$navigation.$nextEl,
            $prevEl = _swiper$navigation.$prevEl;

        if ($prevEl && $prevEl.length > 0) {
          if (swiper.isBeginning) {
            toggleEl($prevEl, true);
          } else {
            toggleEl($prevEl, false);
          }

          if (swiper.params.watchOverflow && swiper.enabled) {
            $prevEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }

        if ($nextEl && $nextEl.length > 0) {
          if (swiper.isEnd) {
            toggleEl($nextEl, true);
          } else {
            toggleEl($nextEl, false);
          }

          if (swiper.params.watchOverflow && swiper.enabled) {
            $nextEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      },
      onPrevClick: function onPrevClick(e) {
        var swiper = this;
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
      },
      onNextClick: function onNextClick(e) {
        var swiper = this;
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
      },
      init: function init() {
        var swiper = this;
        var params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper.$el, swiper.params.navigation, swiper.params.createElements, {
          nextEl: 'swiper-button-next',
          prevEl: 'swiper-button-prev'
        });
        if (!(params.nextEl || params.prevEl)) return;
        var $nextEl;
        var $prevEl;

        if (params.nextEl) {
          $nextEl = $(params.nextEl);

          if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
            $nextEl = swiper.$el.find(params.nextEl);
          }
        }

        if (params.prevEl) {
          $prevEl = $(params.prevEl);

          if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
            $prevEl = swiper.$el.find(params.prevEl);
          }
        }

        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', swiper.navigation.onNextClick);
        }

        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', swiper.navigation.onPrevClick);
        }

        extend$1(swiper.navigation, {
          $nextEl: $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl: $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });

        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      },
      destroy: function destroy() {
        var swiper = this;
        var _swiper$navigation2 = swiper.navigation,
            $nextEl = _swiper$navigation2.$nextEl,
            $prevEl = _swiper$navigation2.$prevEl;

        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', swiper.navigation.onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }

        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', swiper.navigation.onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }
    };
    var Navigation$1 = {
      name: 'navigation',
      params: {
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock'
        }
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          navigation: _extends$1({}, Navigation)
        });
      },
      on: {
        init: function init(swiper) {
          swiper.navigation.init();
          swiper.navigation.update();
        },
        toEdge: function toEdge(swiper) {
          swiper.navigation.update();
        },
        fromEdge: function fromEdge(swiper) {
          swiper.navigation.update();
        },
        destroy: function destroy(swiper) {
          swiper.navigation.destroy();
        },
        'enable disable': function enableDisable(swiper) {
          var _swiper$navigation3 = swiper.navigation,
              $nextEl = _swiper$navigation3.$nextEl,
              $prevEl = _swiper$navigation3.$prevEl;

          if ($nextEl) {
            $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
          }

          if ($prevEl) {
            $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
          }
        },
        click: function click(swiper, e) {
          var _swiper$navigation4 = swiper.navigation,
              $nextEl = _swiper$navigation4.$nextEl,
              $prevEl = _swiper$navigation4.$prevEl;
          var targetEl = e.target;

          if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
            if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
            var isHidden;

            if ($nextEl) {
              isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
            } else if ($prevEl) {
              isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
            }

            if (isHidden === true) {
              swiper.emit('navigationShow');
            } else {
              swiper.emit('navigationHide');
            }

            if ($nextEl) {
              $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
            }

            if ($prevEl) {
              $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
            }
          }
        }
      }
    };

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }
    var Pagination = {
      update: function update() {
        // Render || Update Pagination bullets/items
        var swiper = this;
        var rtl = swiper.rtl;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el; // Current/Total

        var current;
        var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types


        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          var bullets = swiper.pagination.bullets;
          var firstIndex;
          var lastIndex;
          var midIndex;

          if (params.dynamicBullets) {
            swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

              if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (swiper.pagination.dynamicBulletIndex < 0) {
                swiper.pagination.dynamicBulletIndex = 0;
              }
            }

            firstIndex = current - swiper.pagination.dynamicBulletIndex;
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

          if ($el.length > 1) {
            bullets.each(function (bullet) {
              var $bullet = $(bullet);
              var bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(params.bulletActiveClass + "-main");
                }

                if (bulletIndex === firstIndex) {
                  $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                }

                if (bulletIndex === lastIndex) {
                  $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                }
              }
            });
          } else {
            var $bullet = bullets.eq(current);
            var bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              var $firstDisplayedBullet = bullets.eq(firstIndex);
              var $lastDisplayedBullet = bullets.eq(lastIndex);

              for (var i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(params.bulletActiveClass + "-main");
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                  for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                    bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
                } else {
                  $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                  $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                }
              } else {
                $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            }
          }

          if (params.dynamicBullets) {
            var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
            var offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          var progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          var scale = (current + 1) / total;
          var scaleX = 1;
          var scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          swiper.emit('paginationRender', $el[0]);
        } else {
          swiper.emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      },
      render: function render() {
        // Render Container
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var paginationHTML = '';

        if (params.type === 'bullets') {
          var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (var i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + ("<span class=\"" + params.totalClass + "\"></span>");
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          swiper.emit('paginationRender', swiper.pagination.$el[0]);
        }
      },
      init: function init() {
        var swiper = this;
        swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
          el: 'swiper-pagination'
        });
        var params = swiper.params.pagination;
        if (!params.el) return;
        var $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el);
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass("" + params.modifierClass + params.type + "-dynamic");
          swiper.pagination.dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            var index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        extend$1(swiper.pagination, {
          $el: $el,
          el: $el[0]
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      },
      destroy: function destroy() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }
    };
    var Pagination$1 = {
      name: 'pagination',
      params: {
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: function formatFractionCurrent(number) {
            return number;
          },
          formatFractionTotal: function formatFractionTotal(number) {
            return number;
          },
          bulletClass: 'swiper-pagination-bullet',
          bulletActiveClass: 'swiper-pagination-bullet-active',
          modifierClass: 'swiper-pagination-',
          // NEW
          currentClass: 'swiper-pagination-current',
          totalClass: 'swiper-pagination-total',
          hiddenClass: 'swiper-pagination-hidden',
          progressbarFillClass: 'swiper-pagination-progressbar-fill',
          progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
          clickableClass: 'swiper-pagination-clickable',
          // NEW
          lockClass: 'swiper-pagination-lock'
        }
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          pagination: _extends({
            dynamicBulletIndex: 0
          }, Pagination)
        });
      },
      on: {
        init: function init(swiper) {
          swiper.pagination.init();
          swiper.pagination.render();
          swiper.pagination.update();
        },
        activeIndexChange: function activeIndexChange(swiper) {
          if (swiper.params.loop) {
            swiper.pagination.update();
          } else if (typeof swiper.snapIndex === 'undefined') {
            swiper.pagination.update();
          }
        },
        snapIndexChange: function snapIndexChange(swiper) {
          if (!swiper.params.loop) {
            swiper.pagination.update();
          }
        },
        slidesLengthChange: function slidesLengthChange(swiper) {
          if (swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        snapGridLengthChange: function snapGridLengthChange(swiper) {
          if (!swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        destroy: function destroy(swiper) {
          swiper.pagination.destroy();
        },
        'enable disable': function enableDisable(swiper) {
          var $el = swiper.pagination.$el;

          if ($el) {
            $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
          }
        },
        click: function click(swiper, e) {
          var targetEl = e.target;

          if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
            if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
            var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

            if (isHidden === true) {
              swiper.emit('paginationShow');
            } else {
              swiper.emit('paginationHide');
            }

            swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
          }
        }
      }
    };

    function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function extend(target, src) {
      var noExtend = ['__proto__', 'constructor', 'prototype'];
      Object.keys(src).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      }).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
          if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
        } else {
          target[key] = src[key];
        }
      });
    }

    function needsNavigation(params) {
      if (params === void 0) {
        params = {};
      }

      return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
    }

    function needsPagination(params) {
      if (params === void 0) {
        params = {};
      }

      return params.pagination && typeof params.pagination.el === 'undefined';
    }

    function needsScrollbar(params) {
      if (params === void 0) {
        params = {};
      }

      return params.scrollbar && typeof params.scrollbar.el === 'undefined';
    }

    function uniqueClasses(classNames) {
      if (classNames === void 0) {
        classNames = '';
      }

      var classes = classNames.split(' ').map(function (c) {
        return c.trim();
      }).filter(function (c) {
        return !!c;
      });
      var unique = [];
      classes.forEach(function (c) {
        if (unique.indexOf(c) < 0) unique.push(c);
      });
      return unique.join(' ');
    }

    /* underscore in name -> watch for changes */
    var paramsList = ['init', '_direction', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_freeModeMomentum', '_freeModeMomentumRatio', '_freeModeMomentumBounce', '_freeModeMomentumBounceRatio', '_freeModeMomentumVelocityRatio', '_freeModeSticky', '_freeModeMinimumVelocity', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', '_spaceBetween', '_slidesPerView', '_slidesPerColumn', '_slidesPerColumnFill', '_slidesPerGroup', '_slidesPerGroupSkip', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_watchSlidesVisibility', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_preloadImages', 'updateOnImagesReady', '_loop', '_loopAdditionalSlides', '_loopedSlides', '_loopFillGroupWithBlank', 'loopPreventsSlide', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideBlankClass', 'slideActiveClass', 'slideDuplicateActiveClass', 'slideVisibleClass', 'slideDuplicateClass', 'slideNextClass', 'slideDuplicateNextClass', 'slidePrevClass', 'slideDuplicatePrevClass', 'wrapperClass', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren', // modules
    'a11y', 'autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'hashNavigation', 'history', 'keyboard', 'lazy', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', '_virtual', 'zoom'];

    // eslint-disable-next-line

    function getParams(obj) {
      if (obj === void 0) {
        obj = {};
      }

      var params = {
        on: {}
      };
      var passedParams = {};
      extend(params, SwiperCore.defaults);
      extend(params, SwiperCore.extendedDefaults);
      params._emitClasses = true;
      params.init = false;
      var rest = {};
      var allowedParams = paramsList.map(function (key) {
        return key.replace(/_/, '');
      });
      Object.keys(obj).forEach(function (key) {
        if (allowedParams.indexOf(key) >= 0) {
          if (isObject(obj[key])) {
            params[key] = {};
            passedParams[key] = {};
            extend(params[key], obj[key]);
            extend(passedParams[key], obj[key]);
          } else {
            params[key] = obj[key];
            passedParams[key] = obj[key];
          }
        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
          params.on["" + key[2].toLowerCase() + key.substr(3)] = obj[key];
        } else {
          rest[key] = obj[key];
        }
      });
      ['navigation', 'pagination', 'scrollbar'].forEach(function (key) {
        if (params[key] === true) params[key] = {};
        if (params[key] === false) delete params[key];
      });
      return {
        params: params,
        passedParams: passedParams,
        rest: rest
      };
    }

    // eslint-disable-next-line

    function initSwiper(swiperParams, modules) {
      if (modules) SwiperCore.use(modules);
      return new SwiperCore(swiperParams);
    }

    function mountSwiper(_ref, swiperParams) {
      var el = _ref.el,
          nextEl = _ref.nextEl,
          prevEl = _ref.prevEl,
          paginationEl = _ref.paginationEl,
          scrollbarEl = _ref.scrollbarEl,
          swiper = _ref.swiper;

      if (needsNavigation(swiperParams) && nextEl && prevEl) {
        swiper.params.navigation.nextEl = nextEl;
        swiper.originalParams.navigation.nextEl = nextEl;
        swiper.params.navigation.prevEl = prevEl;
        swiper.originalParams.navigation.prevEl = prevEl;
      }

      if (needsPagination(swiperParams) && paginationEl) {
        swiper.params.pagination.el = paginationEl;
        swiper.originalParams.pagination.el = paginationEl;
      }

      if (needsScrollbar(swiperParams) && scrollbarEl) {
        swiper.params.scrollbar.el = scrollbarEl;
        swiper.originalParams.scrollbar.el = scrollbarEl;
      }

      swiper.init(el);
    }

    function getChangedParams(swiperParams, oldParams) {
      var keys = [];
      if (!oldParams) return keys;

      var addKey = function addKey(key) {
        if (keys.indexOf(key) < 0) keys.push(key);
      };

      var watchParams = paramsList.filter(function (key) {
        return key[0] === '_';
      }).map(function (key) {
        return key.replace(/_/, '');
      });
      watchParams.forEach(function (key) {
        if (key in swiperParams && key in oldParams) {
          if (isObject(swiperParams[key]) && isObject(oldParams[key])) {
            var newKeys = Object.keys(swiperParams[key]);
            var oldKeys = Object.keys(oldParams[key]);

            if (newKeys.length !== oldKeys.length) {
              addKey(key);
            } else {
              newKeys.forEach(function (newKey) {
                if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
                  addKey(key);
                }
              });
              oldKeys.forEach(function (oldKey) {
                if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
              });
            }
          } else if (swiperParams[key] !== oldParams[key]) {
            addKey(key);
          }
        }
      });
      return keys;
    }

    function updateSwiper(_ref) {
      var swiper = _ref.swiper,
          passedParams = _ref.passedParams,
          changedParams = _ref.changedParams,
          nextEl = _ref.nextEl,
          prevEl = _ref.prevEl,
          scrollbarEl = _ref.scrollbarEl,
          paginationEl = _ref.paginationEl;
      var updateParams = changedParams.filter(function (key) {
        return key !== 'children' && key !== 'direction';
      });
      var currentParams = swiper.params,
          pagination = swiper.pagination,
          navigation = swiper.navigation,
          scrollbar = swiper.scrollbar,
          thumbs = swiper.thumbs;
      var needThumbsInit;
      var needControllerInit;
      var needPaginationInit;
      var needScrollbarInit;
      var needNavigationInit;

      if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
        needThumbsInit = true;
      }

      if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
        needControllerInit = true;
      }

      if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
        needPaginationInit = true;
      }

      if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
        needScrollbarInit = true;
      }

      if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
        needNavigationInit = true;
      }

      if (changedParams.includes('virtual')) {
        if (passedParams.virtual && passedParams.virtual.slides && swiper.virtual) {
          swiper.virtual.slides = passedParams.virtual.slides;
          swiper.virtual.update();
        }
      }

      var destroyModule = function destroyModule(mod) {
        if (!swiper[mod]) return;
        swiper[mod].destroy();

        if (mod === 'navigation') {
          currentParams[mod].prevEl = undefined;
          currentParams[mod].nextEl = undefined;
          swiper[mod].prevEl = undefined;
          swiper[mod].nextEl = undefined;
        } else {
          currentParams[mod].el = undefined;
          swiper[mod].el = undefined;
        }
      };

      updateParams.forEach(function (key) {
        if (isObject(currentParams[key]) && isObject(passedParams[key])) {
          extend(currentParams[key], passedParams[key]);
        } else {
          var newValue = passedParams[key];

          if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
            if (newValue === false) {
              destroyModule(key);
            }
          } else {
            currentParams[key] = passedParams[key];
          }
        }
      });

      if (needThumbsInit) {
        var initialized = thumbs.init();

        if (initialized) {
          thumbs.update(true);
        }
      }

      if (needControllerInit) {
        swiper.controller.control = currentParams.controller.control;
      }

      if (needPaginationInit) {
        if (paginationEl) currentParams.pagination.el = paginationEl;
        pagination.init();
        pagination.render();
        pagination.update();
      }

      if (needScrollbarInit) {
        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
        scrollbar.init();
        scrollbar.updateSize();
        scrollbar.setTranslate();
      }

      if (needNavigationInit) {
        if (nextEl) currentParams.navigation.nextEl = nextEl;
        if (prevEl) currentParams.navigation.prevEl = prevEl;
        navigation.init();
        navigation.update();
      }

      if (changedParams.includes('allowSlideNext')) {
        swiper.allowSlideNext = passedParams.allowSlideNext;
      }

      if (changedParams.includes('allowSlidePrev')) {
        swiper.allowSlidePrev = passedParams.allowSlidePrev;
      }

      if (changedParams.includes('direction')) {
        swiper.changeDirection(passedParams.direction, false);
      }

      swiper.update();
    }

    /* swiper.svelte generated by Svelte v3.38.2 */

    const get_container_end_slot_changes = dirty => ({
      virtualData: dirty &
      /*virtualData*/
      512
    });

    const get_container_end_slot_context = ctx => ({
      virtualData:
      /*virtualData*/
      ctx[9]
    });

    const get_wrapper_end_slot_changes = dirty => ({
      virtualData: dirty &
      /*virtualData*/
      512
    });

    const get_wrapper_end_slot_context = ctx => ({
      virtualData:
      /*virtualData*/
      ctx[9]
    });

    const get_default_slot_changes$1 = dirty => ({
      virtualData: dirty &
      /*virtualData*/
      512
    });

    const get_default_slot_context$1 = ctx => ({
      virtualData:
      /*virtualData*/
      ctx[9]
    });

    const get_wrapper_start_slot_changes = dirty => ({
      virtualData: dirty &
      /*virtualData*/
      512
    });

    const get_wrapper_start_slot_context = ctx => ({
      virtualData:
      /*virtualData*/
      ctx[9]
    });

    const get_container_start_slot_changes = dirty => ({
      virtualData: dirty &
      /*virtualData*/
      512
    });

    const get_container_start_slot_context = ctx => ({
      virtualData:
      /*virtualData*/
      ctx[9]
    }); // (156:2) {#if needsNavigation(swiperParams)}


    function create_if_block_2$7(ctx) {
      let div0;
      let t;
      let div1;
      return {
        c() {
          div0 = element("div");
          t = space();
          div1 = element("div");
          attr$1(div0, "class", "swiper-button-prev");
          attr$1(div1, "class", "swiper-button-next");
        },

        m(target, anchor) {
          insert(target, div0, anchor);
          /*div0_binding*/

          ctx[14](div0);
          insert(target, t, anchor);
          insert(target, div1, anchor);
          /*div1_binding*/

          ctx[15](div1);
        },

        p: noop,

        d(detaching) {
          if (detaching) detach(div0);
          /*div0_binding*/

          ctx[14](null);
          if (detaching) detach(t);
          if (detaching) detach(div1);
          /*div1_binding*/

          ctx[15](null);
        }

      };
    } // (160:2) {#if needsScrollbar(swiperParams)}


    function create_if_block_1$b(ctx) {
      let div;
      return {
        c() {
          div = element("div");
          attr$1(div, "class", "swiper-scrollbar");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          /*div_binding*/

          ctx[16](div);
        },

        p: noop,

        d(detaching) {
          if (detaching) detach(div);
          /*div_binding*/

          ctx[16](null);
        }

      };
    } // (163:2) {#if needsPagination(swiperParams)}


    function create_if_block$k(ctx) {
      let div;
      return {
        c() {
          div = element("div");
          attr$1(div, "class", "swiper-pagination");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          /*div_binding_1*/

          ctx[17](div);
        },

        p: noop,

        d(detaching) {
          if (detaching) detach(div);
          /*div_binding_1*/

          ctx[17](null);
        }

      };
    }

    function create_fragment$B(ctx) {
      let div1;
      let t0;
      let show_if_2 = needsNavigation(
      /*swiperParams*/
      ctx[2]);
      let t1;
      let show_if_1 = needsScrollbar(
      /*swiperParams*/
      ctx[2]);
      let t2;
      let show_if = needsPagination(
      /*swiperParams*/
      ctx[2]);
      let t3;
      let div0;
      let t4;
      let t5;
      let t6;
      let div1_class_value;
      let current;
      const container_start_slot_template =
      /*#slots*/
      ctx[13]["container-start"];
      const container_start_slot = create_slot(container_start_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_container_start_slot_context);
      let if_block0 = show_if_2 && create_if_block_2$7(ctx);
      let if_block1 = show_if_1 && create_if_block_1$b(ctx);
      let if_block2 = show_if && create_if_block$k(ctx);
      const wrapper_start_slot_template =
      /*#slots*/
      ctx[13]["wrapper-start"];
      const wrapper_start_slot = create_slot(wrapper_start_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_wrapper_start_slot_context);
      const default_slot_template =
      /*#slots*/
      ctx[13].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_default_slot_context$1);
      const wrapper_end_slot_template =
      /*#slots*/
      ctx[13]["wrapper-end"];
      const wrapper_end_slot = create_slot(wrapper_end_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_wrapper_end_slot_context);
      const container_end_slot_template =
      /*#slots*/
      ctx[13]["container-end"];
      const container_end_slot = create_slot(container_end_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_container_end_slot_context);
      let div1_levels = [{
        class: div1_class_value = uniqueClasses(`${
    /*containerClasses*/
    ctx[1]}${
    /*className*/
    ctx[0] ? ` ${
    /*className*/
    ctx[0]}` : ""}`)
      },
      /*restProps*/
      ctx[3]];
      let div1_data = {};

      for (let i = 0; i < div1_levels.length; i += 1) {
        div1_data = assign(div1_data, div1_levels[i]);
      }

      return {
        c() {
          div1 = element("div");
          if (container_start_slot) container_start_slot.c();
          t0 = space();
          if (if_block0) if_block0.c();
          t1 = space();
          if (if_block1) if_block1.c();
          t2 = space();
          if (if_block2) if_block2.c();
          t3 = space();
          div0 = element("div");
          if (wrapper_start_slot) wrapper_start_slot.c();
          t4 = space();
          if (default_slot) default_slot.c();
          t5 = space();
          if (wrapper_end_slot) wrapper_end_slot.c();
          t6 = space();
          if (container_end_slot) container_end_slot.c();
          attr$1(div0, "class", "swiper-wrapper");
          set_attributes(div1, div1_data);
        },

        m(target, anchor) {
          insert(target, div1, anchor);

          if (container_start_slot) {
            container_start_slot.m(div1, null);
          }

          append$1(div1, t0);
          if (if_block0) if_block0.m(div1, null);
          append$1(div1, t1);
          if (if_block1) if_block1.m(div1, null);
          append$1(div1, t2);
          if (if_block2) if_block2.m(div1, null);
          append$1(div1, t3);
          append$1(div1, div0);

          if (wrapper_start_slot) {
            wrapper_start_slot.m(div0, null);
          }

          append$1(div0, t4);

          if (default_slot) {
            default_slot.m(div0, null);
          }

          append$1(div0, t5);

          if (wrapper_end_slot) {
            wrapper_end_slot.m(div0, null);
          }

          append$1(div1, t6);

          if (container_end_slot) {
            container_end_slot.m(div1, null);
          }
          /*div1_binding_1*/


          ctx[18](div1);
          current = true;
        },

        p(ctx, [dirty]) {
          if (container_start_slot) {
            if (container_start_slot.p && (!current || dirty &
            /*$$scope, virtualData*/
            4608)) {
              update_slot(container_start_slot, container_start_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_container_start_slot_changes, get_container_start_slot_context);
            }
          }

          if (dirty &
          /*swiperParams*/
          4) show_if_2 = needsNavigation(
          /*swiperParams*/
          ctx[2]);

          if (show_if_2) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_2$7(ctx);
              if_block0.c();
              if_block0.m(div1, t1);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (dirty &
          /*swiperParams*/
          4) show_if_1 = needsScrollbar(
          /*swiperParams*/
          ctx[2]);

          if (show_if_1) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_1$b(ctx);
              if_block1.c();
              if_block1.m(div1, t2);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (dirty &
          /*swiperParams*/
          4) show_if = needsPagination(
          /*swiperParams*/
          ctx[2]);

          if (show_if) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
            } else {
              if_block2 = create_if_block$k(ctx);
              if_block2.c();
              if_block2.m(div1, t3);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }

          if (wrapper_start_slot) {
            if (wrapper_start_slot.p && (!current || dirty &
            /*$$scope, virtualData*/
            4608)) {
              update_slot(wrapper_start_slot, wrapper_start_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_wrapper_start_slot_changes, get_wrapper_start_slot_context);
            }
          }

          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope, virtualData*/
            4608)) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_default_slot_changes$1, get_default_slot_context$1);
            }
          }

          if (wrapper_end_slot) {
            if (wrapper_end_slot.p && (!current || dirty &
            /*$$scope, virtualData*/
            4608)) {
              update_slot(wrapper_end_slot, wrapper_end_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_wrapper_end_slot_changes, get_wrapper_end_slot_context);
            }
          }

          if (container_end_slot) {
            if (container_end_slot.p && (!current || dirty &
            /*$$scope, virtualData*/
            4608)) {
              update_slot(container_end_slot, container_end_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_container_end_slot_changes, get_container_end_slot_context);
            }
          }

          set_attributes(div1, div1_data = get_spread_update(div1_levels, [(!current || dirty &
          /*containerClasses, className*/
          3 && div1_class_value !== (div1_class_value = uniqueClasses(`${
      /*containerClasses*/
      ctx[1]}${
      /*className*/
      ctx[0] ? ` ${
      /*className*/
      ctx[0]}` : ""}`))) && {
            class: div1_class_value
          }, dirty &
          /*restProps*/
          8 &&
          /*restProps*/
          ctx[3]]));
        },

        i(local) {
          if (current) return;
          transition_in(container_start_slot, local);
          transition_in(wrapper_start_slot, local);
          transition_in(default_slot, local);
          transition_in(wrapper_end_slot, local);
          transition_in(container_end_slot, local);
          current = true;
        },

        o(local) {
          transition_out(container_start_slot, local);
          transition_out(wrapper_start_slot, local);
          transition_out(default_slot, local);
          transition_out(wrapper_end_slot, local);
          transition_out(container_end_slot, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div1);
          if (container_start_slot) container_start_slot.d(detaching);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (wrapper_start_slot) wrapper_start_slot.d(detaching);
          if (default_slot) default_slot.d(detaching);
          if (wrapper_end_slot) wrapper_end_slot.d(detaching);
          if (container_end_slot) container_end_slot.d(detaching);
          /*div1_binding_1*/

          ctx[18](null);
        }

      };
    }

    function instance$B($$self, $$props, $$invalidate) {
      const omit_props_names = ["class", "modules", "swiper"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      const dispatch = createEventDispatcher();
      let {
        class: className = undefined
      } = $$props;
      let {
        modules = null
      } = $$props;
      let containerClasses = "swiper-container";
      let breakpointChanged = false;
      let swiperInstance = null;
      let oldPassedParams = null;
      let paramsData;
      let swiperParams;
      let passedParams;
      let restProps;
      let swiperEl = null;
      let prevEl = null;
      let nextEl = null;
      let scrollbarEl = null;
      let paginationEl = null;
      let virtualData = {
        slides: []
      };

      function swiper() {
        return swiperInstance;
      }

      const setVirtualData = data => {
        $$invalidate(9, virtualData = data);
        tick().then(() => {
          swiperInstance.$wrapperEl.children(".swiper-slide").each(el => {
            if (el.onSwiper) el.onSwiper(swiperInstance);
          });
          swiperInstance.updateSlides();
          swiperInstance.updateProgress();
          swiperInstance.updateSlidesClasses();

          if (swiperInstance.lazy && swiperInstance.params.lazy.enabled) {
            swiperInstance.lazy.load();
          }
        });
      };

      const calcParams = () => {
        paramsData = getParams($$restProps);
        $$invalidate(2, swiperParams = paramsData.params);
        passedParams = paramsData.passedParams;
        $$invalidate(3, restProps = paramsData.rest);
      };

      calcParams();
      oldPassedParams = passedParams;

      const onBeforeBreakpoint = () => {
        breakpointChanged = true;
      };

      swiperParams.onAny = (event, ...args) => {
        dispatch(event, [args]);
      };

      Object.assign(swiperParams.on, {
        _beforeBreakpoint: onBeforeBreakpoint,

        _containerClasses(_swiper, classes) {
          $$invalidate(1, containerClasses = classes);
        }

      });
      swiperInstance = initSwiper(swiperParams, modules);

      if (swiperInstance.virtual && swiperInstance.params.virtual.enabled) {
        const extendWith = {
          cache: false,
          renderExternal: data => {
            setVirtualData(data);

            if (swiperParams.virtual && swiperParams.virtual.renderExternal) {
              swiperParams.virtual.renderExternal(data);
            }
          },
          renderExternalUpdate: false
        };
        extend(swiperInstance.params.virtual, extendWith);
        extend(swiperInstance.originalParams.virtual, extendWith);
      }

      onMount(() => {
        if (!swiperEl) return;
        mountSwiper({
          el: swiperEl,
          nextEl,
          prevEl,
          paginationEl,
          scrollbarEl,
          swiper: swiperInstance
        }, swiperParams);
        dispatch("swiper", [swiperInstance]);
        if (swiperParams.virtual) return;
        swiperInstance.slides.each(el => {
          if (el.onSwiper) el.onSwiper(swiperInstance);
        });
      });
      afterUpdate(() => {
        if (!swiperInstance) return;
        calcParams();
        const changedParams = getChangedParams(passedParams, oldPassedParams);

        if ((changedParams.length || breakpointChanged) && swiperInstance && !swiperInstance.destroyed) {
          updateSwiper({
            swiper: swiperInstance,
            passedParams,
            changedParams,
            nextEl,
            prevEl,
            scrollbarEl,
            paginationEl
          });
        }

        breakpointChanged = false;
        oldPassedParams = passedParams;
      });
      onDestroy(() => {
        if (typeof window !== "undefined" && swiperInstance && !swiperInstance.destroyed) {
          swiperInstance.destroy(true, false);
        }
      });

      function div0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          prevEl = $$value;
          $$invalidate(5, prevEl);
        });
      }

      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          nextEl = $$value;
          $$invalidate(6, nextEl);
        });
      }

      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          scrollbarEl = $$value;
          $$invalidate(7, scrollbarEl);
        });
      }

      function div_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          paginationEl = $$value;
          $$invalidate(8, paginationEl);
        });
      }

      function div1_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          swiperEl = $$value;
          $$invalidate(4, swiperEl);
        });
      }

      $$self.$$set = $$new_props => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
        if ("modules" in $$new_props) $$invalidate(10, modules = $$new_props.modules);
        if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
      };

      return [className, containerClasses, swiperParams, restProps, swiperEl, prevEl, nextEl, scrollbarEl, paginationEl, virtualData, modules, swiper, $$scope, slots, div0_binding, div1_binding, div_binding, div_binding_1, div1_binding_1];
    }

    class Swiper$1 extends SvelteComponent {
      constructor(options) {
        super();
        init(this, options, instance$B, create_fragment$B, safe_not_equal, {
          class: 0,
          modules: 10,
          swiper: 11
        });
      }

      get swiper() {
        return this.$$.ctx[11];
      }

    }

    var Swiper$2 = Swiper$1;

    /* swiper.svelte generated by Svelte v3.38.2 */

    const get_default_slot_changes_1 = dirty => ({
      data: dirty &
      /*slideData*/
      32
    });

    const get_default_slot_context_1 = ctx => ({
      data:
      /*slideData*/
      ctx[5]
    });

    const get_default_slot_changes = dirty => ({
      data: dirty &
      /*slideData*/
      32
    });

    const get_default_slot_context = ctx => ({
      data:
      /*slideData*/
      ctx[5]
    }); // (92:2) {:else}


    function create_else_block$a(ctx) {
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[7], get_default_slot_context_1);
      return {
        c() {
          if (default_slot) default_slot.c();
        },

        m(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }

          current = true;
        },

        p(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope, slideData*/
            160)) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[7], dirty, get_default_slot_changes_1, get_default_slot_context_1);
            }
          }
        },

        i(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },

        o(local) {
          transition_out(default_slot, local);
          current = false;
        },

        d(detaching) {
          if (default_slot) default_slot.d(detaching);
        }

      };
    } // (85:2) {#if zoom}


    function create_if_block$j(ctx) {
      let div;
      let div_data_swiper_zoom_value;
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[7], get_default_slot_context);
      return {
        c() {
          div = element("div");
          if (default_slot) default_slot.c();
          attr$1(div, "class", "swiper-zoom-container");
          attr$1(div, "data-swiper-zoom", div_data_swiper_zoom_value = typeof
          /*zoom*/
          ctx[0] === "number" ?
          /*zoom*/
          ctx[0] : undefined);
        },

        m(target, anchor) {
          insert(target, div, anchor);

          if (default_slot) {
            default_slot.m(div, null);
          }

          current = true;
        },

        p(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope, slideData*/
            160)) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[7], dirty, get_default_slot_changes, get_default_slot_context);
            }
          }

          if (!current || dirty &
          /*zoom*/
          1 && div_data_swiper_zoom_value !== (div_data_swiper_zoom_value = typeof
          /*zoom*/
          ctx[0] === "number" ?
          /*zoom*/
          ctx[0] : undefined)) {
            attr$1(div, "data-swiper-zoom", div_data_swiper_zoom_value);
          }
        },

        i(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },

        o(local) {
          transition_out(default_slot, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if (default_slot) default_slot.d(detaching);
        }

      };
    }

    function create_fragment$A(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let div_class_value;
      let current;
      const if_block_creators = [create_if_block$j, create_else_block$a];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*zoom*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let div_levels = [{
        class: div_class_value = uniqueClasses(`${
    /*slideClasses*/
    ctx[3]}${
    /*className*/
    ctx[2] ? ` ${
    /*className*/
    ctx[2]}` : ""}`)
      }, {
        "data-swiper-slide-index":
        /*virtualIndex*/
        ctx[1]
      },
      /*$$restProps*/
      ctx[6]];
      let div_data = {};

      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }

      return {
        c() {
          div = element("div");
          if_block.c();
          set_attributes(div, div_data);
        },

        m(target, anchor) {
          insert(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          /*div_binding*/

          ctx[9](div);
          current = true;
        },

        p(ctx, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(div, null);
          }

          set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty &
          /*slideClasses, className*/
          12 && div_class_value !== (div_class_value = uniqueClasses(`${
      /*slideClasses*/
      ctx[3]}${
      /*className*/
      ctx[2] ? ` ${
      /*className*/
      ctx[2]}` : ""}`))) && {
            class: div_class_value
          }, (!current || dirty &
          /*virtualIndex*/
          2) && {
            "data-swiper-slide-index":
            /*virtualIndex*/
            ctx[1]
          }, dirty &
          /*$$restProps*/
          64 &&
          /*$$restProps*/
          ctx[6]]));
        },

        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },

        o(local) {
          transition_out(if_block);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if_blocks[current_block_type_index].d();
          /*div_binding*/

          ctx[9](null);
        }

      };
    }

    function instance$A($$self, $$props, $$invalidate) {
      let slideData;
      const omit_props_names = ["zoom", "virtualIndex", "class"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      let {
        zoom = undefined
      } = $$props;
      let {
        virtualIndex = undefined
      } = $$props;
      let {
        class: className = undefined
      } = $$props;
      let slideEl = null;
      let slideClasses = "swiper-slide";
      let swiper = null;
      let eventAttached = false;

      const updateClasses = (_, el, classNames) => {
        if (el === slideEl) {
          $$invalidate(3, slideClasses = classNames);
        }
      };

      const attachEvent = () => {
        if (!swiper || eventAttached) return;
        swiper.on("_slideClass", updateClasses);
        eventAttached = true;
      };

      const detachEvent = () => {
        if (!swiper) return;
        swiper.off("_slideClass", updateClasses);
        eventAttached = false;
      };

      onMount(() => {
        if (typeof virtualIndex === "undefined") return;
        $$invalidate(4, slideEl.onSwiper = _swiper => {
          swiper = _swiper;
          attachEvent();
        }, slideEl);
        attachEvent();
      });
      afterUpdate(() => {
        if (!slideEl || !swiper) return;

        if (swiper.destroyed) {
          if (slideClasses !== "swiper-slide") {
            $$invalidate(3, slideClasses = "swiper-slide");
          }

          return;
        }

        attachEvent();
      });
      beforeUpdate(() => {
        attachEvent();
      });
      onDestroy(() => {
        if (!swiper) return;
        detachEvent();
      });

      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          slideEl = $$value;
          $$invalidate(4, slideEl);
        });
      }

      $$self.$$set = $$new_props => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("zoom" in $$new_props) $$invalidate(0, zoom = $$new_props.zoom);
        if ("virtualIndex" in $$new_props) $$invalidate(1, virtualIndex = $$new_props.virtualIndex);
        if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
        if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*slideClasses*/
        8) {
          $$invalidate(5, slideData = {
            isActive: slideClasses.indexOf("swiper-slide-active") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-active") >= 0,
            isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
            isDuplicate: slideClasses.indexOf("swiper-slide-duplicate") >= 0,
            isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-prev") >= 0,
            isNext: slideClasses.indexOf("swiper-slide-next") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-next") >= 0
          });
        }
      };

      return [zoom, virtualIndex, className, slideClasses, slideEl, slideData, $$restProps, $$scope, slots, div_binding];
    }

    class Swiper extends SvelteComponent {
      constructor(options) {
        super();
        init(this, options, instance$A, create_fragment$A, safe_not_equal, {
          zoom: 0,
          virtualIndex: 1,
          class: 2
        });
      }

    }

    var SwiperSlide = Swiper;

    var css_248z = "@font-face {\n  font-family: 'swiper-icons';\n  src: url(\"data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA\") format(\"woff\");\n  font-weight: 400;\n  font-style: normal; }\n\n:root {\n  --swiper-theme-color: #007aff; }\n\n.swiper-container {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n  /* Fix of Webkit flickering */\n  z-index: 1; }\n\n.swiper-container-vertical > .swiper-wrapper {\n  flex-direction: column; }\n\n.swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: flex;\n  transition-property: transform;\n  box-sizing: content-box; }\n\n.swiper-container-android .swiper-slide,\n.swiper-wrapper {\n  transform: translate3d(0px, 0, 0); }\n\n.swiper-container-multirow > .swiper-wrapper {\n  flex-wrap: wrap; }\n\n.swiper-container-multirow-column > .swiper-wrapper {\n  flex-wrap: wrap;\n  flex-direction: column; }\n\n.swiper-container-free-mode > .swiper-wrapper {\n  transition-timing-function: ease-out;\n  margin: 0 auto; }\n\n.swiper-container-pointer-events {\n  touch-action: pan-y; }\n  .swiper-container-pointer-events.swiper-container-vertical {\n    touch-action: pan-x; }\n\n.swiper-slide {\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition-property: transform; }\n\n.swiper-slide-invisible-blank {\n  visibility: hidden; }\n\n/* Auto Height */\n.swiper-container-autoheight,\n.swiper-container-autoheight .swiper-slide {\n  height: auto; }\n\n.swiper-container-autoheight .swiper-wrapper {\n  align-items: flex-start;\n  transition-property: transform, height; }\n\n/* 3D Effects */\n.swiper-container-3d {\n  perspective: 1200px; }\n  .swiper-container-3d .swiper-wrapper,\n  .swiper-container-3d .swiper-slide,\n  .swiper-container-3d .swiper-slide-shadow-left,\n  .swiper-container-3d .swiper-slide-shadow-right,\n  .swiper-container-3d .swiper-slide-shadow-top,\n  .swiper-container-3d .swiper-slide-shadow-bottom,\n  .swiper-container-3d .swiper-cube-shadow {\n    transform-style: preserve-3d; }\n  .swiper-container-3d .swiper-slide-shadow-left,\n  .swiper-container-3d .swiper-slide-shadow-right,\n  .swiper-container-3d .swiper-slide-shadow-top,\n  .swiper-container-3d .swiper-slide-shadow-bottom {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 10; }\n  .swiper-container-3d .swiper-slide-shadow-left {\n    background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)); }\n  .swiper-container-3d .swiper-slide-shadow-right {\n    background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)); }\n  .swiper-container-3d .swiper-slide-shadow-top {\n    background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)); }\n  .swiper-container-3d .swiper-slide-shadow-bottom {\n    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0)); }\n\n/* CSS Mode */\n.swiper-container-css-mode > .swiper-wrapper {\n  overflow: auto;\n  scrollbar-width: none;\n  /* For Firefox */\n  -ms-overflow-style: none;\n  /* For Internet Explorer and Edge */ }\n  .swiper-container-css-mode > .swiper-wrapper::-webkit-scrollbar {\n    display: none; }\n\n.swiper-container-css-mode > .swiper-wrapper > .swiper-slide {\n  scroll-snap-align: start start; }\n\n.swiper-container-horizontal.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: x mandatory; }\n\n.swiper-container-vertical.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: y mandatory; }\n";
    styleInject(css_248z);

    /* src/components/VideoSlider.svelte generated by Svelte v3.41.0 */

    // (10:0) <Swiper      slidesPerView={3.5}     pagination={{ clickable: true }}     navigation     scrollbar={{ draggable: true }}     breakpoints='{{         "320": {           "slidesPerView": 1,         },         "480": {           "slidesPerView": 1,         },         "640": {           "slidesPerView": 1.6,         },         "730": {           "slidesPerView": 1.8,         },         "768": {           "slidesPerView": 2,         },         "1024": {           "slidesPerView": 2.4,         },         "1025": {           "slidesPerView": 2,         },         "1200": {           "slidesPerView": 2.3,         },         "1280": {           "slidesPerView": 2.5,         },         "1380": {           "slidesPerView": 3,         }       }}'   >
    function create_default_slot$6(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[0].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(10:0) <Swiper      slidesPerView={3.5}     pagination={{ clickable: true }}     navigation     scrollbar={{ draggable: true }}     breakpoints='{{         \\\"320\\\": {           \\\"slidesPerView\\\": 1,         },         \\\"480\\\": {           \\\"slidesPerView\\\": 1,         },         \\\"640\\\": {           \\\"slidesPerView\\\": 1.6,         },         \\\"730\\\": {           \\\"slidesPerView\\\": 1.8,         },         \\\"768\\\": {           \\\"slidesPerView\\\": 2,         },         \\\"1024\\\": {           \\\"slidesPerView\\\": 2.4,         },         \\\"1025\\\": {           \\\"slidesPerView\\\": 2,         },         \\\"1200\\\": {           \\\"slidesPerView\\\": 2.3,         },         \\\"1280\\\": {           \\\"slidesPerView\\\": 2.5,         },         \\\"1380\\\": {           \\\"slidesPerView\\\": 3,         }       }}'   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let swiper;
    	let current;

    	swiper = new Swiper$2({
    			props: {
    				slidesPerView: 3.5,
    				pagination: { clickable: true },
    				navigation: true,
    				scrollbar: { draggable: true },
    				breakpoints: {
    					"320": { "slidesPerView": 1 },
    					"480": { "slidesPerView": 1 },
    					"640": { "slidesPerView": 1.6 },
    					"730": { "slidesPerView": 1.8 },
    					"768": { "slidesPerView": 2 },
    					"1024": { "slidesPerView": 2.4 },
    					"1025": { "slidesPerView": 2 },
    					"1200": { "slidesPerView": 2.3 },
    					"1280": { "slidesPerView": 2.5 },
    					"1380": { "slidesPerView": 3 }
    				},
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(swiper.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(swiper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const swiper_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				swiper_changes.$$scope = { dirty, ctx };
    			}

    			swiper.$set(swiper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(swiper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoSlider', slots, ['default']);
    	SwiperCore.use([Pagination$1, Navigation$1]);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoSlider> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Swiper: Swiper$2,
    		SwiperSlide,
    		SwiperCore,
    		Pagination: Pagination$1,
    		Navigation: Navigation$1
    	});

    	return [slots, $$scope];
    }

    class VideoSlider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoSlider",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src/pages/Videos.svelte generated by Svelte v3.41.0 */
    const file$w = "src/pages/Videos.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (1064:2) {#if videos.length}
    function create_if_block$i(ctx) {
    	let video;
    	let current;

    	video = new Video({
    			props: { video: /*videos*/ ctx[1][0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(video.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(video, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(video, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(1064:2) {#if videos.length}",
    		ctx
    	});

    	return block;
    }

    // (1080:16) <SwiperSlide>
    function create_default_slot_1$2(ctx) {
    	let video;
    	let t;
    	let current;

    	video = new Video({
    			props: {
    				video: /*video*/ ctx[3],
    				classes: "video-card"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(video.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(video, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(video, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(1080:16) <SwiperSlide>",
    		ctx
    	});

    	return block;
    }

    // (1079:16) {#each videos.slice(1, 7) as video}
    function create_each_block_1$6(ctx) {
    	let swiperslide;
    	let current;

    	swiperslide = new SwiperSlide({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(swiperslide.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(swiperslide, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const swiperslide_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				swiperslide_changes.$$scope = { dirty, ctx };
    			}

    			swiperslide.$set(swiperslide_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiperslide.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiperslide.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(swiperslide, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(1079:16) {#each videos.slice(1, 7) as video}",
    		ctx
    	});

    	return block;
    }

    // (1078:12) <VideoSlider>
    function create_default_slot$5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*videos*/ ctx[1].slice(1, 7);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*videos*/ 2) {
    				each_value_1 = /*videos*/ ctx[1].slice(1, 7);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(1078:12) <VideoSlider>",
    		ctx
    	});

    	return block;
    }

    // (1096:12) {#each !toggleFlag ? videos.slice(1, 5): videos.slice(1) as video}
    function create_each_block$9(ctx) {
    	let div;
    	let video;
    	let t;
    	let current;

    	video = new Video({
    			props: { video: /*video*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(video.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "col-lg-6 col-sm-6 col-xs-12 video-container");
    			add_location(div, file$w, 1096, 16, 40158);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(video, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const video_changes = {};
    			if (dirty & /*toggleFlag*/ 1) video_changes.video = /*video*/ ctx[3];
    			video.$set(video_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(video);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(1096:12) {#each !toggleFlag ? videos.slice(1, 5): videos.slice(1) as video}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div1;
    	let h1;
    	let t1;
    	let div0;
    	let t2;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let h40;
    	let t4;
    	let videoslider;
    	let t5;
    	let div11;
    	let div10;
    	let div8;
    	let div7;
    	let h41;
    	let t7;
    	let div9;
    	let t8;
    	let p;
    	let t9_value = (!/*toggleFlag*/ ctx[0] ? 'Load More' : 'Load Less') + "";
    	let t9;
    	let t10;
    	let insider;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*videos*/ ctx[1].length && create_if_block$i(ctx);

    	videoslider = new VideoSlider({
    			props: {
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = !/*toggleFlag*/ ctx[0]
    	? /*videos*/ ctx[1].slice(1, 5)
    	: /*videos*/ ctx[1].slice(1);

    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	insider = new Insider({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Videos";
    			t1 = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t2 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			h40 = element("h4");
    			h40.textContent = "Recent Streams";
    			t4 = space();
    			create_component(videoslider.$$.fragment);
    			t5 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			h41 = element("h4");
    			h41.textContent = "Other Videos on demand";
    			t7 = space();
    			div9 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			p = element("p");
    			t9 = text$1(t9_value);
    			t10 = space();
    			create_component(insider.$$.fragment);
    			attr_dev(h1, "class", "title svelte-17ye0v7");
    			add_location(h1, file$w, 1061, 1, 39036);
    			attr_dev(div0, "class", "video-page-main");
    			add_location(div0, file$w, 1062, 1, 39067);
    			attr_dev(div1, "class", "top-section videos-section-page");
    			add_location(div1, file$w, 1060, 0, 38989);
    			attr_dev(h40, "class", "videos-section-title recent-stream-title");
    			add_location(h40, file$w, 1074, 20, 39411);
    			attr_dev(div2, "class", "col-lg-12 col-sm-12 col-xs-12");
    			add_location(div2, file$w, 1073, 16, 39347);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$w, 1072, 12, 39313);
    			attr_dev(div4, "class", "col-md-8 col-xs-12 video-slide-container");
    			add_location(div4, file$w, 1071, 8, 39246);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$w, 1070, 4, 39220);
    			attr_dev(div6, "class", "container-fluid");
    			add_location(div6, file$w, 1069, 0, 39186);
    			attr_dev(h41, "class", "videos-section-title");
    			add_location(h41, file$w, 1091, 4, 39952);
    			attr_dev(div7, "class", "col-lg-12 col-sm-12 col-xs-12");
    			add_location(div7, file$w, 1090, 3, 39904);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$w, 1089, 2, 39883);
    			attr_dev(div9, "class", "row no-gutters");
    			add_location(div9, file$w, 1094, 2, 40034);
    			attr_dev(p, "class", "video-seemore");
    			add_location(p, file$w, 1101, 8, 40313);
    			attr_dev(div10, "class", "videos-section other-videos-demand svelte-17ye0v7");
    			add_location(div10, file$w, 1088, 1, 39832);
    			attr_dev(div11, "class", "container");
    			add_location(div11, file$w, 1087, 0, 39807);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, h40);
    			append_dev(div4, t4);
    			mount_component(videoslider, div4, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div10);
    			append_dev(div10, div8);
    			append_dev(div8, div7);
    			append_dev(div7, h41);
    			append_dev(div10, t7);
    			append_dev(div10, div9);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div9, null);
    			}

    			append_dev(div10, t8);
    			append_dev(div10, p);
    			append_dev(p, t9);
    			insert_dev(target, t10, anchor);
    			mount_component(insider, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(p, "click", prevent_default(/*click_handler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*videos*/ ctx[1].length) if_block.p(ctx, dirty);
    			const videoslider_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				videoslider_changes.$$scope = { dirty, ctx };
    			}

    			videoslider.$set(videoslider_changes);

    			if (dirty & /*toggleFlag, videos*/ 3) {
    				each_value = !/*toggleFlag*/ ctx[0]
    				? /*videos*/ ctx[1].slice(1, 5)
    				: /*videos*/ ctx[1].slice(1);

    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div9, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if ((!current || dirty & /*toggleFlag*/ 1) && t9_value !== (t9_value = (!/*toggleFlag*/ ctx[0] ? 'Load More' : 'Load Less') + "")) set_data_dev(t9, t9_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(videoslider.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(insider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(videoslider.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(insider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div6);
    			destroy_component(videoslider);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div11);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(insider, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Videos', slots, []);

    	let videos = [
    		{
    			"id": 89,
    			"status": "published",
    			"sort": 87,
    			"owner": 11,
    			"created_on": "2021-03-15T09:53:27.000Z",
    			"name": "[BENGALI] CONQUEST: FREE FIRE OPEN | GRAND FINALS | DAY 2",
    			"url": "https://youtu.be/e7XKdYyUmpY",
    			"thumbnail": 103,
    			"live": 0,
    			"filename_disk": "fe8e4ff0-dd4a-4660-9396-8cffe2d1bf95.jpg"
    		},
    		{
    			"id": 88,
    			"status": "published",
    			"sort": 86,
    			"owner": 11,
    			"created_on": "2021-03-15T09:52:56.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | GRAND FINALS | DAY 2",
    			"url": "https://youtu.be/a_YKaOqOP4o",
    			"thumbnail": 102,
    			"live": 0,
    			"filename_disk": "5c9a5556-a6ee-429b-b01e-768318d71ff4.jpg"
    		},
    		{
    			"id": 87,
    			"status": "published",
    			"sort": 85,
    			"owner": 11,
    			"created_on": "2021-03-15T09:52:16.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | GRAND FINALS | DAY 2",
    			"url": "https://youtu.be/TX5kwmWKK28",
    			"thumbnail": 101,
    			"live": 0,
    			"filename_disk": "4601151a-1a40-45a3-bd52-9c5c79bf49dd.jpg"
    		},
    		{
    			"id": 86,
    			"status": "published",
    			"sort": 84,
    			"owner": 11,
    			"created_on": "2021-03-15T09:51:26.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | GRAND FINALS | DAY 1",
    			"url": "https://youtu.be/7a-ScTb_VWQ",
    			"thumbnail": 100,
    			"live": 0,
    			"filename_disk": "d4e4ff96-a583-404f-9053-0d30e2ba3e2b.jpg"
    		},
    		{
    			"id": 85,
    			"status": "published",
    			"sort": 83,
    			"owner": 11,
    			"created_on": "2021-03-15T09:47:50.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | GRAND FINALS | DAY 1",
    			"url": "https://youtu.be/LIFSHOhGCtE",
    			"thumbnail": 99,
    			"live": 0,
    			"filename_disk": "bb29d51d-2601-4126-b197-344c0fc7dc1b.jpg"
    		},
    		{
    			"id": 84,
    			"status": "published",
    			"sort": 82,
    			"owner": 11,
    			"created_on": "2021-03-15T09:47:15.000Z",
    			"name": "[BENGALI] CONQUEST: FREE FIRE OPEN | GRAND FINALS | DAY 1",
    			"url": "https://youtu.be/lX1bBv3jL34",
    			"thumbnail": 98,
    			"live": 0,
    			"filename_disk": "29825f62-f3e5-4476-8c61-8a0b015eac90.jpg"
    		},
    		{
    			"id": 83,
    			"status": "published",
    			"sort": 81,
    			"owner": 11,
    			"created_on": "2021-03-15T09:46:29.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | PRE-FINALS | DAY 2",
    			"url": "https://youtu.be/8f8tTG7pj9o",
    			"thumbnail": 97,
    			"live": 0,
    			"filename_disk": "f21e61b8-28a4-4323-8674-9f0ba9d902cb.jpg"
    		},
    		{
    			"id": 82,
    			"status": "published",
    			"sort": 80,
    			"owner": 11,
    			"created_on": "2021-03-15T09:45:41.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | PRE-FINALS| DAY 1 | PART 2",
    			"url": "https://youtu.be/H-lltTkKkMk",
    			"thumbnail": 96,
    			"live": 0,
    			"filename_disk": "79bc73ca-0677-4f0e-bef8-7422e0a058ff.jpg"
    		},
    		{
    			"id": 81,
    			"status": "published",
    			"sort": 79,
    			"owner": 11,
    			"created_on": "2021-03-15T09:44:46.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | PRE-FINALS | DAY 1 | PART 1",
    			"url": "https://youtu.be/5U8Tej0qMm8",
    			"thumbnail": 95,
    			"live": 0,
    			"filename_disk": "e7f648c3-039e-4949-800f-0d46969bb55e.jpg"
    		},
    		{
    			"id": 80,
    			"status": "published",
    			"sort": 78,
    			"owner": 11,
    			"created_on": "2021-03-15T09:43:58.000Z",
    			"name": "CONQUEST: GAMING FTW | Episode 4 ft  Total Gaming  Esports | Viewer Games | Diamond Giveaways",
    			"url": "https://youtu.be/13EF-7VFGMk",
    			"thumbnail": 94,
    			"live": 0,
    			"filename_disk": "20792272-5628-45c4-9504-345042fd3949.jpg"
    		},
    		{
    			"id": 79,
    			"status": "published",
    			"sort": 77,
    			"owner": 11,
    			"created_on": "2021-03-15T09:43:09.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 4 - DAY 3",
    			"url": "https://youtu.be/KMuW6RSFDVA",
    			"thumbnail": 93,
    			"live": 0,
    			"filename_disk": "f0fdbae7-d43d-4721-8168-f6a3a1b23648.jpg"
    		},
    		{
    			"id": 78,
    			"status": "published",
    			"sort": 76,
    			"owner": 11,
    			"created_on": "2021-03-15T09:42:32.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 4 - DAY 3",
    			"url": "https://youtu.be/AXG7L0N5VME",
    			"thumbnail": 92,
    			"live": 0,
    			"filename_disk": "7584449b-f368-408e-90ed-e96d43daab6b.jpg"
    		},
    		{
    			"id": 77,
    			"status": "published",
    			"sort": 75,
    			"owner": 11,
    			"created_on": "2021-03-15T09:41:44.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 4 - DAY 2",
    			"url": "https://youtu.be/x0u7cyF1LjY",
    			"thumbnail": 91,
    			"live": 0,
    			"filename_disk": "9ba78043-a5d9-4cb8-8edd-1ff8ee26c6fc.jpg"
    		},
    		{
    			"id": 76,
    			"status": "published",
    			"sort": 74,
    			"owner": 11,
    			"created_on": "2021-03-15T09:41:05.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 4 - DAY 2",
    			"url": "https://youtu.be/wl-TGGEh6oE",
    			"thumbnail": 90,
    			"live": 0,
    			"filename_disk": "fbf3e905-048f-4496-b3ba-4dd053d2b1dc.jpg"
    		},
    		{
    			"id": 75,
    			"status": "published",
    			"sort": 73,
    			"owner": 11,
    			"created_on": "2021-03-15T09:39:51.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 4 - DAY 1",
    			"url": "https://youtu.be/-ScTXIV0rOU",
    			"thumbnail": 89,
    			"live": 0,
    			"filename_disk": "8af11ecf-9329-418d-82be-a0afae563426.jpg"
    		},
    		{
    			"id": 74,
    			"status": "published",
    			"sort": 72,
    			"owner": 11,
    			"created_on": "2021-03-15T09:39:12.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 4 - DAY 1",
    			"url": "https://youtu.be/VKRgfd94ha8",
    			"thumbnail": 88,
    			"live": 0,
    			"filename_disk": "997b3b34-107f-4cd7-b20c-b88082b738ff.jpg"
    		},
    		{
    			"id": 73,
    			"status": "published",
    			"sort": 71,
    			"owner": 11,
    			"created_on": "2021-03-15T09:38:26.000Z",
    			"name": "CONQUEST: GAMING FTW | Episode 3 ft  @FAB INDRO GAMING   | Viewer Games | Diamond Giveaways",
    			"url": "https://youtu.be/W2nVsVRVfvM",
    			"thumbnail": 87,
    			"live": 0,
    			"filename_disk": "0bda70dd-282d-43fc-9fc4-64d0685b0a2b.jpg"
    		},
    		{
    			"id": 72,
    			"status": "published",
    			"sort": 70,
    			"owner": 11,
    			"created_on": "2021-03-15T09:37:32.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 3 - DAY 3",
    			"url": "https://youtu.be/Jnte4P6x8YA",
    			"thumbnail": 86,
    			"live": 0,
    			"filename_disk": "72220767-2904-4d4d-a6c3-4018722fc7df.jpg"
    		},
    		{
    			"id": 71,
    			"status": "published",
    			"sort": 69,
    			"owner": 11,
    			"created_on": "2021-03-15T09:36:54.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 3 - DAY 3",
    			"url": "https://youtu.be/UxXN7i9Ku3s",
    			"thumbnail": 85,
    			"live": 0,
    			"filename_disk": "57bb2479-3189-46a1-9758-cfa9cf52a99f.jpg"
    		},
    		{
    			"id": 70,
    			"status": "published",
    			"sort": 68,
    			"owner": 11,
    			"created_on": "2021-03-15T09:35:58.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 3 - DAY 2",
    			"url": "https://youtu.be/JV1NyP6WAIo",
    			"thumbnail": 84,
    			"live": 0,
    			"filename_disk": "a4554dc7-9f36-4c31-89bb-6a8a5c16b62d.jpg"
    		},
    		{
    			"id": 69,
    			"status": "published",
    			"sort": 67,
    			"owner": 11,
    			"created_on": "2021-03-15T09:35:15.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 3 - DAY 2",
    			"url": "https://youtu.be/KgsdJjES-Fg",
    			"thumbnail": 83,
    			"live": 0,
    			"filename_disk": "4e933aff-9a12-4399-8228-ceaa6e2b2209.jpg"
    		},
    		{
    			"id": 68,
    			"status": "published",
    			"sort": 66,
    			"owner": 11,
    			"created_on": "2021-03-15T09:34:29.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 3 - DAY 1",
    			"url": "https://youtu.be/WJG4JXfwFik",
    			"thumbnail": 82,
    			"live": 0,
    			"filename_disk": "a4bd2160-8863-469c-a771-3c7d94011244.jpg"
    		},
    		{
    			"id": 67,
    			"status": "published",
    			"sort": 65,
    			"owner": 11,
    			"created_on": "2021-03-15T09:33:45.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 3 - DAY 1",
    			"url": "https://youtu.be/QBwLKPb1eCo",
    			"thumbnail": 81,
    			"live": 0,
    			"filename_disk": "80640c77-ec87-4319-8018-96ae70c5a970.jpg"
    		},
    		{
    			"id": 66,
    			"status": "published",
    			"sort": 64,
    			"owner": 11,
    			"created_on": "2021-03-15T09:32:47.000Z",
    			"name": "CONQUEST: GAMING FTW | Episode 2 ft @Jonty Gaming | Viewer Games | Diamond Giveaways",
    			"url": "https://youtu.be/-XSD8KTqOg0",
    			"thumbnail": 80,
    			"live": 0,
    			"filename_disk": "8695082b-8e37-490d-b1a1-9cf38cf70a65.jpg"
    		},
    		{
    			"id": 64,
    			"status": "published",
    			"sort": 63,
    			"owner": 11,
    			"created_on": "2021-03-15T09:29:56.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 3 - DAY 1",
    			"url": "https://youtu.be/Gu9omvMl30g",
    			"thumbnail": 78,
    			"live": 0,
    			"filename_disk": "08c94503-7e38-4a2d-9e9b-e67917e0c20e.jpg"
    		},
    		{
    			"id": 63,
    			"status": "published",
    			"sort": 62,
    			"owner": 11,
    			"created_on": "2021-03-15T09:29:07.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 3 - DAY 2",
    			"url": "https://youtu.be/oa7yJw5R4ws",
    			"thumbnail": 77,
    			"live": 0,
    			"filename_disk": "106e9daa-d9ae-4140-ab7e-8058f99625cf.jpg"
    		},
    		{
    			"id": 62,
    			"status": "published",
    			"sort": 61,
    			"owner": 11,
    			"created_on": "2021-03-15T09:28:14.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 3 - DAY 3",
    			"url": "https://youtu.be/P5rgnqGem_E",
    			"thumbnail": 76,
    			"live": 0,
    			"filename_disk": "1ae08bf0-cafa-430a-830a-e7ea348cdb00.jpg"
    		},
    		{
    			"id": 61,
    			"status": "published",
    			"sort": 60,
    			"owner": 11,
    			"created_on": "2021-03-15T09:26:56.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 3 | WEEKLY ROUND-UP",
    			"url": "https://youtu.be/C7bXWArKbNI",
    			"thumbnail": 75,
    			"live": 0,
    			"filename_disk": "1c6b4ac5-f36f-4369-857d-dc882d3e26ac.jpg"
    		},
    		{
    			"id": 60,
    			"status": "published",
    			"sort": 59,
    			"owner": 11,
    			"created_on": "2021-03-15T09:25:42.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 4 - DAY 1",
    			"url": "https://youtu.be/srGYz_Yjlnw",
    			"thumbnail": 74,
    			"live": 0,
    			"filename_disk": "e9a0d334-3d4c-4695-a71b-fc58bb8b1a8a.jpg"
    		},
    		{
    			"id": 59,
    			"status": "published",
    			"sort": 58,
    			"owner": 11,
    			"created_on": "2021-03-15T09:24:45.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 4 - DAY 2",
    			"url": "https://youtu.be/gCVrClb1ik4",
    			"thumbnail": 73,
    			"live": 0,
    			"filename_disk": "232ce1cf-a33c-4681-8edb-b358ff41a6d0.jpg"
    		},
    		{
    			"id": 58,
    			"status": "published",
    			"sort": 57,
    			"owner": 11,
    			"created_on": "2021-03-15T09:24:05.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 4 - DAY 3",
    			"url": "https://youtu.be/ZheEkYK4phw",
    			"thumbnail": 72,
    			"live": 0,
    			"filename_disk": "9760fffc-5e08-442d-b621-4365fe01d68b.jpg"
    		},
    		{
    			"id": 57,
    			"status": "published",
    			"sort": 55,
    			"owner": 11,
    			"created_on": "2021-03-15T09:23:25.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 4 | WEEKLY ROUND-UP",
    			"url": "https://youtu.be/GWsAyPTvRuk",
    			"thumbnail": 71,
    			"live": 0,
    			"filename_disk": "e66fa0c1-b604-4426-a932-31a9a0f0032b.jpg"
    		},
    		{
    			"id": 56,
    			"status": "published",
    			"sort": 54,
    			"owner": 11,
    			"created_on": "2021-03-15T09:22:46.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | GRAND FINALS | OFFICIAL TRAILER​",
    			"url": "https://youtu.be/6nKxUsAFKIM",
    			"thumbnail": 70,
    			"live": 0,
    			"filename_disk": "920e3e8f-ea03-4469-b4e6-bc099789d3bb.jpg"
    		},
    		{
    			"id": 55,
    			"status": "published",
    			"sort": 53,
    			"owner": 11,
    			"created_on": "2021-03-15T09:22:07.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | TEAM SPOTLIGHT & INTERVIEW | HEX ESPORTS​",
    			"url": "https://youtu.be/1C1Tvh85L8c",
    			"thumbnail": 69,
    			"live": 0,
    			"filename_disk": "48d67f64-860d-49a5-b06f-ddedc2710a3e.jpg"
    		},
    		{
    			"id": 54,
    			"status": "published",
    			"sort": 52,
    			"owner": 11,
    			"created_on": "2021-03-15T09:21:25.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | TEAM SPOTLIGHT & INTERVIEW | GALAXY RACER",
    			"url": "https://youtu.be/V7zvuKmbTBE",
    			"thumbnail": 68,
    			"live": 0,
    			"filename_disk": "6245431a-4f42-414d-b4df-dad09a76ec39.jpg"
    		},
    		{
    			"id": 53,
    			"status": "published",
    			"sort": 51,
    			"owner": 11,
    			"created_on": "2021-03-15T09:20:40.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | TEAM SPOTLIGHT & INTERVIEW | SURVIVOR 4AM",
    			"url": "https://youtu.be/1xywIP9uQvE",
    			"thumbnail": 67,
    			"live": 0,
    			"filename_disk": "2ed23977-13d3-418a-b809-9c840cc8ad04.jpg"
    		},
    		{
    			"id": 52,
    			"status": "published",
    			"sort": 50,
    			"owner": 11,
    			"created_on": "2021-03-15T09:20:07.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | TEAM SPOTLIGHT & INTERVIEW | TEAM CHAOS",
    			"url": "https://youtu.be/1elCNI0tBkk",
    			"thumbnail": 66,
    			"live": 0,
    			"filename_disk": "0673cac0-8ff4-4ff2-87b0-b5f85f58c25d.jpg"
    		},
    		{
    			"id": 50,
    			"status": "published",
    			"sort": 49,
    			"owner": 11,
    			"created_on": "2021-03-15T09:18:32.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | GRAND FINALS | FINAL TOP 12 TEAMS",
    			"url": "https://youtu.be/Q4ndWz2iACI",
    			"thumbnail": 64,
    			"live": 0,
    			"filename_disk": "38b75d54-90f3-4b7b-89b8-14ddfd32c506.jpg"
    		},
    		{
    			"id": 51,
    			"status": "published",
    			"sort": 48,
    			"owner": 11,
    			"created_on": "2021-03-15T09:19:15.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | TEAM SPOTLIGHT & INTERVIEW | 4 UNKNOWN",
    			"url": "https://youtu.be/yGrlN4E487I",
    			"thumbnail": 65,
    			"live": 0,
    			"filename_disk": "9986548d-e41a-4498-b91d-cfed6a840dc1.jpg"
    		},
    		{
    			"id": 49,
    			"status": "published",
    			"sort": 47,
    			"owner": 11,
    			"created_on": "2021-03-15T09:17:57.000Z",
    			"name": "Welcome to Snapdragon Insiders program for Snapdragon enthusiasts",
    			"url": "https://youtu.be/o8w9y4qRuxg",
    			"thumbnail": 63,
    			"live": 0,
    			"filename_disk": "d143e851-eaa2-46bf-8094-7b24dafd36d1.jpg"
    		},
    		{
    			"id": 48,
    			"status": "published",
    			"sort": 46,
    			"owner": 11,
    			"created_on": "2021-03-15T09:17:22.000Z",
    			"name": "GRAND FINALS HIGHLIGHTS | CONQUEST: FREE FIRE OPEN | DAY 1",
    			"url": "https://youtu.be/6_p2IYnLZd0",
    			"thumbnail": 62,
    			"live": 0,
    			"filename_disk": "8fc725a1-d26c-451f-9571-006d34cdba31.jpg"
    		},
    		{
    			"id": 47,
    			"status": "published",
    			"sort": 45,
    			"owner": 11,
    			"created_on": "2021-03-15T09:16:28.000Z",
    			"name": "GRAND FINALS HIGHLIGHTS | CONQUEST: FREE FIRE OPEN | DAY 2",
    			"url": "https://youtu.be/HbdHhZrgIbU",
    			"thumbnail": 61,
    			"live": 0,
    			"filename_disk": "3476a449-2693-41f3-aabf-c70bba5d25fb.jpg"
    		},
    		{
    			"id": 7,
    			"status": "published",
    			"sort": 44,
    			"owner": 1,
    			"created_on": "2021-01-13T18:12:19.000Z",
    			"name": "Video 6",
    			"url": "https://www.youtube.com/watch?v=X-TWnYfuQgY",
    			"thumbnail": 4,
    			"live": 0,
    			"filename_disk": "30b99033-a6d6-4b93-99e5-9959704c51f1.jpeg"
    		},
    		{
    			"id": 6,
    			"status": "published",
    			"sort": 43,
    			"owner": 1,
    			"created_on": "2021-01-13T18:11:42.000Z",
    			"name": "Video 5",
    			"url": "https://www.youtube.com/watch?v=v1Js7pSAuvM",
    			"thumbnail": 8,
    			"live": 0,
    			"filename_disk": "d7c5af8f-a602-4a5c-ad48-ac6b433d7f4e.jpeg"
    		},
    		{
    			"id": 5,
    			"status": "published",
    			"sort": 42,
    			"owner": 1,
    			"created_on": "2021-01-13T18:10:45.000Z",
    			"name": "Video 4",
    			"url": "https://www.youtube.com/watch?v=Vbone1mZpAA",
    			"thumbnail": 7,
    			"live": 0,
    			"filename_disk": "dc5ae723-1d5d-46de-93b2-1882a2053cba.jpeg"
    		},
    		{
    			"id": 4,
    			"status": "published",
    			"sort": 41,
    			"owner": 1,
    			"created_on": "2021-01-13T18:09:52.000Z",
    			"name": "Video 3",
    			"url": "https://www.youtube.com/watch?v=mG2p3PoThbc",
    			"thumbnail": 6,
    			"live": 0,
    			"filename_disk": "624614aa-5a73-48eb-8687-0f82f2a1dcea.jpeg"
    		},
    		{
    			"id": 3,
    			"status": "published",
    			"sort": 40,
    			"owner": 1,
    			"created_on": "2021-01-13T17:18:31.000Z",
    			"name": "Video 2",
    			"url": "https://www.youtube.com/watch?v=TSqkspMzTCU",
    			"thumbnail": 5,
    			"live": 0,
    			"filename_disk": "98ac830e-336a-459b-8bac-a84724208089.jpeg"
    		},
    		{
    			"id": 1,
    			"status": "published",
    			"sort": 39,
    			"owner": 1,
    			"created_on": "2021-01-13T14:01:14.000Z",
    			"name": "Main Vide",
    			"url": "https://www.youtube.com/watch?v=LjSX7wYgx4o",
    			"thumbnail": 4,
    			"live": 0,
    			"filename_disk": "30b99033-a6d6-4b93-99e5-9959704c51f1.jpeg"
    		},
    		{
    			"id": 16,
    			"status": "published",
    			"sort": 38,
    			"owner": 11,
    			"created_on": "2021-01-21T17:39:48.000Z",
    			"name": "CONQUEST: GAMING FTW Episode 1 featuring @vasiyoCRJ 7",
    			"url": "https://youtu.be/y8gceMELYoU?t=1110",
    			"thumbnail": 20,
    			"live": 0,
    			"filename_disk": "132a6011-e600-42fa-8f03-1582596307af.jpg"
    		},
    		{
    			"id": 9,
    			"status": "published",
    			"sort": 37,
    			"owner": 2,
    			"created_on": "2021-01-18T11:41:02.000Z",
    			"name": "[ENGLISH] Playoffs Round 2 - Day 1 - Broadcast",
    			"url": "https://www.youtube.com/watch?v=BXb6IG7lu-o",
    			"thumbnail": 10,
    			"live": 0,
    			"filename_disk": "0c9a1357-d9f4-4010-be5e-53bb45c36d26.jpg"
    		},
    		{
    			"id": 8,
    			"status": "published",
    			"sort": 36,
    			"owner": 2,
    			"created_on": "2021-01-18T11:26:45.000Z",
    			"name": "[HINDI] Playoffs Round 2 - Day 1 - Broadcast",
    			"url": "https://www.youtube.com/watch?v=AyJQDlQ1BSw",
    			"thumbnail": 9,
    			"live": 0,
    			"filename_disk": "dcc91e73-9de7-42e1-b84c-a3d88adb8613.jpg"
    		},
    		{
    			"id": 17,
    			"status": "published",
    			"sort": 35,
    			"owner": 11,
    			"created_on": "2021-01-21T17:41:40.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | PLAYOFFS ROUND 2 - DAY 1",
    			"url": "https://youtu.be/nV2ADsFieTs",
    			"thumbnail": 21,
    			"live": 0,
    			"filename_disk": "1a9d98e1-fe65-4bc8-ac52-7775b9117563.jpg"
    		},
    		{
    			"id": 11,
    			"status": "published",
    			"sort": 34,
    			"owner": 2,
    			"created_on": "2021-01-19T11:04:01.000Z",
    			"name": "[ENGLISH] Playoffs Round 2 - Day 2 - Broadcast",
    			"url": "https://www.youtube.com/watch?v=3Guu08mHguI",
    			"thumbnail": 11,
    			"live": 0,
    			"filename_disk": "114eb49f-768e-408c-a900-66e6b04f1530.png"
    		},
    		{
    			"id": 10,
    			"status": "published",
    			"sort": 33,
    			"owner": 2,
    			"created_on": "2021-01-19T11:02:18.000Z",
    			"name": "[HINDI] Playoffs Round 2 - Day 2 - Broadcast",
    			"url": "https://www.youtube.com/watch?v=6JYMNMH6FKs",
    			"thumbnail": 11,
    			"live": 0,
    			"filename_disk": "114eb49f-768e-408c-a900-66e6b04f1530.png"
    		},
    		{
    			"id": 18,
    			"status": "published",
    			"sort": 32,
    			"owner": 11,
    			"created_on": "2021-01-21T17:42:48.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | PLAYOFFS ROUND 2 - DAY 2",
    			"url": "https://youtu.be/lf4IdNometI",
    			"thumbnail": 22,
    			"live": 0,
    			"filename_disk": "11ecc105-3613-408e-adc9-03ffa1561c76.jpg"
    		},
    		{
    			"id": 13,
    			"status": "published",
    			"sort": 31,
    			"owner": 11,
    			"created_on": "2021-01-20T11:13:45.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 2 - DAY 3",
    			"url": "https://youtu.be/9iJ7TP4H7zg",
    			"thumbnail": 16,
    			"live": 0,
    			"filename_disk": "8704aa67-f734-4232-a7e3-cc793d0de978.jpg"
    		},
    		{
    			"id": 12,
    			"status": "published",
    			"sort": 30,
    			"owner": 11,
    			"created_on": "2021-01-20T11:12:23.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 2 - DAY 3",
    			"url": "https://youtu.be/GBdaKMuDx7Y",
    			"thumbnail": 15,
    			"live": 0,
    			"filename_disk": "94d7b798-6631-4672-bf15-ace87f591229.jpg"
    		},
    		{
    			"id": 19,
    			"status": "published",
    			"sort": 29,
    			"owner": 11,
    			"created_on": "2021-01-21T17:45:28.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | PLAYOFFS ROUND 2 - DAY 3",
    			"url": "https://youtu.be/Sw-iJ-hqtUU",
    			"thumbnail": 23,
    			"live": 0,
    			"filename_disk": "5e032048-96ba-4431-a4e7-aa0a3fcd8870.jpg"
    		},
    		{
    			"id": 14,
    			"status": "published",
    			"sort": 28,
    			"owner": 11,
    			"created_on": "2021-01-21T11:17:08.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 3 - DAY 1",
    			"url": "https://www.youtube.com/watch?v=-IrHnSJBWjw",
    			"thumbnail": 24,
    			"live": 0,
    			"filename_disk": "8e5eba3d-38fb-4f88-85b3-a02ebfb46d0d.jpg"
    		},
    		{
    			"id": 15,
    			"status": "published",
    			"sort": 27,
    			"owner": 11,
    			"created_on": "2021-01-21T11:18:04.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 3 - DAY 1",
    			"url": "https://www.youtube.com/watch?v=_tvZClWLJiI",
    			"thumbnail": 25,
    			"live": 0,
    			"filename_disk": "a3c04519-eae6-47cd-b0fd-a425d3012dfa.jpg"
    		},
    		{
    			"id": 23,
    			"status": "published",
    			"sort": 26,
    			"owner": 11,
    			"created_on": "2021-01-22T11:58:45.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | PLAYOFFS ROUND 3 - DAY 1",
    			"url": "https://youtu.be/v2USkufvabU",
    			"thumbnail": 30,
    			"live": 0,
    			"filename_disk": "77970e7a-e418-4163-a2cf-481a77c67f2a.png"
    		},
    		{
    			"id": 20,
    			"status": "published",
    			"sort": 25,
    			"owner": 11,
    			"created_on": "2021-01-22T11:50:17.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 3 - DAY 2",
    			"url": "https://youtu.be/mddhLi0kRbc",
    			"thumbnail": 26,
    			"live": 0,
    			"filename_disk": "7e56daad-282c-43e1-88d3-6c17cbad4e7d.jpg"
    		},
    		{
    			"id": 21,
    			"status": "published",
    			"sort": 24,
    			"owner": 11,
    			"created_on": "2021-01-22T11:51:08.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 3 - DAY 2",
    			"url": "https://youtu.be/KOl9KOnNsJA",
    			"thumbnail": 27,
    			"live": 0,
    			"filename_disk": "e3c3b3fb-4260-4c94-8202-205a51b43b21.jpg"
    		},
    		{
    			"id": 24,
    			"status": "published",
    			"sort": 23,
    			"owner": 11,
    			"created_on": "2021-01-23T10:49:29.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | PLAYOFFS ROUND 3 - DAY 2",
    			"url": "https://youtu.be/56srIyUIxFM",
    			"thumbnail": 32,
    			"live": 0,
    			"filename_disk": "7372bdaa-9e70-4be0-9ce7-95cf13a622db.png"
    		},
    		{
    			"id": 25,
    			"status": "published",
    			"sort": 22,
    			"owner": 11,
    			"created_on": "2021-01-23T10:54:59.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 3 - DAY 3",
    			"url": "https://youtu.be/2yqM-UQvLIU",
    			"thumbnail": 33,
    			"live": 0,
    			"filename_disk": "b008bf3f-8599-495f-b72d-b17d60bac852.jpg"
    		},
    		{
    			"id": 26,
    			"status": "published",
    			"sort": 21,
    			"owner": 11,
    			"created_on": "2021-01-23T10:56:27.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | PLAYOFFS | ROUND 3 - DAY 3",
    			"url": "https://youtu.be/GbkI7QhLcvQ",
    			"thumbnail": 34,
    			"live": 0,
    			"filename_disk": "984e9b13-a48b-494c-baa8-6734a1c38760.jpg"
    		},
    		{
    			"id": 30,
    			"status": "published",
    			"sort": 20,
    			"owner": 11,
    			"created_on": "2021-01-31T11:45:35.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | PLAYOFFS ROUND 3 - DAY 3",
    			"url": "https://youtu.be/NRuOaS1aQM8",
    			"thumbnail": 39,
    			"live": 0,
    			"filename_disk": "6619254c-ac2b-4ea3-a015-368b0ff8883a.jpg"
    		},
    		{
    			"id": 27,
    			"status": "published",
    			"sort": 19,
    			"owner": 11,
    			"created_on": "2021-01-31T11:41:10.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 1 - DAY 1",
    			"url": "https://youtu.be/XvMy7gI0flM",
    			"thumbnail": 36,
    			"live": 0,
    			"filename_disk": "d7cdafd8-a792-4a53-951e-b6083b1092bd.png"
    		},
    		{
    			"id": 28,
    			"status": "published",
    			"sort": 18,
    			"owner": 11,
    			"created_on": "2021-01-31T11:42:13.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 1 - DAY 1",
    			"url": "https://youtu.be/_l5aBWpqbao",
    			"thumbnail": 37,
    			"live": 0,
    			"filename_disk": "c1bccc3c-d60f-4146-9d6e-e720ae34d6ba.png"
    		},
    		{
    			"id": 29,
    			"status": "published",
    			"sort": 17,
    			"owner": 11,
    			"created_on": "2021-01-31T11:43:47.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 1 - DAY 1",
    			"url": "https://youtu.be/PYg--PQQHus",
    			"thumbnail": 38,
    			"live": 0,
    			"filename_disk": "febd6bdc-d95f-41ce-8879-99b2bbb2d19a.png"
    		},
    		{
    			"id": 31,
    			"status": "published",
    			"sort": 16,
    			"owner": 11,
    			"created_on": "2021-01-31T11:47:13.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 1 - DAY 2",
    			"url": "https://youtu.be/mMuZp4FPejU",
    			"thumbnail": 40,
    			"live": 0,
    			"filename_disk": "3605527a-e300-4d51-b3d9-9a791a2f649b.png"
    		},
    		{
    			"id": 32,
    			"status": "published",
    			"sort": 15,
    			"owner": 11,
    			"created_on": "2021-01-31T11:48:31.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 1 - DAY 2",
    			"url": "https://youtu.be/y-D7cY73lyw",
    			"thumbnail": 41,
    			"live": 0,
    			"filename_disk": "bda7619e-0595-4e60-bc1f-4c29fd6d0980.png"
    		},
    		{
    			"id": 33,
    			"status": "published",
    			"sort": 14,
    			"owner": 11,
    			"created_on": "2021-02-06T06:13:33.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 1 - DAY 2",
    			"url": "https://youtu.be/J5VcMkixRuI",
    			"thumbnail": 44,
    			"live": 0,
    			"filename_disk": "6a3dd466-da1a-4e52-af21-1a3c638511e9.png"
    		},
    		{
    			"id": 34,
    			"status": "published",
    			"sort": 13,
    			"owner": 11,
    			"created_on": "2021-02-06T06:15:31.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 1 - DAY 3",
    			"url": "https://youtu.be/sSoe6RsRHH8",
    			"thumbnail": 45,
    			"live": 0,
    			"filename_disk": "c3579e56-393c-42ac-87d1-51406aa77db9.png"
    		},
    		{
    			"id": 35,
    			"status": "published",
    			"sort": 12,
    			"owner": 11,
    			"created_on": "2021-02-06T06:17:07.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 1 - DAY 3",
    			"url": "https://youtu.be/g8fu6ioZzdc",
    			"thumbnail": 46,
    			"live": 0,
    			"filename_disk": "7341f798-2ad1-4237-9cf6-bcd012b78e7c.png"
    		},
    		{
    			"id": 36,
    			"status": "published",
    			"sort": 11,
    			"owner": 11,
    			"created_on": "2021-02-06T06:20:16.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 1 - DAY 3",
    			"url": "https://youtu.be/9O5urOq1Doc",
    			"thumbnail": 47,
    			"live": 0,
    			"filename_disk": "19391b8f-4656-41b1-b047-f28a65fc96bb.png"
    		},
    		{
    			"id": 46,
    			"status": "published",
    			"sort": 10,
    			"owner": 11,
    			"created_on": "2021-02-09T07:50:25.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 1 | WEEKLY ROUND-UP",
    			"url": "https://youtu.be/RqRomk7pCSc",
    			"thumbnail": 57,
    			"live": 0,
    			"filename_disk": "dfaee0e8-5819-4f7d-96a6-65905b5dd02b.jpg"
    		},
    		{
    			"id": 37,
    			"status": "published",
    			"sort": 9,
    			"owner": 11,
    			"created_on": "2021-02-06T06:25:58.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 2 - DAY 1",
    			"url": "https://youtu.be/yYKNyLL6X8k",
    			"thumbnail": 48,
    			"live": 0,
    			"filename_disk": "7f5567be-154e-4caf-91b2-c773cf4e8e22.png"
    		},
    		{
    			"id": 38,
    			"status": "published",
    			"sort": 8,
    			"owner": 11,
    			"created_on": "2021-02-06T06:27:31.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 2 - DAY 1",
    			"url": "https://youtu.be/7Vugu3RagwU",
    			"thumbnail": 49,
    			"live": 0,
    			"filename_disk": "7b074f6f-6956-4e68-9a73-a8cc2de6697a.png"
    		},
    		{
    			"id": 65,
    			"status": "published",
    			"sort": 8,
    			"owner": 11,
    			"created_on": "2021-03-15T09:30:40.000Z",
    			"name": "CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 2 | WEEKLY ROUND-UP",
    			"url": "https://youtu.be/f45HRNrk2kY",
    			"thumbnail": 79,
    			"live": 0,
    			"filename_disk": "c622ab9a-2afd-4420-b4c9-47201bfe74d0.jpg"
    		},
    		{
    			"id": 39,
    			"status": "published",
    			"sort": 7,
    			"owner": 11,
    			"created_on": "2021-02-09T07:10:56.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 2 - DAY 1",
    			"url": "https://youtu.be/ss_PJ17Yjkw",
    			"thumbnail": 50,
    			"live": 0,
    			"filename_disk": "5f858cb3-8c42-4262-b20e-16777aa7a976.jpg"
    		},
    		{
    			"id": 42,
    			"status": "published",
    			"sort": 6,
    			"owner": 11,
    			"created_on": "2021-02-09T07:15:29.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 2 - DAY 2",
    			"url": "https://youtu.be/ucSIa0SVG44",
    			"thumbnail": 53,
    			"live": 0,
    			"filename_disk": "83e0c160-9c11-44a2-b22b-62c4404bae5b.jpg"
    		},
    		{
    			"id": 41,
    			"status": "published",
    			"sort": 5,
    			"owner": 11,
    			"created_on": "2021-02-09T07:14:50.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 2 - DAY 2",
    			"url": "https://youtu.be/sqnQEtRORzM",
    			"thumbnail": 52,
    			"live": 0,
    			"filename_disk": "2711d416-50d7-46d4-a0e6-1a429979f323.jpg"
    		},
    		{
    			"id": 40,
    			"status": "published",
    			"sort": 4,
    			"owner": 11,
    			"created_on": "2021-02-09T07:12:29.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 2 - DAY 2",
    			"url": "https://youtu.be/8_O4e2c3K2o",
    			"thumbnail": 51,
    			"live": 0,
    			"filename_disk": "1ff9f730-6350-4bae-a5a9-c43667297281.jpg"
    		},
    		{
    			"id": 43,
    			"status": "published",
    			"sort": 3,
    			"owner": 11,
    			"created_on": "2021-02-09T07:16:15.000Z",
    			"name": "[ENGLISH] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE| WEEK 2 - DAY 3",
    			"url": "https://youtu.be/7SF4NH60L7I",
    			"thumbnail": 54,
    			"live": 0,
    			"filename_disk": "742699fe-815a-4bcb-9a2d-2a58f000739f.jpg"
    		},
    		{
    			"id": 44,
    			"status": "published",
    			"sort": 2,
    			"owner": 11,
    			"created_on": "2021-02-09T07:18:47.000Z",
    			"name": "[HINDI] CONQUEST: FREE FIRE OPEN | LEAGUE STAGE | WEEK 2 - DAY 3",
    			"url": "https://youtu.be/wAnoxL5uiGw",
    			"thumbnail": 55,
    			"live": 0,
    			"filename_disk": "a75b858c-4dfb-453a-adfc-d1d2c165e3d3.jpg"
    		},
    		{
    			"id": 45,
    			"status": "published",
    			"sort": 1,
    			"owner": 11,
    			"created_on": "2021-02-09T07:46:53.000Z",
    			"name": "TOP 10 MOMENTS | CONQUEST: FREE FIRE OPEN | LEAGUE STAGE WEEK 2 - DAY 3",
    			"url": "https://youtu.be/CmrcUJq8450",
    			"thumbnail": 56,
    			"live": 0,
    			"filename_disk": "b60d9c73-5bc3-4697-9d7b-b8e4fedfa6ba.jpg"
    		}
    	];

    	// const client = new RESTClient();
    	// client.get('videos').then(res => videos = res);
    	let toggleFlag = false;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Videos> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, toggleFlag = !toggleFlag);

    	$$self.$capture_state = () => ({
    		VideoModal,
    		Modal,
    		Video,
    		RESTClient,
    		VideoSlider,
    		Swiper: Swiper$2,
    		SwiperSlide,
    		Insider,
    		videos,
    		toggleFlag
    	});

    	$$self.$inject_state = $$props => {
    		if ('videos' in $$props) $$invalidate(1, videos = $$props.videos);
    		if ('toggleFlag' in $$props) $$invalidate(0, toggleFlag = $$props.toggleFlag);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [toggleFlag, videos, click_handler];
    }

    class Videos extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Videos",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src/pages/Faq.svelte generated by Svelte v3.41.0 */
    const file$v = "src/pages/Faq.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (385:2) <Tab>
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("General");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(385:2) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (386:2) <Tab>
    function create_default_slot_6$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Registrations");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(386:2) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (387:2) <Tab>
    function create_default_slot_5$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Tournament");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(387:2) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (384:1) <TabList>
    function create_default_slot_4$1(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(384:1) <TabList>",
    		ctx
    	});

    	return block;
    }

    // (401:5) {#if generalfaqcontent.active}
    function create_if_block_2$6(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let raw_value = /*generalfaqcontent*/ ctx[19].content + "";
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[7](/*generalfaqcontent*/ ctx[19]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "section-text svelte-a39fra");
    			add_location(div0, file$v, 403, 8, 28670);
    			attr_dev(div1, "class", "col-12");
    			add_location(div1, file$v, 402, 7, 28640);
    			attr_dev(div2, "class", "slider row no-gutters svelte-a39fra");
    			add_location(div2, file$v, 401, 6, 28534);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*generalfaqs*/ 1) && raw_value !== (raw_value = /*generalfaqcontent*/ ctx[19].content + "")) div0.innerHTML = raw_value;		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide$1, {}, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide$1, {}, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(401:5) {#if generalfaqcontent.active}",
    		ctx
    	});

    	return block;
    }

    // (391:3) {#each generalfaqs as generalfaqcontent}
    function create_each_block_2(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let span0;
    	let t0_value = /*generalfaqcontent*/ ctx[19].title + "";
    	let t0;
    	let t1;
    	let span1;

    	let t2_value = (/*generalfaqcontent*/ ctx[19].active
    	? 'remove_circle_outline'
    	: 'add_circle_outline') + "";

    	let t2;
    	let t3;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*generalfaqcontent*/ ctx[19]);
    	}

    	let if_block = /*generalfaqcontent*/ ctx[19].active && create_if_block_2$6(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text$1(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			attr_dev(span0, "class", "question-title");
    			add_location(span0, file$v, 395, 8, 28234);
    			set_style(span1, "float", "right");
    			attr_dev(span1, "class", "material-icons plus-icon svelte-a39fra");
    			add_location(span1, file$v, 396, 8, 28305);
    			attr_dev(div0, "class", "accordion-list svelte-a39fra");
    			add_location(div0, file$v, 394, 7, 28153);
    			attr_dev(div1, "class", "col-lg-12 col-sm-12 col-xs-12");
    			add_location(div1, file$v, 393, 6, 28101);
    			attr_dev(div2, "class", "row no-gutters");
    			add_location(div2, file$v, 392, 5, 28065);
    			attr_dev(div3, "class", "accordion");
    			add_location(div3, file$v, 391, 4, 28035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			append_dev(div3, t3);
    			if (if_block) if_block.m(div3, null);
    			append_dev(div3, t4);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*generalfaqs*/ 1) && t0_value !== (t0_value = /*generalfaqcontent*/ ctx[19].title + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*generalfaqs*/ 1) && t2_value !== (t2_value = (/*generalfaqcontent*/ ctx[19].active
    			? 'remove_circle_outline'
    			: 'add_circle_outline') + "")) set_data_dev(t2, t2_value);

    			if (/*generalfaqcontent*/ ctx[19].active) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*generalfaqs*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, t4);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(391:3) {#each generalfaqs as generalfaqcontent}",
    		ctx
    	});

    	return block;
    }

    // (389:1) <TabPanel>
    function create_default_slot_3$1(ctx) {
    	let div;
    	let current;
    	let each_value_2 = /*generalfaqs*/ ctx[0];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "faq-section container svelte-a39fra");
    			add_location(div, file$v, 389, 2, 27949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*expand, generalfaqs*/ 9) {
    				each_value_2 = /*generalfaqs*/ ctx[0];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(389:1) <TabPanel>",
    		ctx
    	});

    	return block;
    }

    // (424:5) {#if registrationcontent.active}
    function create_if_block_1$a(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let raw_value = /*registrationcontent*/ ctx[16].content + "";
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[9](/*registrationcontent*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "section-text svelte-a39fra");
    			add_location(div0, file$v, 426, 8, 29607);
    			attr_dev(div1, "class", "col-12");
    			add_location(div1, file$v, 425, 7, 29577);
    			attr_dev(div2, "class", "slider row no-gutters svelte-a39fra");
    			add_location(div2, file$v, 424, 6, 29455);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", click_handler_3, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*registrationfaqs*/ 2) && raw_value !== (raw_value = /*registrationcontent*/ ctx[16].content + "")) div0.innerHTML = raw_value;		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide$1, {}, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide$1, {}, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(424:5) {#if registrationcontent.active}",
    		ctx
    	});

    	return block;
    }

    // (414:3) {#each registrationfaqs as registrationcontent}
    function create_each_block_1$5(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let span0;
    	let t0_value = /*registrationcontent*/ ctx[16].title + "";
    	let t0;
    	let t1;
    	let span1;

    	let t2_value = (/*registrationcontent*/ ctx[16].active
    	? 'remove_circle_outline'
    	: 'add_circle_outline') + "";

    	let t2;
    	let t3;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[8](/*registrationcontent*/ ctx[16]);
    	}

    	let if_block = /*registrationcontent*/ ctx[16].active && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text$1(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			attr_dev(span0, "class", "question-title");
    			add_location(span0, file$v, 418, 8, 29149);
    			set_style(span1, "float", "right");
    			attr_dev(span1, "class", "material-icons plus-icon svelte-a39fra");
    			add_location(span1, file$v, 419, 8, 29222);
    			attr_dev(div0, "class", "accordion-list svelte-a39fra");
    			add_location(div0, file$v, 417, 7, 29052);
    			attr_dev(div1, "class", "col-lg-12 col-sm-12 col-xs-12");
    			add_location(div1, file$v, 416, 6, 29000);
    			attr_dev(div2, "class", "row no-gutters");
    			add_location(div2, file$v, 415, 5, 28964);
    			attr_dev(div3, "class", "accordion");
    			add_location(div3, file$v, 414, 4, 28934);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			append_dev(div3, t3);
    			if (if_block) if_block.m(div3, null);
    			append_dev(div3, t4);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*registrationfaqs*/ 2) && t0_value !== (t0_value = /*registrationcontent*/ ctx[16].title + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*registrationfaqs*/ 2) && t2_value !== (t2_value = (/*registrationcontent*/ ctx[16].active
    			? 'remove_circle_outline'
    			: 'add_circle_outline') + "")) set_data_dev(t2, t2_value);

    			if (/*registrationcontent*/ ctx[16].active) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*registrationfaqs*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, t4);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(414:3) {#each registrationfaqs as registrationcontent}",
    		ctx
    	});

    	return block;
    }

    // (412:1) <TabPanel>
    function create_default_slot_2$1(ctx) {
    	let div;
    	let current;
    	let each_value_1 = /*registrationfaqs*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "faq-section container svelte-a39fra");
    			add_location(div, file$v, 412, 2, 28841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*registrationfaqsopen, registrationfaqs*/ 18) {
    				each_value_1 = /*registrationfaqs*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(412:1) <TabPanel>",
    		ctx
    	});

    	return block;
    }

    // (447:5) {#if tournamentcontent.active}
    function create_if_block$h(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let raw_value = /*tournamentcontent*/ ctx[13].content + "";
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[11](/*tournamentcontent*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "section-text svelte-a39fra");
    			add_location(div0, file$v, 449, 8, 30528);
    			attr_dev(div1, "class", "col-12");
    			add_location(div1, file$v, 448, 7, 30498);
    			attr_dev(div2, "class", "slider row no-gutters svelte-a39fra");
    			add_location(div2, file$v, 447, 6, 30380);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", click_handler_5, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*tournamentfaqs*/ 4) && raw_value !== (raw_value = /*tournamentcontent*/ ctx[13].content + "")) div0.innerHTML = raw_value;		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide$1, {}, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide$1, {}, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(447:5) {#if tournamentcontent.active}",
    		ctx
    	});

    	return block;
    }

    // (437:3) {#each tournamentfaqs as tournamentcontent}
    function create_each_block$8(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let span0;
    	let t0_value = /*tournamentcontent*/ ctx[13].title + "";
    	let t0;
    	let t1;
    	let span1;

    	let t2_value = (/*tournamentcontent*/ ctx[13].active
    	? 'remove_circle_outline'
    	: 'add_circle_outline') + "";

    	let t2;
    	let t3;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[10](/*tournamentcontent*/ ctx[13]);
    	}

    	let if_block = /*tournamentcontent*/ ctx[13].active && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text$1(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			attr_dev(span0, "class", "question-title");
    			add_location(span0, file$v, 441, 8, 30080);
    			set_style(span1, "float", "right");
    			attr_dev(span1, "class", "material-icons plus-icon svelte-a39fra");
    			add_location(span1, file$v, 442, 8, 30151);
    			attr_dev(div0, "class", "accordion-list svelte-a39fra");
    			add_location(div0, file$v, 440, 7, 29987);
    			attr_dev(div1, "class", "col-lg-12 col-sm-12 col-xs-12");
    			add_location(div1, file$v, 439, 6, 29935);
    			attr_dev(div2, "class", "row no-gutters");
    			add_location(div2, file$v, 438, 5, 29899);
    			attr_dev(div3, "class", "accordion");
    			add_location(div3, file$v, 437, 4, 29869);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			append_dev(div3, t3);
    			if (if_block) if_block.m(div3, null);
    			append_dev(div3, t4);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", click_handler_4, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*tournamentfaqs*/ 4) && t0_value !== (t0_value = /*tournamentcontent*/ ctx[13].title + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*tournamentfaqs*/ 4) && t2_value !== (t2_value = (/*tournamentcontent*/ ctx[13].active
    			? 'remove_circle_outline'
    			: 'add_circle_outline') + "")) set_data_dev(t2, t2_value);

    			if (/*tournamentcontent*/ ctx[13].active) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*tournamentfaqs*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, t4);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(437:3) {#each tournamentfaqs as tournamentcontent}",
    		ctx
    	});

    	return block;
    }

    // (435:1) <TabPanel>
    function create_default_slot_1$1(ctx) {
    	let div;
    	let current;
    	let each_value = /*tournamentfaqs*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "faq-section container svelte-a39fra");
    			add_location(div, file$v, 435, 2, 29780);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tournamentfaqsopen, tournamentfaqs*/ 36) {
    				each_value = /*tournamentfaqs*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(435:1) <TabPanel>",
    		ctx
    	});

    	return block;
    }

    // (383:0) <Tabs>
    function create_default_slot$4(ctx) {
    	let tablist;
    	let t0;
    	let tabpanel0;
    	let t1;
    	let tabpanel1;
    	let t2;
    	let tabpanel2;
    	let current;

    	tablist = new TabList({
    			props: {
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabpanel0 = new TabPanel({
    			props: {
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabpanel1 = new TabPanel({
    			props: {
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabpanel2 = new TabPanel({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabpanel0.$$.fragment);
    			t1 = space();
    			create_component(tabpanel1.$$.fragment);
    			t2 = space();
    			create_component(tabpanel2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tablist, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tabpanel0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabpanel1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabpanel2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabpanel0_changes = {};

    			if (dirty & /*$$scope, generalfaqs*/ 4194305) {
    				tabpanel0_changes.$$scope = { dirty, ctx };
    			}

    			tabpanel0.$set(tabpanel0_changes);
    			const tabpanel1_changes = {};

    			if (dirty & /*$$scope, registrationfaqs*/ 4194306) {
    				tabpanel1_changes.$$scope = { dirty, ctx };
    			}

    			tabpanel1.$set(tabpanel1_changes);
    			const tabpanel2_changes = {};

    			if (dirty & /*$$scope, tournamentfaqs*/ 4194308) {
    				tabpanel2_changes.$$scope = { dirty, ctx };
    			}

    			tabpanel2.$set(tabpanel2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabpanel0.$$.fragment, local);
    			transition_in(tabpanel1.$$.fragment, local);
    			transition_in(tabpanel2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabpanel0.$$.fragment, local);
    			transition_out(tabpanel1.$$.fragment, local);
    			transition_out(tabpanel2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tablist, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabpanel0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabpanel1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabpanel2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(383:0) <Tabs>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let link;
    	let t0;
    	let div0;
    	let h1;
    	let t2;
    	let tabs;
    	let t3;
    	let div3;
    	let div2;
    	let div1;
    	let p;
    	let t4;
    	let a;
    	let current;

    	tabs = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			link = element("link");
    			t0 = space();
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Frequently asked questions";
    			t2 = space();
    			create_component(tabs.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			p = element("p");
    			t4 = text$1("For additional support, please contact us at ");
    			a = element("a");
    			a.textContent = "support@snapdragonconquest.com";
    			attr_dev(link, "href", "https://fonts.googleapis.com/icon?family=Material+Icons");
    			attr_dev(link, "rel", "stylesheet");
    			add_location(link, file$v, 375, 1, 27617);
    			attr_dev(h1, "class", "main-heading svelte-a39fra");
    			add_location(h1, file$v, 380, 1, 27760);
    			attr_dev(div0, "class", "banner-section svelte-a39fra");
    			add_location(div0, file$v, 379, 0, 27729);
    			attr_dev(a, "href", "mailto:someone@example.com");
    			add_location(a, file$v, 462, 49, 30816);
    			add_location(p, file$v, 461, 3, 30762);
    			attr_dev(div1, "class", "col");
    			add_location(div1, file$v, 460, 2, 30740);
    			attr_dev(div2, "class", "row");
    			add_location(div2, file$v, 459, 1, 30719);
    			attr_dev(div3, "class", "container");
    			add_location(div3, file$v, 458, 0, 30693);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h1);
    			insert_dev(target, t2, anchor);
    			mount_component(tabs, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(p, t4);
    			append_dev(p, a);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope, tournamentfaqs, registrationfaqs, generalfaqs*/ 4194311) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabs, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Faq', slots, []);
    	let visible = true;

    	let generalfaqs = [
    		{
    			id: 1,
    			title: "What is Free Fire?",
    			content: 'Free Fire is an online multiplayer battle royale game developed by 111 Dots Studio and published by Garena for Android and iOS. <p class="hindi-txt">फ्री फायर 111 Dots Studio  द्वारा विकसित Android और iOS के लिए गरेना द्वारा प्रकाशित एक ऑनलाइन मल्टीप्लेयर बैटल रॉयल गेम है।​</p>',
    			active: false
    		},
    		{
    			id: 2,
    			title: "How to play Free Fire?",
    			content: "<p>Download the Free Fire Mobile app from the Apple app store or Google play store.</p><p>Create an account within the app.</p><p>Play and enjoy.</p><p class='hindi-txt'>ऐप्पल ऐप स्टोर या गूगल प्ले स्टोर से फ्री फायर मोबाइल ऐप डाउनलोड करें। ऐप के भीतर एक खाता बनाएं। खेलें और आनंद लें।</p>",
    			active: false
    		},
    		{
    			id: 3,
    			title: "Who is organizing Free Fire Open 2020?",
    			content: "<p>Qualcomm(R) Snapdragon Conquest(TM): Free Fire Open 2020 is organized by Qualcomm and executed by Tesseract Esports</p><p class='hindi-txt'>क्वालकॉम (R) स्नैपड्रैगन कांकुएस्ट (TM): फ्री फायर ओपन 2020 क्वालकॉम द्वारा आयोजित किया जाता है और टेसरैक्ट इस्पोर्ट्स द्वारा निष्पादित किया जाता है</p>",
    			active: false
    		},
    		{
    			id: 4,
    			title: "What are the tournament rules?",
    			content: "<p>You can find the complete rulebook at <a href='/rulebook.pdf' target='_blank'>Rulebook</a></p><p class='hindi-txt'>आप <a href='/rulebook.pdf' target='_blank'>नियम पुस्तिका</a> में पूरे  नियम पा सकते हैं</p>",
    			active: false
    		},
    		{
    			id: 5,
    			title: "How will we be playing- mobile or PC?",
    			content: "<p>This is a mobile- only online tournament and usage of emulators in the tournament is strictly prohibited.</p><p class='hindi-txt'>यह एक केवल-मोबाइल ऑनलाइन टूर्नामेंट है और टूर्नामेंट में एमुलेटर का उपयोग पूरी तरह से प्रतिबंधित है।</p>",
    			active: false
    		},
    		{
    			id: 6,
    			title: "Can I use triggers or Emulators?",
    			content: "<p>No, triggers and emulators or any other add-on devices are strictly prohibited. Team/Players will be disqualified if found to be using additional devices.</p><p class='hindi-txt'>नहीं, ट्रिगर्स और एमुलेटर या किसी भी अन्य ऐड-ऑन डिवाइस को सख्त वर्जित है। अतिरिक्त उपकरणों का उपयोग करते पाए जाने पर टीम / खिलाड़ियों को अयोग्य घोषित कर दिया जाएगा।</p>",
    			active: false
    		},
    		{
    			id: 7,
    			title: "What is the Prize Pool? ",
    			content: "<p>A prize pool of INR 50 Lakhs is up for grabs. The prize distribution is based on the team’s standing post finals. Individuals excelling in certain categories are also entitled to special awards.</p><p class='hindi-txt'>50 लाख रुपए का पुरस्कार पूल उपलब्ध है। पुरस्कार वितरण टीम के अंतिम स्थायी पद पर आधारित है। कुछ श्रेणियों में उत्कृष्ट व्यक्ति भी विशेष पुरस्कार के हकदार हैं।</p>",
    			active: false
    		},
    		{
    			id: 8,
    			title: "How is the prize pool distributed?",
    			content: "<p>Below is the detailed breakdown of the prizes at stake.</p><div class='table-responsive'><table class='table'><thead><tr><th scope='col'>Position</th><th scope='col'>Prize</th></tr></thead><tbody><tr><td>1</td><td>20,00,000INR</td></tr><tr><td>2</td><td>8,00,000INR</td></tr><tr><td>3</td><td>5,00,000INR</td></tr><tr><td>4</td><td>4,00,000INR</td></tr><tr><td>5</td><td>3,00,000INR</td></tr><tr><td>6</td><td>2,00,000INR</td></tr><tr><td>7</td><td>1,50,000INR</td></tr><tr><td>8</td><td>1,00,000INR</td></tr><tr><td>9</td><td>75,000INR</td></tr><tr><td>10</td><td>75,000INR</td></tr><tr><td>11</td><td>50,000INR</td></tr><tr><td>12</td><td>50,000INR</td></tr><tr><td>Special Rewards</td><td>3,00,000INR</td></tr></tbody></table></div><p class='hindi-txt'>नीचे पुरस्कारों का विस्तृत विराम दिया गया है।</p><div class='table-responsive'><table class='table'><thead><tr><th scope='col'>Position</th><th scope='col'>Prize</th></tr></thead><tbody><tr><td>1</td><td>20,00,000INR</td></tr><tr><td>2</td><td>8,00,000INR</td></tr><tr><td>3</td><td>5,00,000INR</td></tr><tr><td>4</td><td>4,00,000INR</td></tr><tr><td>5</td><td>3,00,000INR</td></tr><tr><td>6</td><td>2,00,000INR</td></tr><tr><td>7</td><td>1,50,000INR</td></tr><tr><td>8</td><td>1,00,000INR</td></tr><tr><td>9</td><td>75,000INR</td></tr><tr><td>10</td><td>75,000INR</td></tr><tr><td>11</td><td>50,000INR</td></tr><tr><td>12</td><td>50,000INR</td></tr><tr><td>Special Rewards</td><td>3,00,000INR</td></tr></tbody></table></div>",
    			active: false
    		},
    		{
    			id: 9,
    			title: "How do I get the money if I win?",
    			content: "<p>The prize money will be directly transferred to the winner’s bank account. The details will be collected and the deposit will be done within 90 working days after finals.</p><p class='hindi-txt'>पुरस्कार राशि सीधे विजेता के बैंक खाते में स्थानांतरित कर दी जाएगी। विवरण एकत्र किया जाएगा और फाइनल के बाद 90 दिनों के भीतर जमा किया जाएगा।</p>",
    			active: false
    		},
    		{
    			id: 10,
    			title: "Is the prize money subject to Government taxes or deductions?",
    			content: "<p>Yes. Like winnings from any other tournament, the tax amount will be deducted at source (TDS) in accordance with the Government regulations.</p><p class='hindi-txt'>हाँ। किसी भी अन्य टूर्नामेंट से मिली जीत की तरह, कर की राशि सरकार के नियमों के अनुसार स्रोत (TDS) में काटी जाएगी।</p>",
    			active: false
    		},
    		{
    			id: 11,
    			title: "What are the phases of tournament?",
    			content: "<p><strong>Tournament Phases</strong></p><ol><li>Registrations</li><li>In-game qualifiers</li><li>Online Playoffs</li><li>League Stage</li><li>Grand Finals</li></ol><p class='hindi-txt'>टूर्नामेंट के चरण</p><ol><li>पंजीकरण</li><li>इन-गेम क्वालिफ़ायर</li><li>ऑनलाइन प्लेऑफ्स</li><li>लीग स्टेज</li><li>ग्रैंड फाइनल</li></ol>",
    			active: false
    		},
    		{
    			id: 12,
    			title: "What is the format of the tournament?",
    			content: "<p>You can find all information on the tournament format <a href='/format' target='_top'>here</a></p><p class='hindi-txt'>आप टूर्नामेंट प्रारूप पर सभी जानकारी <a href='/format' target='_top'>यहाँ</a> पा सकते हैं</p>",
    			active: false
    		},
    		{
    			id: 13,
    			title: "From where should I play the tournament?",
    			content: "<p>You can play the tournament from any choice of location as long as you can maintain an internet connection, since the tournament matches are going to be played online. However, you need to be physically at the venue if the tournament organizer decides to hold the finals at an offline venue.</p><p class='hindi-txt'>आप टूर्नामेंट को किसी भी पसंद के स्थान से खेल सकते हैं जब तक आप इंटरनेट कनेक्शन बनाए रख सकते हैं, क्योंकि टूर्नामेंट मैच ऑनलाइन खेले जाने हैं। हालाँकि, यदि टूर्नामेंट आयोजक एक ऑफ़लाइन स्थान पर फाइनल आयोजित करने का निर्णय लेता है तब आपको टूर्नामेंट स्थल पर शारीरिक रूप से रहने की आवश्यकता है ।</p>",
    			active: false
    		}
    	];

    	const expand = generalfaqcontent => {
    		$$invalidate(0, generalfaqs = generalfaqs.map(s => {
    			let c = generalfaqs.find(i => i.active);
    			s.active = false;

    			if (!c || c && c.id != generalfaqcontent.id) if (s.id === generalfaqcontent.id) {
    				s.active = true;
    			}

    			return s;
    		}));
    	};

    	// for Registration
    	let registrationfaqs = [
    		{
    			id: 1,
    			title: "How to register for the tournament?",
    			content: '<ul class="list-items"><li>Visit the official website - <a target="_balnk" href="http://www.snapdragonconquest.com/">http://www.snapdragonconquest.com/</a></li><li>Click on the "Register Now" button on the homepage</li><li>Enter your "Email ID" and verify with the OTP received on your Email.</li><li>Fill in your details</li><li>Accept the terms and conditions</li></ul><p>You are now registered on the website. To complete registrations for the tournament either create a team or join a team. Only a complete team of 4 players will be considered eligible for participating in the tournament.</p><ul class="list-items"><li>आधिकारिक वेबसाइट पर जाएं - <a target="_balnk" href="http://www.snapdragonconquest.com/">http://www.snapdragonconquest.com/</a></li><li>होमपेज पर "Register Now" बटन पर क्लिक करें</li><li>अपनी "Email ID" दर्ज करें और अपने ईमेल पर प्राप्त ओटीपी के साथ सत्यापित करें।</li><li>अपने विवरण भरें</li><li>नियम और शर्तों को स्वीकार करें</li></ul><p>अब आप वेबसाइट पर पंजीकृत हैं। टूर्नामेंट के लिए पंजीकरण पूरा करने के लिए या तो एक टीम बनाएं या एक टीम में शामिल हों। टूर्नामेंट में भाग लेने के लिए केवल 4 खिलाड़ियों की एक पूरी टीम को योग्य माना जाएगा।</p>',
    			active: false
    		},
    		{
    			id: 2,
    			title: "What do I require for registering?",
    			content: '<p>You need your mail ID, phone number and Free Fire player ID to register for the Qualcomm Snapdragon Conquest Free Fire India Open 2020.</p><p class="hindi-txt">क्वालकॉम स्नैपड्रैगन कांकुएस्ट फ्री फायर इंडिया ओपन 2020 के लिए पंजीकरण करने के लिए आपको अपनी मेल आईडी, फोन नंबर और फ्री फायर प्लेयर आईडी की आवश्यकता है।</p>',
    			active: false
    		},
    		{
    			id: 3,
    			title: "What is the player ID? Where can I find my Free Fire player ID?",
    			content: '<ul><li>Open the Free Fire app on your device</li><li>Tap on your profile icon on the top left corner of the home screen</li><li>Under Gallery you will see your in game name and your player ID number below it.</li><li>Copy player ID number by taping on the copy button on the side of the number</li></ul><ul><li>अपने डिवाइस पर फ्री फायर ऐप खोलें</li><li>होम स्क्रीन के ऊपरी बाएँ कोने पर अपने प्रोफ़ाइल आइकन पर टैप करें</li><li>गैलरी के तहत आप अपने गेम का नाम और उसके नीचे अपना खिलाड़ी आईडी नंबर देखेंगे।</li><li>नंबर के कॉपी बटन पर टैप करके प्लेयर आईडी नंबर कॉपी करें</li></ul>',
    			active: false
    		},
    		{
    			id: 4,
    			title: "Are there any criteria for participating in the tournament?",
    			content: '<p>Some of the important criteria includes</p><ul><li>You must be 12 years or more to be eligible to participate in the tournament.</li><li>You must be an Indian Citizen</li><li>To complete registration you must have 4 members in your team before the registration closes.</li><li>Your Free Fire account must be Level 10 or above</li></ul><p>Please read the rulebook for more detailed information <a href="/rulebook.pdf" target="_blank">Rulebook</a></p><p class="hindi-txt">कुछ महत्वपूर्ण मानदंडों में शामिल हैं</p><ul><li>टूर्नामेंट में भाग लेने के लिए आपकी आयु 12 वर्ष या उससे अधिक होनी चाहिए।</li><li>आपको भारतीय नागरिक होना चाहिए</li><li>पंजीकरण पूरा करने के लिए पंजीकरण बंद होने से पहले आपकी टीम में 4 सदस्य होने चाहिए।</li><li>आपका Free Fire खाता 10 या उससे ऊपर का स्तर होना चाहिए</li></ul><p>अधिक विस्तृत जानकारी नियम पुस्तिका के लिए कृपया <a href="/rulebook.pdf" target="_blank">नियम पुस्तक</a> पढ़ें</p>',
    			active: false
    		},
    		{
    			id: 5,
    			title: "Is there a registration cost or fee for participating in the tournament?",
    			content: '<p>No, Qualcomm Snapdragon Conquest: Free Fire India Open 2020 is a free to participate tournament. There is no registration fee or cost involved.</p><p class="hindi-txt">नहीं, क्वालकॉम स्नैपड्रैगन कांकुएस्ट: फ्री फायर इंडिया ओपन 2020 टूर्नामेंट में भाग लेने के लिए स्वतंत्र है। इसमें कोई पंजीकरण शुल्क या लागत शामिल नहीं है।</p>',
    			active: false
    		},
    		{
    			id: 6,
    			title: "Are the registrations limited?",
    			content: '<p>The registrations are not limited- the more the merrier!</p><p class="hindi-txt">पंजीकरण सीमित नहीं हैं- जितना ज़्यादा उतना अच्छा!</p>',
    			active: false
    		},
    		{
    			id: 7,
    			title: "When is the last day for registration?",
    			content: '<p>The last day of registration is 20th December, 2020.</p><p class="hindi-txt">पंजीकरण का अंतिम दिन 20 दिसंबर, 2020 है।</p>',
    			active: false
    		},
    		{
    			id: 8,
    			title: "Can I add or modify team members during registrations?",
    			content: '<p>Yes, if you are the team leader you can add or modify team members till registrations close.Please note that you cannot make changes to your team once the registrations close.</p><p class="hindi-txt">हां, यदि आप टीम लीडर हैं, तो आप पंजीकरण तक टीम के सदस्यों को जोड़ या संशोधित कर सकते हैं। कृपया ध्यान दें कि पंजीकरण बंद होने के बाद आप अपनी टीम में बदलाव नहीं कर सकते।</p>',
    			active: false
    		},
    		{
    			id: 9,
    			title: "How do I create my team?",
    			content: '<ul><li>Go to the user dashboard.</li><li>On the Your Team panel, enter the team name, and click on Create Team</li><li>Invite 3 more of your friends to join the team</li></ul><ul><li>उपयोगकर्ता dashboard पर जाएं।.</li><li>Your Team पैनल पर, टीम का नाम दर्ज करें, और Create Team पर क्लिक करें</li><li>टीम में शामिल होने के लिए अपने 3 और दोस्तों को आमंत्रित करें</li></ul>',
    			active: false
    		},
    		{
    			id: 10,
    			title: "How do I invite players to join my team?",
    			content: '<ul><li>Go to Your Team Section of the Dashboard</li><li>Go to the Complete your team panel</li><li>Click on "+ add player"</li><li>Copy the invite code and share it with your friends or enter your friends’ email to send them an invite link.</li></ul><ul><li>डैशबोर्ड की अपनी टीम अनुभाग पर जाएं</li><li>अपनी टीम के पैनल को पूरा करें</li><li>"+ खिलाड़ी जोड़ें" पर क्लिक करें</li><li>आमंत्रण कोड को कॉपी करें और अपने दोस्तों के साथ साझा करें या उन्हें आमंत्रित लिंक भेजने के लिए अपने दोस्तों के ईमेल दर्ज करें।</li></ul>',
    			active: false
    		},
    		{
    			id: 11,
    			title: "How do I remove a player from my team?",
    			content: '<ul><li>Go to Your Team Section of the Dashboard</li><li>Click on the drop-down option on the top right of the player you wish to remove</li><li>Click on remove player</li></ul><p>You can invite the player back again by sharing the invite code or link.</p><ul><li>डैशबोर्ड(Dashboard) की अपनी टीम अनुभाग पर जाएं</li><li>जिस खिलाड़ी को आप हटाना चाहते हैं, उसके ऊपर दाईं ओर drop-down विकल्प पर क्लिक करें</li><li>निकालें खिलाड़ी(remove player) पर क्लिक करें</li></ul><p>आप आमंत्रित कोड या लिंक साझा करके खिलाड़ी को फिर से आमंत्रित कर सकते हैं।</p>',
    			active: false
    		},
    		{
    			id: 12,
    			title: "How do I make another player in my team the team leader?",
    			content: '<ul><li>Go to Your Team Section of the Dashboard</li><li>Click on the drop-down option on the top right of the player you wish to make leader</li><li>Click Make Leader</li></ul><p>As a team leader you can only leave the team once you make another team member the leader.</p><ul class="hindi-txt"><li>डैशबोर्ड (Dashboard) की अपनी Team अनुभाग पर जाएं</li><li>जिस खिलाड़ी को आप लीडर बनाना चाहते हैं, उसके ऊपर दाईं ओर ड्रॉप-डाउन (drop-down) विकल्प पर क्लिक करें</li><li>मेक लीडर(Make Leader) पर क्लिक करें</li></ul><p>एक टीम लीडर के रूप में आप एक बार टीम के किसी अन्य सदस्य को नेता बनाने के बाद ही टीम छोड़ सकते हैं।</p>',
    			active: false
    		},
    		{
    			id: 13,
    			title: "How do I delete or disband a team?",
    			content: '<p>If you are the team leader</p><ul><li>Go to Your Team Section of the Dashboard</li><li>Click on the drop-down option on the top of the team panel</li><li>Click delete team</li></ul><p>Warning: Deleting the team will cause all of the players in the team to get removed as well</p><p class="hindi-txt">अगर आप टीम लीडर हैं</p><ul><li>डैशबोर्ड (Dashboard) की अपनी टीम अनुभाग पर जाएं</li><li>टीम पैनल के शीर्ष पर स्थित ड्रॉप-डाउन(drop-down) विकल्प पर क्लिक करें</li><li>डिलीट टीम (delete team)पर क्लिक करें</li></ul><p>चेतावनी: टीम को हटाने से टीम के सभी खिलाड़ियों को हटा दिया जाएगा</p>',
    			active: false
    		},
    		{
    			id: 14,
    			title: "How do I join a team?",
    			content: '<p>After registering your account</p><ul><li>Go to Your Team Section of the Dashboard</li><li>Click the ‘Join a team’ in the Join a team panel</li><li>Paste the invite code shared by your friends or click on find a team to join</li><li>Input either the Team Leader or Team Name in the search bar to find the team to join</li></ul><p class="hindi-txt">अपना अकाउंट रजिस्टर करने के बाद डैशबोर्ड (Dashboard)की अपनी टीम अनुभाग पर जाएं</p><ul><li>एक टीम में शामिल हों पैनल में &lsquo;एक टीम में शामिल हों&rsquo; (Join a team)पर क्लिक करें</li><li>अपने दोस्तों द्वारा साझा किए गए आमंत्रण कोड को पेस्ट करें या खोजने के लिए एक टीम खोजें पर क्लिक करें</li><li>टीम में शामिल होने के लिए टीम लीडर या टीम का नाम सर्च बार में इनपुट करें</li></ul>',
    			active: false
    		},
    		{
    			id: 15,
    			title: "How do I leave a team?",
    			content: '<p>If you are the team leader, to leave the team you would have to assign another member of your team as the leader first. Once done you can leave the team by clicking the drop down menu on the top right of the team panel and leaving team</p><p>If you are not the team leader, you can leave the team you joined at any time by pressing the leave team below the team panel.</p><p class="hindi-txt">यदि आप टीम लीडर हैं, तो टीम को छोड़ने के लिए आपको अपनी टीम के किसी अन्य सदस्य को पहले लीडर के रूप में नियुक्त करना होगा। एक बार जब आप टीम पैनल के शीर्ष दाईं ओर ड्रॉप डाउन (drop down)मेनू पर क्लिक करके और टीम को छोड़ कर टीम छोड़ सकते हैं</p><p class="hindi-txt">यदि आप टीम लीडर नहीं हैं, तो आप किसी भी समय ज्वाइन की गई टीम को टीम पैनल के नीचे लीव टीम(leave team) दबाकर छोड़ सकते हैं।</p>',
    			active: false
    		},
    		{
    			id: 16,
    			title: "I tried joining/leaving a team or removing a team member but my status isn't updating?",
    			content: '<p>Please refresh your browser once and you will see the updated status</p><p>कृपया अपने ब्राउज़र(browser) को एक बार रीफ़्रेश(refresh) करें और आपको अपडेट की गई स्थिति दिखाई देगी</p>',
    			active: false
    		},
    		{
    			id: 17,
    			title: "Can I register with one member in my team?",
    			content: '<p>Unfortunately, the format does not allow for solo players to register. This is to prevent matches from becoming one- sided since teams without a full squad are bound to start with a disadvantage. However, we suggest you get your buddies to register along with you and join us on this wild ride that promises a thrilling time for everyone involved!</p><p class="hindi-txt">दुर्भाग्य से, प्रारूप एकल खिलाड़ियों को पंजीकृत करने की अनुमति नहीं देता है। यह मैचों को एकतरफा बनने से रोकने के लिए है क्योंकि बिना पूरी टीम के टीम एक नुकसान के साथ शुरुआत करने के लिए बाध्य है। हालाँकि, हमारा सुझाव है कि आप अपने मित्रों को अपने साथ पंजीकृत करवाएं और इस जंगली सवारी में शामिल हों, जो सभी के लिए रोमांचकारी समय का वादा करता है!</p>',
    			active: false
    		},
    		{
    			id: 18,
    			title: "Can I register with two members in my team?",
    			content: '<p>Unfortunately, the format does not allow for players without 4 members in their squad to register. This is to prevent matches from becoming one- sided since teams without a full squad are bound to start with a disadvantage. However, we suggest you get your buddies to register along with you and join us on this wild ride that promises a thrilling time for everyone involved!</p><p class="hindu-txt">दुर्भाग्य से, प्रारूप 4 सदस्यों वाले खिलाड़ियों को पंजीकरण करने के लिए अनुमति नहीं देता है। यह मैचों को एकतरफा बनने से रोकने के लिए है क्योंकि बिना पूरी टीम के टीम एक नुकसान के साथ शुरुआत करने के लिए बाध्य है। हालाँकि, हमारा सुझाव है कि आप अपने मित्रों को अपने साथ पंजीकृत करवाएं और इस जंगली सवारी में शामिल हों, जो सभी के लिए रोमांचकारी समय का वादा करता है!</p>',
    			active: false
    		},
    		{
    			id: 19,
    			title: "Can I register with three members in my team?",
    			content: '<p>Unfortunately, the format does not allow for players without 4 members in their squad to register. This is to prevent matches from becoming one- sided since teams without a full squad are bound to start with a disadvantage. However, we suggest you get your buddies to register along with you and join us on this wild ride that promises a thrilling time for everyone involved!</p><p class="hindi-txt">दुर्भाग्य से, प्रारूप 4 सदस्यों वाले खिलाड़ियों को पंजीकरण करने के लिए अनुमति नहीं देता है। यह मैचों को एकतरफा बनने से रोकने के लिए है क्योंकि बिना पूरी टीम के टीम एक नुकसान के साथ शुरुआत करने के लिए बाध्य है। हालाँकि, हमारा सुझाव है कि आप अपने मित्रों को अपने साथ पंजीकृत करवाएं और इस जंगली सवारी में शामिल हों, जो सभी के लिए रोमांचकारी समय का वादा करता है!</p>',
    			active: false
    		},
    		{
    			id: 20,
    			title: "What happens if I don’t complete my team during registrations?",
    			content: '<p>Only a complete 4-member team will be eligible to participate in the tournament. If you don’t complete your team or are part of an incomplete team before the end of registrations, you will not be eligible to participate in the tournament.</p><p class="hindi-txt">केवल 4 सदस्यीय पूरी टीम टूर्नामेंट में भाग लेने के लिए पात्र होगी। यदि आप अपनी टीम को पूरा नहीं करते हैं या पंजीकरण समाप्त होने से पहले एक अधूरी टीम का हिस्सा हैं, तो आप टूर्नामेंट में भाग लेने के लिए पात्र नहीं होंगे।</p>',
    			active: false
    		}
    	];

    	const registrationfaqsopen = registrationcontent => {
    		$$invalidate(1, registrationfaqs = registrationfaqs.map(s => {
    			let c = registrationfaqs.find(i => i.active);
    			s.active = false;

    			if (!c || c && c.id != registrationcontent.id) if (s.id === registrationcontent.id) {
    				s.active = true;
    			}

    			return s;
    		}));
    	};

    	// for Tournament
    	// for Registration
    	let tournamentfaqs = [
    		{
    			id: 1,
    			title: "When does the In-game Qualifiers begin?",
    			content: '<p>The In-game qualifiers will begin once the registrations close. Check out the schedule at <a href="/schedule">schedule</a> and follow us on Facebook, Instagram and Twitter to stay up to date on all the latest info.</p><p class="hindi-txt">पंजीकरण बंद होने के बाद इन-गेम क्वालिफायर शुरू हो जाएगा <a href="/schedule">शेड्यूल देखें</a>शेड्यूल देखें और सभी नवीनतम जानकारी पर अपडेट रहने के लिए हमें Facebook, Instagram और Twitter पर फॉलो करें।</p>',
    			active: false
    		},
    		{
    			id: 2,
    			title: "How many teams will participate in the in-game qualifiers?",
    			content: '<p>All registered teams with all 4 team members will be eligible to participate in the In-game qualifiers.</p><p class="hindi-txt">सभी 4 टीम सदस्यों के साथ सभी पंजीकृत टीमें इन-गेम क्वालिफायर (In-game qualifiers) में भाग लेने के लिए पात्र होंगी।</p>',
    			active: false
    		},
    		{
    			id: 3,
    			title: "Can my team use substitutes who are not registered once the In-game qualifiers begin?",
    			content: '<p>No, you cannot use unregistered players once the tournament begins.</p><p class="hindi-txt">नहीं, आप टूर्नामेंट शुरू होने के बाद अपंजीकृत खिलाड़ियों का उपयोग नहीं कर सकते।</p>',
    			active: false
    		},
    		{
    			id: 4,
    			title: "How to play the in-game qualifiers?",
    			content: '<p>Once registered, the team will be required to play 15 classic matches (Bermuda and Kalahari) within the timeframe of the In-Game Qualifiers. Scores of 10 best matches out of the first 15 matches played will be considered for the qualification to the online playoffs.​</p><p class="hindi-txt">एक बार पंजीकृत होने के बाद, टीम को इन-गेम क्वालिफ़ायर के समय सीमा के भीतर 15 क्लासिक मैच (बरमूडा और कालाहारी)(Bermuda and Kalahari) खेलने की आवश्यकता होगी। पहले खेले गए 15 मैचों में से 10 सर्वश्रेष्ठ मैचों के स्कोर को ऑनलाइन प्लेऑफ़ के लिए योग्यता के लिए माना जाएगा।</p>',
    			active: false
    		},
    		{
    			id: 5,
    			title: "When does the online playoffs begin?",
    			content: '<p>The online playoffs will begin once the seeding ends. Check out the <a href="/schedule">schedule</a> and follow us on Facebook, Instagram and Twitter to stay up to date on all the latest info.</p><p class="hindi-txt">सीडिंग खत्म होते ही ऑनलाइन प्लेऑफ शुरू हो जाएगा। <a href="/schedule">शेड्यूल</a> देखें और सभी नवीनतम जानकारी पर अपडेट रहने के लिए हमें Facebook, Instagram और Twitter पर फॉलो करें।</p>',
    			active: false
    		},
    		{
    			id: 6,
    			title: "How many teams will participate in the online playoffs?",
    			content: '<p>Playoffs will be played in 3 rounds. The participating teams are as follows</p><ul class="list-items"><li>Round 1 – 648 Teams</li><li>Round 2 – 216 Teams</li><li>Round 3 – 72 Teams</li></ul><p>प्लेऑफ 3 राउंड में खेले जाएंगे। प्रतिभागी टीमें इस प्रकार हैं</p><ul class="list-items"><li>दौर 1 - 648 टीमें</li><li>दौर 2 - 216 टीमें</li><li>दौर 3 - 72 टीमें</li></ul>',
    			active: false
    		},
    		{
    			id: 7,
    			title: "What is the format for the online playoffs?",
    			content: '<p>You can find all information on the tournament format <a href="/format">here</a></p><p class="hindi-txt">आप टूर्नामेंट प्रारूप पर सभी जानकारी <a href="/format">यहाँ</a> पा सकते हैं</p>',
    			active: false
    		},
    		{
    			id: 8,
    			title: "Where to find lobby ID and password?",
    			content: '<p><strong>For In-game Qualifiers:</strong> There will be no lobbies for in-game qualifiers. Once registered, the team will be required to play 15 classic matches (Bermuda or Kalahari) in during the duration of the In game qualifiers. Scores of 10 best matches out of the first 15 matches played will be considered for the qualification of the online playoffs.</p><p><strong>For Playoffs, League Stage and Finals:</strong> Lobby ID and password will be shared with you via the user dashboard and also on community platforms like Whatsapp or Discord before the match by tournament organizers. You will receive an invite link to the community.​</p><p>इन-गेम क्वालिफायर के लिए कोई लॉबी नहीं होगी। एक बार पंजीकृत होने के बाद, टीम को इन गेम क्वालिफायर की अवधि के दौरान 15 क्लासिक मैच (बरमूडा या कालाहारी) खेलने की आवश्यकता होगी। पहले खेले गए 15 मैचों में से 10 सर्वश्रेष्ठ मैचों के स्कोर को ऑनलाइन प्लेऑफ़ की योग्यता के लिए माना जाएगा।</p><p><strong>प्लेऑफ, लीग स्टेज और फाइनल</strong> के लिए: लॉबी आईडी और पासवर्ड को उपयोगकर्ता डैशबोर्ड के माध्यम से और टूर्नामेंट आयोजकों द्वारा मैच से पहले व्हाट्सएप (Whatsapp) या डिस्कॉर्ड (Discord) जैसे सामुदायिक प्लेटफार्मों पर भी आपके साथ साझा किया जाएगा। आपको समुदाय के लिए एक निमंत्रण लिंक प्राप्त होगा।</p>',
    			active: false
    		},
    		{
    			id: 9,
    			title: "How many teams will participate in the League Stage?",
    			content: '<p>18 qualifying teams and 6 Invited teams will be participate in the League Stage.</p><p class="hindi-txt">लीग चरण में 18 क्वालीफाइंग टीमें और 6 आमंत्रित टीमें भाग लेंगी।</p>',
    			active: false
    		},
    		{
    			id: 10,
    			title: "What is the format for the league stage?",
    			content: '<p>You can find all information on the tournament format <a href="/format">here</a></p><p>आप टूर्नामेंट प्रारूप पर सभी जानकारी <a href="/format">यहाँ</a> पा सकते हैं</p>',
    			active: false
    		},
    		{
    			id: 11,
    			title: "How many teams will participate in the finals?",
    			content: '<p>12 Teams will participate in the finals.</p><p class="hindi-txt">12 टीमें फाइनल में हिस्सा लेंगी।</p>',
    			active: false
    		},
    		{
    			id: 12,
    			title: "What is the format for the finals?",
    			content: '<p>You can find all information on the tournament format <a href="/format">here</a></p><p class="hindi-txt">आप टूर्नामेंट प्रारूप पर सभी जानकारी <a href="/format">यहाँ</a> पा सकते हैं</p>',
    			active: false
    		},
    		{
    			id: 13,
    			title: "How will the Team get to know if they are qualified?",
    			content: '<p>They will be receiving a Mail, Message and Call to the registered contact details</p><p class="hindi-txt">वे पंजीकृत संपर्क विवरणों को एक मेल(Mail), संदेश (Message)और कॉल(Call) प्राप्त करेंगे</p>',
    			active: false
    		}
    	];

    	const tournamentfaqsopen = tournamentcontent => {
    		$$invalidate(2, tournamentfaqs = tournamentfaqs.map(s => {
    			let c = tournamentfaqs.find(i => i.active);
    			s.active = false;

    			if (!c || c && c.id != tournamentcontent.id) if (s.id === tournamentcontent.id) {
    				s.active = true;
    			}

    			return s;
    		}));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Faq> was created with unknown prop '${key}'`);
    	});

    	const click_handler = generalfaqcontent => expand(generalfaqcontent);
    	const click_handler_1 = generalfaqcontent => expand(!generalfaqcontent);
    	const click_handler_2 = registrationcontent => registrationfaqsopen(registrationcontent);
    	const click_handler_3 = registrationcontent => registrationfaqsopen(!registrationcontent);
    	const click_handler_4 = tournamentcontent => tournamentfaqsopen(tournamentcontent);
    	const click_handler_5 = tournamentcontent => tournamentfaqsopen(!tournamentcontent);

    	$$self.$capture_state = () => ({
    		Tabs,
    		TabList,
    		TabPanel,
    		Tab,
    		slide: slide$1,
    		visible,
    		generalfaqs,
    		expand,
    		registrationfaqs,
    		registrationfaqsopen,
    		tournamentfaqs,
    		tournamentfaqsopen
    	});

    	$$self.$inject_state = $$props => {
    		if ('visible' in $$props) visible = $$props.visible;
    		if ('generalfaqs' in $$props) $$invalidate(0, generalfaqs = $$props.generalfaqs);
    		if ('registrationfaqs' in $$props) $$invalidate(1, registrationfaqs = $$props.registrationfaqs);
    		if ('tournamentfaqs' in $$props) $$invalidate(2, tournamentfaqs = $$props.tournamentfaqs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		generalfaqs,
    		registrationfaqs,
    		tournamentfaqs,
    		expand,
    		registrationfaqsopen,
    		tournamentfaqsopen,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5
    	];
    }

    class Faq extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Faq",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src/pages/users/dashboard/profile/Schedule.svelte generated by Svelte v3.41.0 */
    const file$u = "src/pages/users/dashboard/profile/Schedule.svelte";

    // (15:4) {:else}
    function create_else_block$9(ctx) {
    	let div;
    	let t1;
    	let h4;
    	let t2;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Playoffs Round 1";
    			t1 = space();
    			h4 = element("h4");
    			t2 = space();
    			p = element("p");
    			p.textContent = "Playoffs Round 1 will begin soon";
    			attr_dev(div, "class", "survey-txt text-color svelte-1w8xrn");
    			add_location(div, file$u, 15, 8, 416);
    			attr_dev(h4, "class", "mt-2");
    			add_location(h4, file$u, 18, 8, 504);
    			attr_dev(p, "class", "survey-info-txt text-color");
    			add_location(p, file$u, 21, 8, 557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(15:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (8:4) {#if $TeamStore.match_info}
    function create_if_block$g(ctx) {
    	let div;
    	let t0_value = /*$TeamStore*/ ctx[0].stage_name + "";
    	let t0;
    	let t1;
    	let p;
    	let raw_value = /*$TeamStore*/ ctx[0].match_info + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			p = element("p");
    			attr_dev(div, "class", "survey-txt text-color svelte-1w8xrn");
    			add_location(div, file$u, 8, 8, 207);
    			attr_dev(p, "class", "survey-info-txt text-color");
    			add_location(p, file$u, 11, 8, 302);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			p.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 1 && t0_value !== (t0_value = /*$TeamStore*/ ctx[0].stage_name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$TeamStore*/ 1 && raw_value !== (raw_value = /*$TeamStore*/ ctx[0].match_info + "")) p.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(8:4) {#if $TeamStore.match_info}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div;
    	let span;
    	let t1;

    	function select_block_type(ctx, dirty) {
    		if (/*$TeamStore*/ ctx[0].match_info) return create_if_block$g;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Schedule";
    			t1 = space();
    			if_block.c();
    			attr_dev(span, "class", "team-title text-color");
    			add_location(span, file$u, 4, 4, 101);
    			attr_dev(div, "class", "team-box svelte-1w8xrn");
    			add_location(div, file$u, 3, 0, 74);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $TeamStore;
    	validate_store(TeamStore, 'TeamStore');
    	component_subscribe($$self, TeamStore, $$value => $$invalidate(0, $TeamStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Schedule', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Schedule> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ TeamStore, $TeamStore });
    	return [$TeamStore];
    }

    class Schedule extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Schedule",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/pages/users/dashboard/profile/Standings.svelte generated by Svelte v3.41.0 */

    const file$t = "src/pages/users/dashboard/profile/Standings.svelte";

    function create_fragment$v(ctx) {
    	let div1;
    	let span;
    	let t1;
    	let div0;
    	let t3;
    	let p;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			span.textContent = "Standings";
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Leaderboard";
    			t3 = space();
    			p = element("p");
    			p.textContent = "The Leaderboard will be live after the start of the League Stage.";
    			attr_dev(span, "class", "team-title text-color");
    			add_location(span, file$t, 1, 4, 37);
    			attr_dev(div0, "class", "survey-txt text-color svelte-8j9vxt");
    			add_location(div0, file$t, 4, 4, 108);
    			attr_dev(p, "class", "survey-info-txt text-color");
    			add_location(p, file$t, 10, 4, 246);
    			attr_dev(div1, "class", "team-box box-right");
    			add_location(div1, file$t, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div1, t3);
    			append_dev(div1, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Standings', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Standings> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Standings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Standings",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src/pages/users/dashboard/Profile.svelte generated by Svelte v3.41.0 */
    const file$s = "src/pages/users/dashboard/Profile.svelte";

    // (28:0) {#if !hideSurvey}
    function create_if_block$f(ctx) {
    	let div5;
    	let div4;
    	let div2;
    	let div1;
    	let div0;
    	let t;
    	let div3;

    	function select_block_type(ctx, dirty) {
    		if (/*$TeamStore*/ ctx[1].notice) return create_if_block_1$9;
    		if (/*$TeamStore*/ ctx[1].status == 'active' && /*$TeamStore*/ ctx[1].players.length == 4) return create_if_block_2$5;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t = space();
    			div3 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "bg-image");
    			add_location(div0, file$s, 62, 16, 2255);
    			attr_dev(div1, "class", "mobile-bg");
    			add_location(div1, file$s, 61, 12, 2215);
    			attr_dev(div2, "class", "col-lg-6 col-sm-12 col-xs-12 enable-in-mobile");
    			add_location(div2, file$s, 60, 8, 2143);
    			attr_dev(div3, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div3, file$s, 65, 8, 2326);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$s, 59, 4, 2117);
    			attr_dev(div5, "class", "survey-block survey-bg in-game-qualifier");
    			add_location(div5, file$s, 58, 0, 2058);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div4, t);
    			append_dev(div4, div3);
    			if_block.m(div3, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(28:0) {#if !hideSurvey}",
    		ctx
    	});

    	return block;
    }

    // (85:12) {:else}
    function create_else_block$8(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Faild to qualify In game qualifiers";
    			t1 = space();
    			p = element("p");
    			p.textContent = "You did not qualify for the In-Game Qualifiers as you were not a part of a completed team. Good luck for your future events.";
    			attr_dev(div0, "class", "survey-txt");
    			add_location(div0, file$s, 86, 20, 3335);
    			attr_dev(p, "class", "survey-info-txt");
    			add_location(p, file$s, 89, 20, 3467);
    			attr_dev(div1, "class", "bg-cls");
    			add_location(div1, file$s, 85, 16, 3294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, p);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(85:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (76:86) 
    function create_if_block_2$5(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Your team has not qualified to the further stages";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Your team did not qualify to the further phases of the tournament based on your score. Thank you for your participation and good luck for future tournaments.";
    			attr_dev(div0, "class", "survey-txt");
    			add_location(div0, file$s, 77, 20, 2854);
    			attr_dev(p, "class", "survey-info-txt");
    			add_location(p, file$s, 80, 20, 3000);
    			attr_dev(div1, "class", "bg-cls");
    			add_location(div1, file$s, 76, 16, 2813);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, p);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(76:86) ",
    		ctx
    	});

    	return block;
    }

    // (67:12) {#if $TeamStore.notice }
    function create_if_block_1$9(ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*$TeamStore*/ ctx[1].notice_title + "";
    	let t0;
    	let t1;
    	let p;
    	let raw_value = /*$TeamStore*/ ctx[1].notice + "";

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			p = element("p");
    			attr_dev(div0, "class", "survey-txt");
    			add_location(div0, file$s, 68, 20, 2462);
    			attr_dev(p, "class", "survey-info-txt");
    			add_location(p, file$s, 71, 20, 2584);
    			attr_dev(div1, "class", "bg-cls");
    			add_location(div1, file$s, 67, 16, 2421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, p);
    			p.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2 && t0_value !== (t0_value = /*$TeamStore*/ ctx[1].notice_title + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$TeamStore*/ 2 && raw_value !== (raw_value = /*$TeamStore*/ ctx[1].notice + "")) p.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(67:12) {#if $TeamStore.notice }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let t0;
    	let div2;
    	let div0;
    	let schedule;
    	let t1;
    	let div1;
    	let standings;
    	let current;
    	let if_block = !/*hideSurvey*/ ctx[0] && create_if_block$f(ctx);
    	schedule = new Schedule({ $$inline: true });
    	standings = new Standings({ $$inline: true });

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			create_component(schedule.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(standings.$$.fragment);
    			attr_dev(div0, "class", "col-lg-6 col-sm-12 col-xs-12");
    			add_location(div0, file$s, 125, 8, 4663);
    			attr_dev(div1, "class", "col-lg-6 col-sm-12 col-xs-12");
    			add_location(div1, file$s, 128, 8, 4753);
    			attr_dev(div2, "class", "row");
    			add_location(div2, file$s, 124, 4, 4637);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(schedule, div0, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(standings, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*hideSurvey*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(schedule.$$.fragment, local);
    			transition_in(standings.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(schedule.$$.fragment, local);
    			transition_out(standings.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			destroy_component(schedule);
    			destroy_component(standings);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $TeamStore;
    	validate_store(TeamStore, 'TeamStore');
    	component_subscribe($$self, TeamStore, $$value => $$invalidate(1, $TeamStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Profile', slots, []);
    	let { onTeamCreate } = $$props;
    	let { hideSurvey } = $$props;
    	let newTeamName = '';
    	let currentUser = User.getUser();
    	let teamModel = Team.getInstance();
    	let currentTeam;

    	const createTeam = async name => {
    		currentTeam = await teamModel.createTeam({ name });
    		onTeamCreate();
    	};

    	const writable_props = ['onTeamCreate', 'hideSurvey'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Profile> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('onTeamCreate' in $$props) $$invalidate(2, onTeamCreate = $$props.onTeamCreate);
    		if ('hideSurvey' in $$props) $$invalidate(0, hideSurvey = $$props.hideSurvey);
    	};

    	$$self.$capture_state = () => ({
    		InviteModal,
    		FindTeamModal,
    		Modal,
    		User,
    		Team,
    		TeamStore,
    		Schedule,
    		Standings,
    		onTeamCreate,
    		hideSurvey,
    		newTeamName,
    		currentUser,
    		teamModel,
    		currentTeam,
    		createTeam,
    		$TeamStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('onTeamCreate' in $$props) $$invalidate(2, onTeamCreate = $$props.onTeamCreate);
    		if ('hideSurvey' in $$props) $$invalidate(0, hideSurvey = $$props.hideSurvey);
    		if ('newTeamName' in $$props) $$invalidate(3, newTeamName = $$props.newTeamName);
    		if ('currentUser' in $$props) currentUser = $$props.currentUser;
    		if ('teamModel' in $$props) teamModel = $$props.teamModel;
    		if ('currentTeam' in $$props) currentTeam = $$props.currentTeam;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*newTeamName*/ 8) {
    			((() => {
    				let name = newTeamName.replace(/[^A-Za-z0-9 ]/g, '');
    				if (name != newTeamName) $$invalidate(3, newTeamName = name);
    			})());
    		}
    	};

    	return [hideSurvey, $TeamStore, onTeamCreate, newTeamName];
    }

    class Profile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { onTeamCreate: 2, hideSurvey: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Profile",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onTeamCreate*/ ctx[2] === undefined && !('onTeamCreate' in props)) {
    			console.warn("<Profile> was created without expected prop 'onTeamCreate'");
    		}

    		if (/*hideSurvey*/ ctx[0] === undefined && !('hideSurvey' in props)) {
    			console.warn("<Profile> was created without expected prop 'hideSurvey'");
    		}
    	}

    	get onTeamCreate() {
    		throw new Error("<Profile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTeamCreate(value) {
    		throw new Error("<Profile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideSurvey() {
    		throw new Error("<Profile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideSurvey(value) {
    		throw new Error("<Profile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/modal/RequestModal.svelte generated by Svelte v3.41.0 */
    const file$r = "src/components/modal/RequestModal.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (75:0) {:else}
    function create_else_block$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No new request");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(75:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (39:0) {#each requests as request}
    function create_each_block$7(ctx) {
    	let div6;
    	let div4;
    	let div3;
    	let div0;
    	let t0_value = /*request*/ ctx[8].player.first_name + "";
    	let t0;
    	let t1;
    	let t2_value = /*request*/ ctx[8].player.last_name + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*request*/ ctx[8].player.email + "";
    	let t4;
    	let t5;
    	let div2;
    	let t6_value = /*request*/ ctx[8].player.mobile + "";
    	let t6;
    	let t7;
    	let div5;
    	let a0;
    	let span0;
    	let t9;
    	let a1;
    	let span1;
    	let t11;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[4](/*request*/ ctx[8], ...args);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[5](/*request*/ ctx[8], ...args);
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			t2 = text$1(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text$1(t4_value);
    			t5 = space();
    			div2 = element("div");
    			t6 = text$1(t6_value);
    			t7 = space();
    			div5 = element("div");
    			a0 = element("a");
    			span0 = element("span");
    			span0.textContent = "add_circle_outline";
    			t9 = space();
    			a1 = element("a");
    			span1 = element("span");
    			span1.textContent = "highlight_off";
    			t11 = space();
    			attr_dev(div0, "class", "requestie-name");
    			add_location(div0, file$r, 43, 5, 1060);
    			attr_dev(div1, "class", "requestie-mail");
    			add_location(div1, file$r, 46, 5, 1167);
    			attr_dev(div2, "class", "requestie-mail requestie-phone");
    			add_location(div2, file$r, 49, 5, 1242);
    			attr_dev(div3, "class", "");
    			add_location(div3, file$r, 42, 4, 1040);
    			attr_dev(div4, "class", "col-9");
    			add_location(div4, file$r, 41, 3, 1016);
    			attr_dev(span0, "class", "material-icons");
    			add_location(span0, file$r, 60, 4, 1493);
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "add-btn");
    			add_location(a0, file$r, 56, 3, 1389);
    			attr_dev(span1, "class", "material-icons");
    			add_location(span1, file$r, 68, 4, 1673);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "remove-btn");
    			add_location(a1, file$r, 64, 3, 1570);
    			attr_dev(div5, "class", "col-3 text-right");
    			add_location(div5, file$r, 55, 2, 1355);
    			attr_dev(div6, "class", "row no-gutters requestie-details");
    			add_location(div6, file$r, 39, 1, 963);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, t6);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			append_dev(div5, a0);
    			append_dev(a0, span0);
    			append_dev(div5, t9);
    			append_dev(div5, a1);
    			append_dev(a1, span1);
    			append_dev(div6, t11);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", click_handler, false, false, false),
    					listen_dev(a1, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*requests*/ 1 && t0_value !== (t0_value = /*request*/ ctx[8].player.first_name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*requests*/ 1 && t2_value !== (t2_value = /*request*/ ctx[8].player.last_name + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*requests*/ 1 && t4_value !== (t4_value = /*request*/ ctx[8].player.email + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*requests*/ 1 && t6_value !== (t6_value = /*request*/ ctx[8].player.mobile + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(39:0) {#each requests as request}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div;
    	let h2;
    	let t0_value = /*$TeamStore*/ ctx[1].newRequests + "";
    	let t0;
    	let t1;
    	let t2;
    	let small;
    	let t4;
    	let each_1_anchor;
    	let each_value = /*requests*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block$7(ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			t0 = text$1(t0_value);
    			t1 = text$1(" New Requests");
    			t2 = space();
    			small = element("small");
    			small.textContent = "You received below requests from players who wish to join your team.";
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$r, 31, 1, 739);
    			attr_dev(small, "class", "request-info-txt");
    			add_location(small, file$r, 34, 1, 812);
    			attr_dev(div, "class", "svelte-modal-header");
    			add_location(div, file$r, 30, 0, 704);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(h2, t0);
    			append_dev(h2, t1);
    			append_dev(div, t2);
    			append_dev(div, small);
    			insert_dev(target, t4, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$TeamStore*/ 2 && t0_value !== (t0_value = /*$TeamStore*/ ctx[1].newRequests + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*reject, requests, approve*/ 13) {
    				each_value = /*requests*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;

    				if (each_value.length) {
    					if (each_1_else) {
    						each_1_else.d(1);
    						each_1_else = null;
    					}
    				} else if (!each_1_else) {
    					each_1_else = create_else_block$7(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t4);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $TeamStore;
    	validate_store(TeamStore, 'TeamStore');
    	component_subscribe($$self, TeamStore, $$value => $$invalidate(1, $TeamStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RequestModal', slots, []);
    	const teamModel = Team.getInstance();
    	let requests = [];

    	const getRequests = () => {
    		teamModel.getRequests().then(r => {
    			$$invalidate(0, requests = r);
    		});
    	};

    	getRequests();

    	const approve = async request => {
    		let res = await teamModel.approveRequest(request);

    		if (!res.error) {
    			getRequests();
    			teamModel.getTeam();
    			notyf.success('Request accepted!');
    		}
    	};

    	const reject = async request => {
    		let res = await teamModel.rejectRequest(request);

    		if (!res.error) {
    			getRequests();
    			teamModel.getTeam();
    			notyf.success('Request rejected!');
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RequestModal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (request, e) => {
    		e.preventDefault();
    		approve(request);
    	};

    	const click_handler_1 = (request, e) => {
    		e.preventDefault();
    		reject(request);
    	};

    	$$self.$capture_state = () => ({
    		TeamStore,
    		Team,
    		teamModel,
    		toast: notyf,
    		requests,
    		getRequests,
    		approve,
    		reject,
    		$TeamStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('requests' in $$props) $$invalidate(0, requests = $$props.requests);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [requests, $TeamStore, approve, reject, click_handler, click_handler_1];
    }

    class RequestModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RequestModal",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src/components/modal/DeleteModal.svelte generated by Svelte v3.41.0 */
    const file$q = "src/components/modal/DeleteModal.svelte";

    // (22:1) {#if !$Modal.props.hideCancel}
    function create_if_block$e(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Cancel";
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "btn cancel-btn");
    			add_location(a, file$q, 22, 1, 526);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_1*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(22:1) {#if !$Modal.props.hideCancel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div0;
    	let h2;

    	let t0_value = (/*$Modal*/ ctx[0].props.title
    	? /*$Modal*/ ctx[0].props.title
    	: 'Are you sure?') + "";

    	let t0;
    	let t1;
    	let small;
    	let t2_value = /*$Modal*/ ctx[0].props.content + "";
    	let t2;
    	let t3;
    	let div1;
    	let span;
    	let t5;
    	let div2;
    	let button;
    	let t6_value = /*$Modal*/ ctx[0].props.btnText + "";
    	let t6;
    	let t7;
    	let mounted;
    	let dispose;
    	let if_block = !/*$Modal*/ ctx[0].props.hideCancel && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text$1(t0_value);
    			t1 = space();
    			small = element("small");
    			t2 = text$1(t2_value);
    			t3 = space();
    			div1 = element("div");
    			span = element("span");
    			span.textContent = "star_border";
    			t5 = space();
    			div2 = element("div");
    			button = element("button");
    			t6 = text$1(t6_value);
    			t7 = space();
    			if (if_block) if_block.c();
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$q, 4, 1, 97);
    			attr_dev(small, "class", "request-info-txt");
    			add_location(small, file$q, 7, 1, 192);
    			attr_dev(div0, "class", "svelte-modal-header");
    			add_location(div0, file$q, 3, 0, 62);
    			attr_dev(span, "class", "material-icons svelte-1w7jh2w");
    			add_location(span, file$q, 12, 1, 290);
    			attr_dev(div1, "class", "bg-icon svelte-1w7jh2w");
    			add_location(div1, file$q, 11, 0, 267);
    			attr_dev(button, "class", "btn btn-primary");
    			add_location(button, file$q, 17, 1, 377);
    			attr_dev(div2, "class", "btn-section");
    			add_location(div2, file$q, 16, 0, 350);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(div0, t1);
    			append_dev(div0, small);
    			append_dev(small, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(button, t6);
    			append_dev(div2, t7);
    			if (if_block) if_block.m(div2, null);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$Modal*/ 1 && t0_value !== (t0_value = (/*$Modal*/ ctx[0].props.title
    			? /*$Modal*/ ctx[0].props.title
    			: 'Are you sure?') + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$Modal*/ 1 && t2_value !== (t2_value = /*$Modal*/ ctx[0].props.content + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$Modal*/ 1 && t6_value !== (t6_value = /*$Modal*/ ctx[0].props.btnText + "")) set_data_dev(t6, t6_value);

    			if (!/*$Modal*/ ctx[0].props.hideCancel) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $Modal;
    	validate_store(Modal, 'Modal');
    	component_subscribe($$self, Modal, $$value => $$invalidate(0, $Modal = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DeleteModal', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DeleteModal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		if ($Modal.cb) $Modal.cb();
    	};

    	const click_handler_1 = e => {
    		Modal.close();
    	};

    	$$self.$capture_state = () => ({ Modal, $Modal });
    	return [$Modal, click_handler, click_handler_1];
    }

    class DeleteModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeleteModal",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/utils/Clipboard.svelte generated by Svelte v3.41.0 */
    const file$p = "src/utils/Clipboard.svelte";

    function create_fragment$r(ctx) {
    	let textarea_1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea_1 = element("textarea");
    			add_location(textarea_1, file$p, 14, 0, 220);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea_1, anchor);
    			set_input_value(textarea_1, /*name*/ ctx[0]);
    			/*textarea_1_binding*/ ctx[3](textarea_1);

    			if (!mounted) {
    				dispose = listen_dev(textarea_1, "input", /*textarea_1_input_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 1) {
    				set_input_value(textarea_1, /*name*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea_1);
    			/*textarea_1_binding*/ ctx[3](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Clipboard', slots, []);
    	let { name } = $$props;
    	let textarea;

    	onMount(() => {
    		textarea.select();
    		textarea.setSelectionRange(0, 99999);
    		document.execCommand('copy');
    	});

    	const writable_props = ['name'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Clipboard> was created with unknown prop '${key}'`);
    	});

    	function textarea_1_input_handler() {
    		name = this.value;
    		$$invalidate(0, name);
    	}

    	function textarea_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textarea = $$value;
    			$$invalidate(1, textarea);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    	};

    	$$self.$capture_state = () => ({ onMount, name, textarea });

    	$$self.$inject_state = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('textarea' in $$props) $$invalidate(1, textarea = $$props.textarea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [name, textarea, textarea_1_input_handler, textarea_1_binding];
    }

    class Clipboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { name: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Clipboard",
    			options,
    			id: create_fragment$r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[0] === undefined && !('name' in props)) {
    			console.warn("<Clipboard> was created without expected prop 'name'");
    		}
    	}

    	get name() {
    		throw new Error("<Clipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Clipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-tags-input/src/Tags.svelte generated by Svelte v3.41.0 */

    const { console: console_1$3 } = globals;
    const file$o = "node_modules/svelte-tags-input/src/Tags.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	child_ctx[39] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[41] = i;
    	return child_ctx;
    }

    // (309:4) {#if tags.length > 0}
    function create_if_block_1$8(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*tags*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*removeTag, disable, tags, autoCompleteKey*/ 2121) {
    				each_value_1 = /*tags*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(309:4) {#if tags.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (314:16) {:else}
    function create_else_block$6(ctx) {
    	let t_value = /*tag*/ ctx[8][/*autoCompleteKey*/ ctx[3]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tags, autoCompleteKey*/ 9 && t_value !== (t_value = /*tag*/ ctx[8][/*autoCompleteKey*/ ctx[3]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(314:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (312:16) {#if typeof tag === 'string'}
    function create_if_block_3$2(ctx) {
    	let t_value = /*tag*/ ctx[8] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tags*/ 1 && t_value !== (t_value = /*tag*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(312:16) {#if typeof tag === 'string'}",
    		ctx
    	});

    	return block;
    }

    // (317:16) {#if !disable}
    function create_if_block_2$4(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[27](/*i*/ ctx[41]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "×";
    			attr_dev(span, "class", "svelte-tags-input-tag-remove svelte-1s4blrc");
    			add_location(span, file$o, 317, 16, 9118);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(317:16) {#if !disable}",
    		ctx
    	});

    	return block;
    }

    // (310:8) {#each tags as tag, i}
    function create_each_block_1$4(ctx) {
    	let span;
    	let t0;
    	let t1;

    	function select_block_type(ctx, dirty) {
    		if (typeof /*tag*/ ctx[8] === 'string') return create_if_block_3$2;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*disable*/ ctx[6] && create_if_block_2$4(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			attr_dev(span, "class", "svelte-tags-input-tag svelte-1s4blrc");
    			add_location(span, file$o, 310, 12, 8866);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if_block0.m(span, null);
    			append_dev(span, t0);
    			if (if_block1) if_block1.m(span, null);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span, t0);
    				}
    			}

    			if (!/*disable*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$4(ctx);
    					if_block1.c();
    					if_block1.m(span, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(310:8) {#each tags as tag, i}",
    		ctx
    	});

    	return block;
    }

    // (339:0) {#if autoComplete && arrelementsmatch.length > 0}
    function create_if_block$d(ctx) {
    	let div;
    	let ul;
    	let ul_id_value;
    	let each_value = /*arrelementsmatch*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "id", ul_id_value = "" + (/*id*/ ctx[5] + "_matchs"));
    			attr_dev(ul, "class", "svelte-tags-input-matchs svelte-1s4blrc");
    			add_location(ul, file$o, 340, 8, 9758);
    			attr_dev(div, "class", "svelte-tags-input-matchs-parent svelte-1s4blrc");
    			add_location(div, file$o, 339, 4, 9703);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*navigateAutoComplete, arrelementsmatch, addTag*/ 66688) {
    				each_value = /*arrelementsmatch*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*id*/ 32 && ul_id_value !== (ul_id_value = "" + (/*id*/ ctx[5] + "_matchs"))) {
    				attr_dev(ul, "id", ul_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(339:0) {#if autoComplete && arrelementsmatch.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (342:12) {#each arrelementsmatch as element, index}
    function create_each_block$6(ctx) {
    	let li;
    	let html_tag;
    	let raw_value = /*element*/ ctx[37].search + "";
    	let t;
    	let mounted;
    	let dispose;

    	function keydown_handler() {
    		return /*keydown_handler*/ ctx[30](/*index*/ ctx[39], /*element*/ ctx[37]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[31](/*element*/ ctx[37]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			html_tag = new HtmlTag();
    			t = space();
    			html_tag.a = t;
    			attr_dev(li, "tabindex", "-1");
    			attr_dev(li, "class", "svelte-1s4blrc");
    			add_location(li, file$o, 342, 16, 9886);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			html_tag.m(raw_value, li);
    			append_dev(li, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "keydown", keydown_handler, false, false, false),
    					listen_dev(li, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*arrelementsmatch*/ 128 && raw_value !== (raw_value = /*element*/ ctx[37].search + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(342:12) {#each arrelementsmatch as element, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div;
    	let t0;
    	let input;
    	let t1;
    	let if_block1_anchor;
    	let mounted;
    	let dispose;
    	let if_block0 = /*tags*/ ctx[0].length > 0 && create_if_block_1$8(ctx);
    	let if_block1 = /*autoComplete*/ ctx[2] && /*arrelementsmatch*/ ctx[7].length > 0 && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			input = element("input");
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", /*name*/ ctx[4]);
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
    			attr_dev(input, "id", /*id*/ ctx[5]);
    			attr_dev(input, "class", "svelte-tags-input svelte-1s4blrc");
    			input.disabled = /*disable*/ ctx[6];
    			add_location(input, file$o, 322, 4, 9283);
    			attr_dev(div, "class", "svelte-tags-input-layout svelte-1s4blrc");
    			toggle_class(div, "sti-layout-disable", /*disable*/ ctx[6]);
    			add_location(div, file$o, 307, 0, 8720);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, input);
    			set_input_value(input, /*tag*/ ctx[8]);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[28]),
    					listen_dev(input, "keydown", /*setTag*/ ctx[9], false, false, false),
    					listen_dev(input, "keyup", /*getMatchElements*/ ctx[15], false, false, false),
    					listen_dev(input, "paste", /*onPaste*/ ctx[12], false, false, false),
    					listen_dev(input, "drop", /*onDrop*/ ctx[13], false, false, false),
    					listen_dev(input, "blur", /*blur_handler*/ ctx[29], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*tags*/ ctx[0].length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$8(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*name*/ 16) {
    				attr_dev(input, "name", /*name*/ ctx[4]);
    			}

    			if (dirty[0] & /*placeholder*/ 2) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
    			}

    			if (dirty[0] & /*id*/ 32) {
    				attr_dev(input, "id", /*id*/ ctx[5]);
    			}

    			if (dirty[0] & /*disable*/ 64) {
    				prop_dev(input, "disabled", /*disable*/ ctx[6]);
    			}

    			if (dirty[0] & /*tag*/ 256 && input.value !== /*tag*/ ctx[8]) {
    				set_input_value(input, /*tag*/ ctx[8]);
    			}

    			if (dirty[0] & /*disable*/ 64) {
    				toggle_class(div, "sti-layout-disable", /*disable*/ ctx[6]);
    			}

    			if (/*autoComplete*/ ctx[2] && /*arrelementsmatch*/ ctx[7].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$d(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getClipboardData(e) {
    	if (window.clipboardData) {
    		return window.clipboardData.getData('Text');
    	}

    	if (e.clipboardData) {
    		return e.clipboardData.getData('text/plain');
    	}

    	return '';
    }

    function uniqueID() {
    	return 'sti_' + Math.random().toString(36).substr(2, 9);
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let matchsID;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tags', slots, []);
    	const dispatch = createEventDispatcher();
    	let tag = "";
    	let arrelementsmatch = [];

    	let regExpEscape = s => {
    		return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
    	};

    	let { tags } = $$props;
    	let { addKeys } = $$props;
    	let { maxTags } = $$props;
    	let { onlyUnique } = $$props;
    	let { removeKeys } = $$props;
    	let { placeholder } = $$props;
    	let { allowPaste } = $$props;
    	let { allowDrop } = $$props;
    	let { splitWith } = $$props;
    	let { autoComplete } = $$props;
    	let { autoCompleteKey } = $$props;
    	let { name } = $$props;
    	let { id } = $$props;
    	let { allowBlur } = $$props;
    	let { disable } = $$props;
    	let { minChars } = $$props;
    	let { onlyAutocomplete } = $$props;
    	let storePlaceholder = placeholder;

    	function setTag(input) {
    		const currentTag = input.target.value;

    		if (addKeys) {
    			addKeys.forEach(function (key) {
    				if (key === input.keyCode) {
    					if (currentTag) input.preventDefault();

    					switch (input.keyCode) {
    						case 9:
    							// TAB add first element on the autoComplete list
    							if (autoComplete && document.getElementById(matchsID)) {
    								addTag(document.getElementById(matchsID).querySelectorAll("li")[0].textContent);
    							} else {
    								addTag(currentTag);
    							}
    							break;
    						default:
    							addTag(currentTag);
    							break;
    					}
    				}
    			});
    		}

    		if (removeKeys) {
    			removeKeys.forEach(function (key) {
    				if (key === input.keyCode && tag === "") {
    					tags.pop();
    					$$invalidate(0, tags);
    					dispatch('tags', { tags });
    					$$invalidate(7, arrelementsmatch = []);
    					document.getElementById(id).readOnly = false;
    					$$invalidate(1, placeholder = storePlaceholder);
    					document.getElementById(id).focus();
    				}
    			});
    		}

    		// ArrowDown : focus on first element of the autocomplete
    		if (input.keyCode === 40 && autoComplete && document.getElementById(matchsID)) {
    			event.preventDefault();
    			document.getElementById(matchsID).querySelector("li:first-child").focus();
    		} else if (input.keyCode === 38 && autoComplete && document.getElementById(matchsID)) {
    			event.preventDefault(); // ArrowUp : focus on last element of the autocomplete
    			document.getElementById(matchsID).querySelector("li:last-child").focus();
    		}
    	}

    	function addTag(currentTag) {
    		if (typeof currentTag === 'object' && currentTag !== null) {
    			if (!autoCompleteKey) {
    				return console.error("'autoCompleteKey' is necessary if 'autoComplete' result is an array of objects");
    			}

    			var currentObjTags = currentTag;
    			currentTag = currentTag[autoCompleteKey].trim();
    		} else {
    			currentTag = currentTag.trim();
    		}

    		if (currentTag == "") return;
    		if (maxTags && tags.length == maxTags) return;
    		if (onlyUnique && tags.includes(currentTag)) return;
    		if (onlyAutocomplete && arrelementsmatch.length === 0) return;
    		tags.push(currentObjTags ? currentObjTags : currentTag);
    		$$invalidate(0, tags);
    		$$invalidate(8, tag = "");
    		dispatch('tags', { tags });

    		// Hide autocomplete list
    		// Focus on svelte tags input
    		$$invalidate(7, arrelementsmatch = []);

    		document.getElementById(id).focus();

    		if (maxTags && tags.length == maxTags) {
    			document.getElementById(id).readOnly = true;
    			$$invalidate(1, placeholder = "");
    		}

    		
    	}

    	function removeTag(i) {
    		tags.splice(i, 1);
    		$$invalidate(0, tags);
    		dispatch('tags', { tags });

    		// Hide autocomplete list
    		// Focus on svelte tags input
    		$$invalidate(7, arrelementsmatch = []);

    		document.getElementById(id).readOnly = false;
    		$$invalidate(1, placeholder = storePlaceholder);
    		document.getElementById(id).focus();
    	}

    	function onPaste(e) {
    		if (!allowPaste) return;
    		e.preventDefault();
    		const data = getClipboardData(e);
    		splitTags(data).map(tag => addTag(tag));
    	}

    	function onDrop(e) {
    		if (!allowDrop) return;
    		e.preventDefault();
    		const data = e.dataTransfer.getData("Text");
    		splitTags(data).map(tag => addTag(tag));
    	}

    	function onBlur(tag) {
    		if (!document.getElementById(matchsID) && allowBlur) {
    			event.preventDefault();
    			addTag(tag);
    		}
    	}

    	function splitTags(data) {
    		return data.split(splitWith).map(tag => tag.trim());
    	}

    	async function getMatchElements(input) {
    		if (!autoComplete) return;
    		let autoCompleteValues = [];

    		if (Array.isArray(autoComplete)) {
    			autoCompleteValues = autoComplete;
    		}

    		if (typeof autoComplete === 'function') {
    			if (autoComplete.constructor.name === 'AsyncFunction') {
    				autoCompleteValues = await autoComplete();
    			} else {
    				autoCompleteValues = autoComplete();
    			}
    		}

    		var value = input.target.value;

    		// Escape
    		if (value == "" || input.keyCode === 27 || value.length < minChars) {
    			$$invalidate(7, arrelementsmatch = []);
    			return;
    		}

    		if (typeof autoCompleteValues[0] === 'object' && autoCompleteValues !== null) {
    			if (!autoCompleteKey) {
    				return console.error("'autoCompleteValue' is necessary if 'autoComplete' result is an array of objects");
    			}

    			var matchs = autoCompleteValues.filter(e => e[autoCompleteKey].toLowerCase().includes(value.toLowerCase())).map(matchTag => {
    				return {
    					label: matchTag,
    					search: matchTag[autoCompleteKey].replace(RegExp(regExpEscape(value.toLowerCase()), 'i'), "<strong>$&</strong>")
    				};
    			});
    		} else {
    			var matchs = autoCompleteValues.filter(e => e.toLowerCase().includes(value.toLowerCase())).map(matchTag => {
    				return {
    					label: matchTag,
    					search: matchTag.replace(RegExp(regExpEscape(value.toLowerCase()), 'i'), "<strong>$&</strong>")
    				};
    			});
    		}

    		if (onlyUnique === true && !autoCompleteKey) {
    			matchs = matchs.filter(tag => !tags.includes(tag.label));
    		}

    		$$invalidate(7, arrelementsmatch = matchs);
    	}

    	function navigateAutoComplete(autoCompleteIndex, autoCompleteLength, autoCompleteElement) {
    		if (!autoComplete) return;
    		event.preventDefault();

    		// ArrowDown
    		if (event.keyCode === 40) {
    			// Last element on the list ? Go to the first
    			if (autoCompleteIndex + 1 === autoCompleteLength) {
    				document.getElementById(matchsID).querySelector("li:first-child").focus();
    				return;
    			}

    			document.getElementById(matchsID).querySelectorAll("li")[autoCompleteIndex + 1].focus();
    		} else if (event.keyCode === 38) {
    			// ArrowUp
    			// First element on the list ? Go to the last
    			if (autoCompleteIndex === 0) {
    				document.getElementById(matchsID).querySelector("li:last-child").focus();
    				return;
    			}

    			document.getElementById(matchsID).querySelectorAll("li")[autoCompleteIndex - 1].focus();
    		} else if (event.keyCode === 13) {
    			// Enter
    			addTag(autoCompleteElement);
    		} else if (event.keyCode === 27) {
    			// Escape
    			$$invalidate(7, arrelementsmatch = []);

    			document.getElementById(id).focus();
    		}
    	}

    	

    	const writable_props = [
    		'tags',
    		'addKeys',
    		'maxTags',
    		'onlyUnique',
    		'removeKeys',
    		'placeholder',
    		'allowPaste',
    		'allowDrop',
    		'splitWith',
    		'autoComplete',
    		'autoCompleteKey',
    		'name',
    		'id',
    		'allowBlur',
    		'disable',
    		'minChars',
    		'onlyAutocomplete'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Tags> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => removeTag(i);

    	function input_input_handler() {
    		tag = this.value;
    		$$invalidate(8, tag);
    	}

    	const blur_handler = () => onBlur(tag);
    	const keydown_handler = (index, element) => navigateAutoComplete(index, arrelementsmatch.length, element.label);
    	const click_handler_1 = element => addTag(element.label);

    	$$self.$$set = $$props => {
    		if ('tags' in $$props) $$invalidate(0, tags = $$props.tags);
    		if ('addKeys' in $$props) $$invalidate(17, addKeys = $$props.addKeys);
    		if ('maxTags' in $$props) $$invalidate(18, maxTags = $$props.maxTags);
    		if ('onlyUnique' in $$props) $$invalidate(19, onlyUnique = $$props.onlyUnique);
    		if ('removeKeys' in $$props) $$invalidate(20, removeKeys = $$props.removeKeys);
    		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
    		if ('allowPaste' in $$props) $$invalidate(21, allowPaste = $$props.allowPaste);
    		if ('allowDrop' in $$props) $$invalidate(22, allowDrop = $$props.allowDrop);
    		if ('splitWith' in $$props) $$invalidate(23, splitWith = $$props.splitWith);
    		if ('autoComplete' in $$props) $$invalidate(2, autoComplete = $$props.autoComplete);
    		if ('autoCompleteKey' in $$props) $$invalidate(3, autoCompleteKey = $$props.autoCompleteKey);
    		if ('name' in $$props) $$invalidate(4, name = $$props.name);
    		if ('id' in $$props) $$invalidate(5, id = $$props.id);
    		if ('allowBlur' in $$props) $$invalidate(24, allowBlur = $$props.allowBlur);
    		if ('disable' in $$props) $$invalidate(6, disable = $$props.disable);
    		if ('minChars' in $$props) $$invalidate(25, minChars = $$props.minChars);
    		if ('onlyAutocomplete' in $$props) $$invalidate(26, onlyAutocomplete = $$props.onlyAutocomplete);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		tag,
    		arrelementsmatch,
    		regExpEscape,
    		tags,
    		addKeys,
    		maxTags,
    		onlyUnique,
    		removeKeys,
    		placeholder,
    		allowPaste,
    		allowDrop,
    		splitWith,
    		autoComplete,
    		autoCompleteKey,
    		name,
    		id,
    		allowBlur,
    		disable,
    		minChars,
    		onlyAutocomplete,
    		storePlaceholder,
    		setTag,
    		addTag,
    		removeTag,
    		onPaste,
    		onDrop,
    		onBlur,
    		getClipboardData,
    		splitTags,
    		getMatchElements,
    		navigateAutoComplete,
    		uniqueID,
    		matchsID
    	});

    	$$self.$inject_state = $$props => {
    		if ('tag' in $$props) $$invalidate(8, tag = $$props.tag);
    		if ('arrelementsmatch' in $$props) $$invalidate(7, arrelementsmatch = $$props.arrelementsmatch);
    		if ('regExpEscape' in $$props) regExpEscape = $$props.regExpEscape;
    		if ('tags' in $$props) $$invalidate(0, tags = $$props.tags);
    		if ('addKeys' in $$props) $$invalidate(17, addKeys = $$props.addKeys);
    		if ('maxTags' in $$props) $$invalidate(18, maxTags = $$props.maxTags);
    		if ('onlyUnique' in $$props) $$invalidate(19, onlyUnique = $$props.onlyUnique);
    		if ('removeKeys' in $$props) $$invalidate(20, removeKeys = $$props.removeKeys);
    		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
    		if ('allowPaste' in $$props) $$invalidate(21, allowPaste = $$props.allowPaste);
    		if ('allowDrop' in $$props) $$invalidate(22, allowDrop = $$props.allowDrop);
    		if ('splitWith' in $$props) $$invalidate(23, splitWith = $$props.splitWith);
    		if ('autoComplete' in $$props) $$invalidate(2, autoComplete = $$props.autoComplete);
    		if ('autoCompleteKey' in $$props) $$invalidate(3, autoCompleteKey = $$props.autoCompleteKey);
    		if ('name' in $$props) $$invalidate(4, name = $$props.name);
    		if ('id' in $$props) $$invalidate(5, id = $$props.id);
    		if ('allowBlur' in $$props) $$invalidate(24, allowBlur = $$props.allowBlur);
    		if ('disable' in $$props) $$invalidate(6, disable = $$props.disable);
    		if ('minChars' in $$props) $$invalidate(25, minChars = $$props.minChars);
    		if ('onlyAutocomplete' in $$props) $$invalidate(26, onlyAutocomplete = $$props.onlyAutocomplete);
    		if ('storePlaceholder' in $$props) storePlaceholder = $$props.storePlaceholder;
    		if ('matchsID' in $$props) matchsID = $$props.matchsID;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*tags*/ 1) {
    			$$invalidate(0, tags = tags || []);
    		}

    		if ($$self.$$.dirty[0] & /*addKeys*/ 131072) {
    			$$invalidate(17, addKeys = addKeys || [13]);
    		}

    		if ($$self.$$.dirty[0] & /*maxTags*/ 262144) {
    			$$invalidate(18, maxTags = maxTags || false);
    		}

    		if ($$self.$$.dirty[0] & /*onlyUnique*/ 524288) {
    			$$invalidate(19, onlyUnique = onlyUnique || false);
    		}

    		if ($$self.$$.dirty[0] & /*removeKeys*/ 1048576) {
    			$$invalidate(20, removeKeys = removeKeys || [8]);
    		}

    		if ($$self.$$.dirty[0] & /*placeholder*/ 2) {
    			$$invalidate(1, placeholder = placeholder || "");
    		}

    		if ($$self.$$.dirty[0] & /*allowPaste*/ 2097152) {
    			$$invalidate(21, allowPaste = allowPaste || false);
    		}

    		if ($$self.$$.dirty[0] & /*allowDrop*/ 4194304) {
    			$$invalidate(22, allowDrop = allowDrop || false);
    		}

    		if ($$self.$$.dirty[0] & /*splitWith*/ 8388608) {
    			$$invalidate(23, splitWith = splitWith || ",");
    		}

    		if ($$self.$$.dirty[0] & /*autoComplete*/ 4) {
    			$$invalidate(2, autoComplete = autoComplete || false);
    		}

    		if ($$self.$$.dirty[0] & /*autoCompleteKey*/ 8) {
    			$$invalidate(3, autoCompleteKey = autoCompleteKey || false);
    		}

    		if ($$self.$$.dirty[0] & /*name*/ 16) {
    			$$invalidate(4, name = name || "svelte-tags-input");
    		}

    		if ($$self.$$.dirty[0] & /*id*/ 32) {
    			$$invalidate(5, id = id || uniqueID());
    		}

    		if ($$self.$$.dirty[0] & /*allowBlur*/ 16777216) {
    			$$invalidate(24, allowBlur = allowBlur || false);
    		}

    		if ($$self.$$.dirty[0] & /*disable*/ 64) {
    			$$invalidate(6, disable = disable || false);
    		}

    		if ($$self.$$.dirty[0] & /*minChars*/ 33554432) {
    			$$invalidate(25, minChars = minChars || 1);
    		}

    		if ($$self.$$.dirty[0] & /*onlyAutocomplete*/ 67108864) {
    			$$invalidate(26, onlyAutocomplete = onlyAutocomplete || false);
    		}

    		if ($$self.$$.dirty[0] & /*id*/ 32) {
    			matchsID = id + "_matchs";
    		}
    	};

    	return [
    		tags,
    		placeholder,
    		autoComplete,
    		autoCompleteKey,
    		name,
    		id,
    		disable,
    		arrelementsmatch,
    		tag,
    		setTag,
    		addTag,
    		removeTag,
    		onPaste,
    		onDrop,
    		onBlur,
    		getMatchElements,
    		navigateAutoComplete,
    		addKeys,
    		maxTags,
    		onlyUnique,
    		removeKeys,
    		allowPaste,
    		allowDrop,
    		splitWith,
    		allowBlur,
    		minChars,
    		onlyAutocomplete,
    		click_handler,
    		input_input_handler,
    		blur_handler,
    		keydown_handler,
    		click_handler_1
    	];
    }

    class Tags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$q,
    			create_fragment$q,
    			safe_not_equal,
    			{
    				tags: 0,
    				addKeys: 17,
    				maxTags: 18,
    				onlyUnique: 19,
    				removeKeys: 20,
    				placeholder: 1,
    				allowPaste: 21,
    				allowDrop: 22,
    				splitWith: 23,
    				autoComplete: 2,
    				autoCompleteKey: 3,
    				name: 4,
    				id: 5,
    				allowBlur: 24,
    				disable: 6,
    				minChars: 25,
    				onlyAutocomplete: 26
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tags",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tags*/ ctx[0] === undefined && !('tags' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'tags'");
    		}

    		if (/*addKeys*/ ctx[17] === undefined && !('addKeys' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'addKeys'");
    		}

    		if (/*maxTags*/ ctx[18] === undefined && !('maxTags' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'maxTags'");
    		}

    		if (/*onlyUnique*/ ctx[19] === undefined && !('onlyUnique' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'onlyUnique'");
    		}

    		if (/*removeKeys*/ ctx[20] === undefined && !('removeKeys' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'removeKeys'");
    		}

    		if (/*placeholder*/ ctx[1] === undefined && !('placeholder' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'placeholder'");
    		}

    		if (/*allowPaste*/ ctx[21] === undefined && !('allowPaste' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'allowPaste'");
    		}

    		if (/*allowDrop*/ ctx[22] === undefined && !('allowDrop' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'allowDrop'");
    		}

    		if (/*splitWith*/ ctx[23] === undefined && !('splitWith' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'splitWith'");
    		}

    		if (/*autoComplete*/ ctx[2] === undefined && !('autoComplete' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'autoComplete'");
    		}

    		if (/*autoCompleteKey*/ ctx[3] === undefined && !('autoCompleteKey' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'autoCompleteKey'");
    		}

    		if (/*name*/ ctx[4] === undefined && !('name' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'name'");
    		}

    		if (/*id*/ ctx[5] === undefined && !('id' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'id'");
    		}

    		if (/*allowBlur*/ ctx[24] === undefined && !('allowBlur' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'allowBlur'");
    		}

    		if (/*disable*/ ctx[6] === undefined && !('disable' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'disable'");
    		}

    		if (/*minChars*/ ctx[25] === undefined && !('minChars' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'minChars'");
    		}

    		if (/*onlyAutocomplete*/ ctx[26] === undefined && !('onlyAutocomplete' in props)) {
    			console_1$3.warn("<Tags> was created without expected prop 'onlyAutocomplete'");
    		}
    	}

    	get tags() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tags(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addKeys() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addKeys(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxTags() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxTags(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onlyUnique() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onlyUnique(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get removeKeys() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set removeKeys(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowPaste() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowPaste(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowDrop() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowDrop(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get splitWith() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set splitWith(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoComplete() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoComplete(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoCompleteKey() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoCompleteKey(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowBlur() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowBlur(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disable() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disable(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minChars() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minChars(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onlyAutocomplete() {
    		throw new Error("<Tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onlyAutocomplete(value) {
    		throw new Error("<Tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/modal/TeamInviteModal.svelte generated by Svelte v3.41.0 */
    const file$n = "src/components/modal/TeamInviteModal.svelte";

    function create_fragment$p(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let h2;
    	let t2;
    	let small0;
    	let t4;
    	let div2;
    	let span0;
    	let t6;
    	let div5;
    	let div4;
    	let div3;
    	let t7_value = /*$TeamStore*/ ctx[1].code + "";
    	let t7;
    	let t8;
    	let a;
    	let span1;
    	let t10;
    	let small1;
    	let t12;
    	let div6;
    	let tags;
    	let updating_tags;
    	let t13;
    	let div7;
    	let button;
    	let t14;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	function tags_tags_binding(value) {
    		/*tags_tags_binding*/ ctx[5](value);
    	}

    	let tags_props = {
    		onlyUnique: true,
    		allowBlur: true,
    		class: "text-box",
    		placeholder: "Email address",
    		name: "emails",
    		addKeys: [9, 13, 32, 188]
    	};

    	if (/*emails*/ ctx[0] !== void 0) {
    		tags_props.tags = /*emails*/ ctx[0];
    	}

    	tags = new Tags({ props: tags_props, $$inline: true });
    	binding_callbacks.push(() => bind(tags, 'tags', tags_tags_binding));
    	tags.$on("tags", /*onTags*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Invite players to your team";
    			t2 = space();
    			small0 = element("small");
    			small0.textContent = "Copy the below code and share it with your friends to invite them into your team.";
    			t4 = space();
    			div2 = element("div");
    			span0 = element("span");
    			span0.textContent = "star_border";
    			t6 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			t7 = text$1(t7_value);
    			t8 = space();
    			a = element("a");
    			span1 = element("span");
    			span1.textContent = "library_books";
    			t10 = space();
    			small1 = element("small");
    			small1.textContent = "Alternatively, add email addresses of friends below and we will email them your invite.";
    			t12 = space();
    			div6 = element("div");
    			create_component(tags.$$.fragment);
    			t13 = space();
    			div7 = element("div");
    			button = element("button");
    			t14 = text$1("Send Invites");
    			attr_dev(div0, "id", "clipboard");
    			add_location(div0, file$n, 41, 0, 980);
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$n, 43, 1, 1042);
    			attr_dev(small0, "class", "request-info-txt svelte-h13j00");
    			add_location(small0, file$n, 46, 1, 1105);
    			attr_dev(div1, "class", "svelte-modal-header svelte-h13j00");
    			add_location(div1, file$n, 42, 0, 1007);
    			attr_dev(span0, "class", "material-icons svelte-h13j00");
    			add_location(span0, file$n, 51, 1, 1264);
    			attr_dev(div2, "class", "bg-icon svelte-h13j00");
    			add_location(div2, file$n, 50, 0, 1241);
    			attr_dev(span1, "class", "material-icons svelte-h13j00");
    			add_location(span1, file$n, 60, 4, 1487);
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "copy-code svelte-h13j00");
    			add_location(a, file$n, 59, 3, 1436);
    			attr_dev(div3, "class", "invitation-code");
    			add_location(div3, file$n, 57, 2, 1382);
    			attr_dev(div4, "class", "col-12 mt-3");
    			add_location(div4, file$n, 56, 1, 1354);
    			attr_dev(div5, "class", "row no-gutters");
    			add_location(div5, file$n, 55, 0, 1324);
    			attr_dev(small1, "class", "request-info-txt mt-40 mb-3 d-block svelte-h13j00");
    			add_location(small1, file$n, 67, 0, 1580);
    			attr_dev(div6, "class", "form-group position-relative");
    			add_location(div6, file$n, 70, 0, 1730);
    			attr_dev(button, "class", "btn btn-primary");
    			button.disabled = button_disabled_value = /*emails*/ ctx[0].length == 0;
    			add_location(button, file$n, 76, 1, 2094);
    			attr_dev(div7, "class", "mt-40");
    			add_location(div7, file$n, 75, 0, 2073);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(div1, t2);
    			append_dev(div1, small0);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span0);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, t7);
    			append_dev(div3, t8);
    			append_dev(div3, a);
    			append_dev(a, span1);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, small1, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div6, anchor);
    			mount_component(tags, div6, null);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, button);
    			append_dev(button, t14);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*copy*/ ctx[2], false, false, false),
    					listen_dev(button, "click", /*sendInvite*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$TeamStore*/ 2) && t7_value !== (t7_value = /*$TeamStore*/ ctx[1].code + "")) set_data_dev(t7, t7_value);
    			const tags_changes = {};

    			if (!updating_tags && dirty & /*emails*/ 1) {
    				updating_tags = true;
    				tags_changes.tags = /*emails*/ ctx[0];
    				add_flush_callback(() => updating_tags = false);
    			}

    			tags.$set(tags_changes);

    			if (!current || dirty & /*emails*/ 1 && button_disabled_value !== (button_disabled_value = /*emails*/ ctx[0].length == 0)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tags.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tags.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(small1);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div6);
    			destroy_component(tags);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $TeamStore;
    	validate_store(TeamStore, 'TeamStore');
    	component_subscribe($$self, TeamStore, $$value => $$invalidate(1, $TeamStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TeamInviteModal', slots, []);
    	const teamModel = Team.getInstance();
    	let emails = [];

    	const copy = e => {
    		e.preventDefault();

    		const app = new Clipboard({
    				target: document.getElementById('clipboard'),
    				props: { name: $TeamStore.code }
    			});

    		app.$destroy();
    		notyf.success('Copied to clipboard');
    	};

    	const onTags = e => {
    		$$invalidate(0, emails = emails.filter(t => {
    			if ((/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/).test(t)) {
    				return true;
    			} else {
    				notyf.error(t + ' is invalid email');
    				return false;
    			}
    		}));
    	};

    	const sendInvite = async e => {
    		e.preventDefault();
    		let res = await teamModel.sendInvite(emails);

    		if (!res.error) {
    			notyf.success('Invitation sent successfully!');
    			Modal.close();
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TeamInviteModal> was created with unknown prop '${key}'`);
    	});

    	function tags_tags_binding(value) {
    		emails = value;
    		$$invalidate(0, emails);
    	}

    	$$self.$capture_state = () => ({
    		TeamStore,
    		Team,
    		CopyClipBoard: Clipboard,
    		toast: notyf,
    		Tags,
    		Modal,
    		teamModel,
    		emails,
    		copy,
    		onTags,
    		sendInvite,
    		$TeamStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('emails' in $$props) $$invalidate(0, emails = $$props.emails);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [emails, $TeamStore, copy, onTags, sendInvite, tags_tags_binding];
    }

    class TeamInviteModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TeamInviteModal",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src/pages/users/dashboard/team/StatusCard.svelte generated by Svelte v3.41.0 */

    const file$m = "src/pages/users/dashboard/team/StatusCard.svelte";

    function create_fragment$o(ctx) {
    	let div;
    	let h6;
    	let t0;
    	let t1;
    	let p;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h6 = element("h6");
    			t0 = text$1(/*title*/ ctx[0]);
    			t1 = space();
    			p = element("p");
    			if (default_slot) default_slot.c();
    			attr_dev(h6, "class", "title svelte-179ucl2");
    			add_location(h6, file$m, 4, 4, 96);
    			attr_dev(p, "class", "response-desc svelte-179ucl2");
    			add_location(p, file$m, 7, 4, 145);
    			attr_dev(div, "class", "upload-block teacm-full-details p-40 svelte-179ucl2");
    			add_location(div, file$m, 3, 0, 41);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h6);
    			append_dev(h6, t0);
    			append_dev(div, t1);
    			append_dev(div, p);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('StatusCard', slots, ['default']);
    	let { title } = $$props;
    	const writable_props = ['title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StatusCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ title });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, $$scope, slots];
    }

    class StatusCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { title: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StatusCard",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
    			console.warn("<StatusCard> was created without expected prop 'title'");
    		}
    	}

    	get title() {
    		throw new Error("<StatusCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<StatusCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/users/dashboard/team/TeamMenu.svelte generated by Svelte v3.41.0 */
    const file$l = "src/pages/users/dashboard/team/TeamMenu.svelte";

    // (16:4) {#if onInvite && $TeamStore.players.length < 4}
    function create_if_block_2$3(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Invite player";
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "svelte-1rtj3yi");
    			add_location(a, file$l, 16, 8, 577);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(
    					a,
    					"click",
    					function () {
    						if (is_function(/*onInvite*/ ctx[3])) /*onInvite*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(16:4) {#if onInvite && $TeamStore.players.length < 4}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if onLeaveTeam}
    function create_if_block_1$7(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Leave team";
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "svelte-1rtj3yi");
    			add_location(a, file$l, 19, 5, 661);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(
    					a,
    					"click",
    					function () {
    						if (is_function(/*onLeaveTeam*/ ctx[1])) /*onLeaveTeam*/ ctx[1].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(19:4) {#if onLeaveTeam}",
    		ctx
    	});

    	return block;
    }

    // (22:1) {#if onDeleteTeam}
    function create_if_block$c(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Delete team";
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "svelte-1rtj3yi");
    			add_location(a, file$l, 22, 2, 740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(
    					a,
    					"click",
    					function () {
    						if (is_function(/*onDeleteTeam*/ ctx[2])) /*onDeleteTeam*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(22:1) {#if onDeleteTeam}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;
    	let if_block0 = /*onInvite*/ ctx[3] && /*$TeamStore*/ ctx[5].players.length < 4 && create_if_block_2$3(ctx);
    	let if_block1 = /*onLeaveTeam*/ ctx[1] && create_if_block_1$7(ctx);
    	let if_block2 = /*onDeleteTeam*/ ctx[2] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div, "class", "dropdown-content svelte-1rtj3yi");
    			add_location(div, file$l, 14, 0, 461);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			/*div_binding*/ ctx[7](div);

    			if (!mounted) {
    				dispose = listen_dev(document.body, "mouseup", /*mouseup_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*onInvite*/ ctx[3] && /*$TeamStore*/ ctx[5].players.length < 4) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*onLeaveTeam*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$7(ctx);
    					if_block1.c();
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*onDeleteTeam*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$c(ctx);
    					if_block2.c();
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*div_binding*/ ctx[7](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $TeamStore;
    	validate_store(TeamStore, 'TeamStore');
    	component_subscribe($$self, TeamStore, $$value => $$invalidate(5, $TeamStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TeamMenu', slots, []);
    	let dropdownMenu;
    	let { onClose } = $$props;
    	let { onLeaveTeam } = $$props;
    	let { onDeleteTeam } = $$props;
    	let { onInvite } = $$props;
    	const writable_props = ['onClose', 'onLeaveTeam', 'onDeleteTeam', 'onInvite'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TeamMenu> was created with unknown prop '${key}'`);
    	});

    	const mouseup_handler = e => {
    		if (dropdownMenu != e.target && !dropdownMenu.contains(e.target)) onClose();
    	};

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			dropdownMenu = $$value;
    			$$invalidate(4, dropdownMenu);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('onClose' in $$props) $$invalidate(0, onClose = $$props.onClose);
    		if ('onLeaveTeam' in $$props) $$invalidate(1, onLeaveTeam = $$props.onLeaveTeam);
    		if ('onDeleteTeam' in $$props) $$invalidate(2, onDeleteTeam = $$props.onDeleteTeam);
    		if ('onInvite' in $$props) $$invalidate(3, onInvite = $$props.onInvite);
    	};

    	$$self.$capture_state = () => ({
    		Modal,
    		TeamInviteModal,
    		TeamStore,
    		dropdownMenu,
    		onClose,
    		onLeaveTeam,
    		onDeleteTeam,
    		onInvite,
    		$TeamStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('dropdownMenu' in $$props) $$invalidate(4, dropdownMenu = $$props.dropdownMenu);
    		if ('onClose' in $$props) $$invalidate(0, onClose = $$props.onClose);
    		if ('onLeaveTeam' in $$props) $$invalidate(1, onLeaveTeam = $$props.onLeaveTeam);
    		if ('onDeleteTeam' in $$props) $$invalidate(2, onDeleteTeam = $$props.onDeleteTeam);
    		if ('onInvite' in $$props) $$invalidate(3, onInvite = $$props.onInvite);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		onClose,
    		onLeaveTeam,
    		onDeleteTeam,
    		onInvite,
    		dropdownMenu,
    		$TeamStore,
    		mouseup_handler,
    		div_binding
    	];
    }

    class TeamMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			onClose: 0,
    			onLeaveTeam: 1,
    			onDeleteTeam: 2,
    			onInvite: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TeamMenu",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onClose*/ ctx[0] === undefined && !('onClose' in props)) {
    			console.warn("<TeamMenu> was created without expected prop 'onClose'");
    		}

    		if (/*onLeaveTeam*/ ctx[1] === undefined && !('onLeaveTeam' in props)) {
    			console.warn("<TeamMenu> was created without expected prop 'onLeaveTeam'");
    		}

    		if (/*onDeleteTeam*/ ctx[2] === undefined && !('onDeleteTeam' in props)) {
    			console.warn("<TeamMenu> was created without expected prop 'onDeleteTeam'");
    		}

    		if (/*onInvite*/ ctx[3] === undefined && !('onInvite' in props)) {
    			console.warn("<TeamMenu> was created without expected prop 'onInvite'");
    		}
    	}

    	get onClose() {
    		throw new Error("<TeamMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClose(value) {
    		throw new Error("<TeamMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onLeaveTeam() {
    		throw new Error("<TeamMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onLeaveTeam(value) {
    		throw new Error("<TeamMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onDeleteTeam() {
    		throw new Error("<TeamMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onDeleteTeam(value) {
    		throw new Error("<TeamMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onInvite() {
    		throw new Error("<TeamMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onInvite(value) {
    		throw new Error("<TeamMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Switch.svelte generated by Svelte v3.41.0 */

    const file$k = "src/components/Switch.svelte";

    function create_fragment$m(ctx) {
    	let label;
    	let input;
    	let t;
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t = space();
    			span = element("span");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "svelte-1kuuxh5");
    			add_location(input, file$k, 62, 1, 990);
    			attr_dev(span, "class", "slider switch-slider svelte-1kuuxh5");
    			add_location(span, file$k, 63, 1, 1039);
    			attr_dev(label, "class", "switch svelte-1kuuxh5");
    			add_location(label, file$k, 61, 1, 966);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			input.checked = /*checked*/ ctx[0];
    			append_dev(label, t);
    			append_dev(label, span);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[3]),
    					listen_dev(input, "change", /*change_handler*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*checked*/ 1) {
    				input.checked = /*checked*/ ctx[0];
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Switch', slots, []);
    	let { checked = false } = $$props;
    	let { color = "#3253dc" } = $$props;
    	const writable_props = ['checked', 'color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Switch> was created with unknown prop '${key}'`);
    	});

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_change_handler() {
    		checked = this.checked;
    		$$invalidate(0, checked);
    	}

    	$$self.$$set = $$props => {
    		if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({ checked, color });

    	$$self.$inject_state = $$props => {
    		if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [checked, color, change_handler, input_change_handler];
    }

    class Switch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { checked: 0, color: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Switch",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get checked() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/users/dashboard/YourTeam.svelte generated by Svelte v3.41.0 */

    const { Object: Object_1, console: console_1$2 } = globals;
    const file$j = "src/pages/users/dashboard/YourTeam.svelte";

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[21] = i;
    	return child_ctx;
    }

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[21] = i;
    	return child_ctx;
    }

    // (139:0) {#if $TeamStore.name && $TeamStore.status != 'deleted' && $TeamStore.status != 'team_full' && $TeamStore.status != 'cancelled' && $TeamStore.status != 'left_team' && $TeamStore.status != 'rejected'}
    function create_if_block$b(ctx) {
    	let div8;
    	let div7;
    	let div2;
    	let div1;
    	let div0;

    	let t0_value = (/*$TeamStore*/ ctx[1].name.indexOf(' ') != -1
    	? /*$TeamStore*/ ctx[1].name.split(' ').map(func$1).join('').substr(0, 2)
    	: /*$TeamStore*/ ctx[1].name.substr(0, 2)) + "";

    	let t0;
    	let t1;
    	let div6;
    	let div5;
    	let div3;
    	let ul0;
    	let li0;
    	let strong0;
    	let t3;
    	let span0;
    	let t4_value = /*$TeamStore*/ ctx[1].name + "";
    	let t4;
    	let t5;
    	let li1;
    	let strong1;
    	let t7;
    	let span1;
    	let t8_value = /*$TeamStore*/ ctx[1].code + "";
    	let t8;
    	let t9;
    	let div4;
    	let ul1;
    	let li2;
    	let strong2;
    	let t11;
    	let span2;
    	let t12;
    	let div12;
    	let div11;
    	let div10;
    	let h6;
    	let t14;
    	let p;
    	let t15;
    	let div9;
    	let t16;

    	function select_block_type(ctx, dirty) {
    		if (/*$TeamStore*/ ctx[1].status == 'active') return create_if_block_6;
    		if (/*$TeamStore*/ ctx[1].status == 'requested') return create_if_block_8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type && current_block_type(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*$TeamStore*/ ctx[1].notice) return create_if_block_4;
    		if (/*$TeamStore*/ ctx[1].status == 'active' && /*$TeamStore*/ ctx[1].players.length == 4) return create_if_block_5;
    		return create_else_block_2;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block1 = current_block_type_1(ctx);
    	let if_block2 = /*$TeamStore*/ ctx[1].leader && create_if_block_3$1(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*isLeader*/ ctx[0]) return create_if_block_1$6;
    		return create_else_block$5;
    	}

    	let current_block_type_2 = select_block_type_3(ctx);
    	let if_block3 = current_block_type_2(ctx);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			strong0 = element("strong");
    			strong0.textContent = "Team Name";
    			t3 = space();
    			span0 = element("span");
    			t4 = text$1(t4_value);
    			t5 = space();
    			li1 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Team Code";
    			t7 = space();
    			span1 = element("span");
    			t8 = text$1(t8_value);
    			t9 = space();
    			div4 = element("div");
    			ul1 = element("ul");
    			li2 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Status";
    			t11 = space();
    			span2 = element("span");
    			if (if_block0) if_block0.c();
    			t12 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			h6 = element("h6");
    			h6.textContent = "Team members";
    			t14 = space();
    			p = element("p");
    			if_block1.c();
    			t15 = space();
    			div9 = element("div");
    			if (if_block2) if_block2.c();
    			t16 = space();
    			if_block3.c();
    			attr_dev(div0, "class", "content rounded-circle svelte-1qavdbm");
    			add_location(div0, file$j, 143, 5, 5252);
    			attr_dev(div1, "class", "box svelte-1qavdbm");
    			add_location(div1, file$j, 142, 16, 5229);
    			attr_dev(div2, "class", "col-lg-4 col-sm-7 col-xs-12");
    			add_location(div2, file$j, 141, 12, 5171);
    			attr_dev(strong0, "class", "svelte-1qavdbm");
    			add_location(strong0, file$j, 151, 8, 5614);
    			attr_dev(span0, "class", "svelte-1qavdbm");
    			add_location(span0, file$j, 152, 8, 5649);
    			attr_dev(li0, "class", "svelte-1qavdbm");
    			add_location(li0, file$j, 150, 7, 5601);
    			attr_dev(strong1, "class", "svelte-1qavdbm");
    			add_location(strong1, file$j, 155, 8, 5713);
    			attr_dev(span1, "class", "svelte-1qavdbm");
    			add_location(span1, file$j, 156, 8, 5748);
    			attr_dev(li1, "class", "svelte-1qavdbm");
    			add_location(li1, file$j, 154, 7, 5700);
    			attr_dev(ul0, "class", "team-details pt-30 svelte-1qavdbm");
    			add_location(ul0, file$j, 149, 6, 5562);
    			attr_dev(div3, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div3, file$j, 148, 5, 5514);
    			attr_dev(strong2, "class", "svelte-1qavdbm");
    			add_location(strong2, file$j, 163, 8, 5929);
    			attr_dev(span2, "class", "svelte-1qavdbm");
    			add_location(span2, file$j, 164, 8, 5961);
    			attr_dev(li2, "class", "svelte-1qavdbm");
    			add_location(li2, file$j, 162, 7, 5916);
    			attr_dev(ul1, "class", "team-details reqeust pt-30 svelte-1qavdbm");
    			add_location(ul1, file$j, 161, 6, 5869);
    			attr_dev(div4, "class", "col-lg-6 col-sm-6 col-xs-12");
    			add_location(div4, file$j, 160, 5, 5821);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$j, 147, 4, 5491);
    			attr_dev(div6, "class", "col-lg-8");
    			add_location(div6, file$j, 146, 3, 5464);
    			attr_dev(div7, "class", "row");
    			add_location(div7, file$j, 140, 8, 5141);
    			attr_dev(div8, "class", "upload-block teacm-full-details p-40 svelte-1qavdbm");
    			add_location(div8, file$j, 139, 4, 5082);
    			attr_dev(h6, "class", "title svelte-1qavdbm");
    			add_location(h6, file$j, 185, 4, 6528);
    			attr_dev(p, "class", "response-desc svelte-1qavdbm");
    			add_location(p, file$j, 188, 4, 6579);
    			attr_dev(div9, "class", "row player-section");
    			add_location(div9, file$j, 197, 16, 7091);
    			attr_dev(div10, "class", "col-12");
    			add_location(div10, file$j, 184, 12, 6503);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$j, 183, 8, 6473);
    			attr_dev(div12, "class", "upload-block awating-response p-40 mt-20 svelte-1qavdbm");
    			add_location(div12, file$j, 182, 4, 6410);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, strong0);
    			append_dev(li0, t3);
    			append_dev(li0, span0);
    			append_dev(span0, t4);
    			append_dev(ul0, t5);
    			append_dev(ul0, li1);
    			append_dev(li1, strong1);
    			append_dev(li1, t7);
    			append_dev(li1, span1);
    			append_dev(span1, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, ul1);
    			append_dev(ul1, li2);
    			append_dev(li2, strong2);
    			append_dev(li2, t11);
    			append_dev(li2, span2);
    			if (if_block0) if_block0.m(span2, null);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, h6);
    			append_dev(div10, t14);
    			append_dev(div10, p);
    			if_block1.m(p, null);
    			append_dev(div10, t15);
    			append_dev(div10, div9);
    			if (if_block2) if_block2.m(div9, null);
    			append_dev(div9, t16);
    			if_block3.m(div9, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2 && t0_value !== (t0_value = (/*$TeamStore*/ ctx[1].name.indexOf(' ') != -1
    			? /*$TeamStore*/ ctx[1].name.split(' ').map(func$1).join('').substr(0, 2)
    			: /*$TeamStore*/ ctx[1].name.substr(0, 2)) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$TeamStore*/ 2 && t4_value !== (t4_value = /*$TeamStore*/ ctx[1].name + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$TeamStore*/ 2 && t8_value !== (t8_value = /*$TeamStore*/ ctx[1].code + "")) set_data_dev(t8, t8_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if (if_block0) if_block0.d(1);
    				if_block0 = current_block_type && current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span2, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(p, null);
    				}
    			}

    			if (/*$TeamStore*/ ctx[1].leader) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3$1(ctx);
    					if_block2.c();
    					if_block2.m(div9, t16);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_3(ctx)) && if_block3) {
    				if_block3.p(ctx, dirty);
    			} else {
    				if_block3.d(1);
    				if_block3 = current_block_type_2(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(div9, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);

    			if (if_block0) {
    				if_block0.d();
    			}

    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div12);
    			if_block1.d();
    			if (if_block2) if_block2.d();
    			if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(139:0) {#if $TeamStore.name && $TeamStore.status != 'deleted' && $TeamStore.status != 'team_full' && $TeamStore.status != 'cancelled' && $TeamStore.status != 'left_team' && $TeamStore.status != 'rejected'}",
    		ctx
    	});

    	return block;
    }

    // (172:52) 
    function create_if_block_8(ctx) {
    	let t_value = (/*$TeamStore*/ ctx[1].players.length < 4
    	? 'Awaiting response'
    	: 'Team is full') + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2 && t_value !== (t_value = (/*$TeamStore*/ ctx[1].players.length < 4
    			? 'Awaiting response'
    			: 'Team is full') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(172:52) ",
    		ctx
    	});

    	return block;
    }

    // (166:9) {#if $TeamStore.status == 'active'}
    function create_if_block_6(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$TeamStore*/ ctx[1].players && /*$TeamStore*/ ctx[1].players.length < 4) return create_if_block_7;
    		return create_else_block_3;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(166:9) {#if $TeamStore.status == 'active'}",
    		ctx
    	});

    	return block;
    }

    // (169:10) {:else}
    function create_else_block_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Complete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(169:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (167:10) {#if $TeamStore.players && $TeamStore.players.length < 4}
    function create_if_block_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Incomplete");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(167:10) {#if $TeamStore.players && $TeamStore.players.length < 4}",
    		ctx
    	});

    	return block;
    }

    // (194:5) {:else}
    function create_else_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("You did not qualify for the In-Game Qualifiers as you were not a part of a completed team. Good luck for your future events.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(194:5) {:else}",
    		ctx
    	});

    	return block;
    }

    // (192:79) 
    function create_if_block_5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Your team did not qualify to the further phases of the tournament based on your score. Thank you for your participation and good luck for future tournaments.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(192:79) ",
    		ctx
    	});

    	return block;
    }

    // (190:5) {#if $TeamStore.notice}
    function create_if_block_4(ctx) {
    	let html_tag;
    	let raw_value = /*$TeamStore*/ ctx[1].notice + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2 && raw_value !== (raw_value = /*$TeamStore*/ ctx[1].notice + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(190:5) {#if $TeamStore.notice}",
    		ctx
    	});

    	return block;
    }

    // (199:20) {#if $TeamStore.leader}
    function create_if_block_3$1(ctx) {
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let strong;
    	let t1_value = /*leaderObj*/ ctx[3].first_name + "";
    	let t1;
    	let t2;
    	let t3_value = /*leaderObj*/ ctx[3].last_name + "";
    	let t3;
    	let t4;
    	let span0;
    	let t6;
    	let span1;
    	let t7;
    	let t8_value = /*leaderObj*/ ctx[3].free_fire_id + "";
    	let t8;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			strong = element("strong");
    			t1 = text$1(t1_value);
    			t2 = space();
    			t3 = text$1(t3_value);
    			t4 = space();
    			span0 = element("span");
    			span0.textContent = "Team Leader";
    			t6 = space();
    			span1 = element("span");
    			t7 = text$1("FF");
    			t8 = text$1(t8_value);
    			attr_dev(img, "class", "pic profile-pic-sm rounded svelte-1qavdbm");
    			if (!src_url_equal(img.src, img_src_value = "/images/white-player.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "Profile-pic");
    			add_location(img, file$j, 200, 28, 7256);
    			attr_dev(strong, "class", "player-name svelte-1qavdbm");
    			add_location(strong, file$j, 202, 32, 7434);
    			attr_dev(span0, "class", "player-position svelte-1qavdbm");
    			add_location(span0, file$j, 205, 32, 7618);
    			attr_dev(span1, "class", "player-position svelte-1qavdbm");
    			add_location(span1, file$j, 208, 8, 7721);
    			attr_dev(div0, "class", "player-info svelte-1qavdbm");
    			add_location(div0, file$j, 201, 28, 7376);
    			attr_dev(div1, "class", "player col-6 col-md-3 svelte-1qavdbm");
    			add_location(div1, file$j, 199, 24, 7192);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(strong, t1);
    			append_dev(strong, t2);
    			append_dev(strong, t3);
    			append_dev(div0, t4);
    			append_dev(div0, span0);
    			append_dev(div0, t6);
    			append_dev(div0, span1);
    			append_dev(span1, t7);
    			append_dev(span1, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*leaderObj*/ 8 && t1_value !== (t1_value = /*leaderObj*/ ctx[3].first_name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*leaderObj*/ 8 && t3_value !== (t3_value = /*leaderObj*/ ctx[3].last_name + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*leaderObj*/ 8 && t8_value !== (t8_value = /*leaderObj*/ ctx[3].free_fire_id + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(199:20) {#if $TeamStore.leader}",
    		ctx
    	});

    	return block;
    }

    // (228:20) {:else}
    function create_else_block$5(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*$TeamStore*/ ctx[1].players.filter(/*func_2*/ ctx[7]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$currentUser, $TeamStore*/ 6) {
    				each_value_1 = /*$TeamStore*/ ctx[1].players.filter(/*func_2*/ ctx[7]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(228:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (213:20) {#if isLeader}
    function create_if_block_1$6(ctx) {
    	let each_1_anchor;
    	let each_value = /*$TeamStore*/ ctx[1].players.filter(/*func_1*/ ctx[6]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2) {
    				each_value = /*$TeamStore*/ ctx[1].players.filter(/*func_1*/ ctx[6]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(213:20) {#if isLeader}",
    		ctx
    	});

    	return block;
    }

    // (243:7) {:else}
    function create_else_block_1(ctx) {
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let strong;
    	let t1_value = /*player*/ ctx[19].first_name + "";
    	let t1;
    	let t2;
    	let t3_value = /*player*/ ctx[19].last_name + "";
    	let t3;
    	let t4;
    	let span0;
    	let t5;
    	let t6_value = /*i*/ ctx[21] + 2 + "";
    	let t6;
    	let t7;
    	let span1;
    	let t8;
    	let t9_value = /*player*/ ctx[19].free_fire_id + "";
    	let t9;
    	let t10;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			strong = element("strong");
    			t1 = text$1(t1_value);
    			t2 = space();
    			t3 = text$1(t3_value);
    			t4 = space();
    			span0 = element("span");
    			t5 = text$1("Player ");
    			t6 = text$1(t6_value);
    			t7 = space();
    			span1 = element("span");
    			t8 = text$1("FF");
    			t9 = text$1(t9_value);
    			t10 = space();
    			attr_dev(img, "class", "pic profile-pic-sm rounded svelte-1qavdbm");
    			if (!src_url_equal(img.src, img_src_value = "/images/white-player.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "Profile-pic");
    			add_location(img, file$j, 244, 32, 9528);
    			attr_dev(strong, "class", "player-name svelte-1qavdbm");
    			add_location(strong, file$j, 246, 36, 9714);
    			attr_dev(span0, "class", "player-position svelte-1qavdbm");
    			add_location(span0, file$j, 249, 36, 9904);
    			attr_dev(span1, "class", "player-position svelte-1qavdbm");
    			add_location(span1, file$j, 252, 9, 10014);
    			attr_dev(div0, "class", "player-info svelte-1qavdbm");
    			add_location(div0, file$j, 245, 32, 9652);
    			attr_dev(div1, "class", "player col-6 col-md-3 svelte-1qavdbm");
    			add_location(div1, file$j, 243, 28, 9460);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(strong, t1);
    			append_dev(strong, t2);
    			append_dev(strong, t3);
    			append_dev(div0, t4);
    			append_dev(div0, span0);
    			append_dev(span0, t5);
    			append_dev(span0, t6);
    			append_dev(div0, t7);
    			append_dev(div0, span1);
    			append_dev(span1, t8);
    			append_dev(span1, t9);
    			append_dev(div1, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2 && t1_value !== (t1_value = /*player*/ ctx[19].first_name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*$TeamStore*/ 2 && t3_value !== (t3_value = /*player*/ ctx[19].last_name + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*$TeamStore*/ 2 && t9_value !== (t9_value = /*player*/ ctx[19].free_fire_id + "")) set_data_dev(t9, t9_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(243:7) {:else}",
    		ctx
    	});

    	return block;
    }

    // (230:7) {#if player.id == $currentUser.id}
    function create_if_block_2$2(ctx) {
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let strong;
    	let t1_value = /*$currentUser*/ ctx[2].first_name + "";
    	let t1;
    	let t2;
    	let t3_value = /*$currentUser*/ ctx[2].last_name + "";
    	let t3;
    	let t4;
    	let span0;
    	let t5;
    	let t6_value = /*i*/ ctx[21] + 2 + "";
    	let t6;
    	let t7;
    	let span1;
    	let t8;
    	let t9_value = /*$currentUser*/ ctx[2].free_fire_id + "";
    	let t9;
    	let t10;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			strong = element("strong");
    			t1 = text$1(t1_value);
    			t2 = space();
    			t3 = text$1(t3_value);
    			t4 = space();
    			span0 = element("span");
    			t5 = text$1("Player ");
    			t6 = text$1(t6_value);
    			t7 = space();
    			span1 = element("span");
    			t8 = text$1("FF");
    			t9 = text$1(t9_value);
    			t10 = space();
    			attr_dev(img, "class", "pic profile-pic-sm rounded svelte-1qavdbm");
    			if (!src_url_equal(img.src, img_src_value = "/images/white-player.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "Profile-pic");
    			add_location(img, file$j, 231, 9, 8978);
    			attr_dev(strong, "class", "player-name svelte-1qavdbm");
    			add_location(strong, file$j, 233, 10, 9115);
    			attr_dev(span0, "class", "player-position svelte-1qavdbm");
    			add_location(span0, file$j, 236, 10, 9236);
    			attr_dev(span1, "class", "player-position svelte-1qavdbm");
    			add_location(span1, file$j, 239, 10, 9319);
    			attr_dev(div0, "class", "player-info svelte-1qavdbm");
    			add_location(div0, file$j, 232, 9, 9079);
    			attr_dev(div1, "class", "player col-6 col-md-3 svelte-1qavdbm");
    			add_location(div1, file$j, 230, 8, 8933);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(strong, t1);
    			append_dev(strong, t2);
    			append_dev(strong, t3);
    			append_dev(div0, t4);
    			append_dev(div0, span0);
    			append_dev(span0, t5);
    			append_dev(span0, t6);
    			append_dev(div0, t7);
    			append_dev(div0, span1);
    			append_dev(span1, t8);
    			append_dev(span1, t9);
    			append_dev(div1, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$currentUser*/ 4 && t1_value !== (t1_value = /*$currentUser*/ ctx[2].first_name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*$currentUser*/ 4 && t3_value !== (t3_value = /*$currentUser*/ ctx[2].last_name + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*$currentUser*/ 4 && t9_value !== (t9_value = /*$currentUser*/ ctx[2].free_fire_id + "")) set_data_dev(t9, t9_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(230:7) {#if player.id == $currentUser.id}",
    		ctx
    	});

    	return block;
    }

    // (229:6) {#each $TeamStore.players.filter(p => p.id != $TeamStore.leader.id) as player, i}
    function create_each_block_1$3(ctx) {
    	let if_block_anchor;

    	function select_block_type_4(ctx, dirty) {
    		if (/*player*/ ctx[19].id == /*$currentUser*/ ctx[2].id) return create_if_block_2$2;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type_4(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(229:6) {#each $TeamStore.players.filter(p => p.id != $TeamStore.leader.id) as player, i}",
    		ctx
    	});

    	return block;
    }

    // (214:24) {#each $TeamStore.players.filter(p => p.id != $TeamStore.leader.id) as player, i}
    function create_each_block$5(ctx) {
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let strong;
    	let t1_value = /*player*/ ctx[19].first_name + "";
    	let t1;
    	let t2;
    	let t3_value = /*player*/ ctx[19].last_name + "";
    	let t3;
    	let t4;
    	let span0;
    	let t5;
    	let t6_value = /*i*/ ctx[21] + 2 + "";
    	let t6;
    	let t7;
    	let span1;
    	let t8;
    	let t9_value = /*player*/ ctx[19].free_fire_id + "";
    	let t9;
    	let t10;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			strong = element("strong");
    			t1 = text$1(t1_value);
    			t2 = space();
    			t3 = text$1(t3_value);
    			t4 = space();
    			span0 = element("span");
    			t5 = text$1("Player ");
    			t6 = text$1(t6_value);
    			t7 = space();
    			span1 = element("span");
    			t8 = text$1("FF");
    			t9 = text$1(t9_value);
    			t10 = space();
    			attr_dev(img, "class", "pic profile-pic-sm rounded svelte-1qavdbm");
    			if (!src_url_equal(img.src, img_src_value = "/images/white-player.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "align", "Profile-pic");
    			add_location(img, file$j, 215, 32, 8114);
    			attr_dev(strong, "class", "player-name svelte-1qavdbm");
    			add_location(strong, file$j, 217, 36, 8300);
    			attr_dev(span0, "class", "player-position svelte-1qavdbm");
    			add_location(span0, file$j, 220, 36, 8490);
    			attr_dev(span1, "class", "player-position svelte-1qavdbm");
    			add_location(span1, file$j, 223, 9, 8600);
    			attr_dev(div0, "class", "player-info svelte-1qavdbm");
    			add_location(div0, file$j, 216, 32, 8238);
    			attr_dev(div1, "class", "player col-6 col-md-3 svelte-1qavdbm");
    			add_location(div1, file$j, 214, 28, 8046);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(strong, t1);
    			append_dev(strong, t2);
    			append_dev(strong, t3);
    			append_dev(div0, t4);
    			append_dev(div0, span0);
    			append_dev(span0, t5);
    			append_dev(span0, t6);
    			append_dev(div0, t7);
    			append_dev(div0, span1);
    			append_dev(span1, t8);
    			append_dev(span1, t9);
    			append_dev(div1, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$TeamStore*/ 2 && t1_value !== (t1_value = /*player*/ ctx[19].first_name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*$TeamStore*/ 2 && t3_value !== (t3_value = /*player*/ ctx[19].last_name + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*$TeamStore*/ 2 && t9_value !== (t9_value = /*player*/ ctx[19].free_fire_id + "")) set_data_dev(t9, t9_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(214:24) {#each $TeamStore.players.filter(p => p.id != $TeamStore.leader.id) as player, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let t;
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let if_block = /*$TeamStore*/ ctx[1].name && /*$TeamStore*/ ctx[1].status != 'deleted' && /*$TeamStore*/ ctx[1].status != 'team_full' && /*$TeamStore*/ ctx[1].status != 'cancelled' && /*$TeamStore*/ ctx[1].status != 'left_team' && /*$TeamStore*/ ctx[1].status != 'rejected' && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(document.body, "mouseup", /*mouseup_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$TeamStore*/ ctx[1].name && /*$TeamStore*/ ctx[1].status != 'deleted' && /*$TeamStore*/ ctx[1].status != 'team_full' && /*$TeamStore*/ ctx[1].status != 'cancelled' && /*$TeamStore*/ ctx[1].status != 'left_team' && /*$TeamStore*/ ctx[1].status != 'rejected') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = a => a[0];

    function instance$l($$self, $$props, $$invalidate) {
    	let $TeamStore;
    	let $currentUser;
    	validate_store(TeamStore, 'TeamStore');
    	component_subscribe($$self, TeamStore, $$value => $$invalidate(1, $TeamStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('YourTeam', slots, []);
    	let dropdonwMenu = false;
    	const currentUser = User.getUser();
    	validate_store(currentUser, 'currentUser');
    	component_subscribe($$self, currentUser, value => $$invalidate(2, $currentUser = value));
    	const teamModel = Team.getInstance();
    	let isLeader = false;
    	let leaderObj;
    	let hideTeam;

    	TeamStore.subscribe(t => {
    		if (t.leader && t.leader.id == $currentUser.id) {
    			$$invalidate(0, isLeader = true);
    		} else {
    			$$invalidate(0, isLeader = false);
    		}

    		hideTeam = !t.searchable;
    	});

    	const updateRequests = async e => {
    		e.preventDefault();
    		let requests = await teamModel.getRequests();
    		set_store_value(TeamStore, $TeamStore.newRequests = requests.length, $TeamStore);
    	};

    	const kickPlayer = async player => {
    		Modal.open(
    			DeleteModal,
    			{
    				content: `You chose to kick ${player.first_name} ${player.last_name} out of the team. You cannot reverse this.`,
    				btnText: 'Kick player'
    			},
    			async () => {
    				let res = await teamModel.kickPlayer(player.id);

    				if (!res.error) {
    					Modal.close();
    				}
    			}
    		);
    	};

    	const makeLeader = async player => {
    		Modal.open(
    			DeleteModal,
    			{
    				content: `You chose to make ${player.first_name} ${player.last_name} leader of the team. You will loose rights to manage the team. You cannot reverse this.`,
    				btnText: 'Make leader'
    			},
    			async () => {
    				let res = await teamModel.makeLeader(player.id);

    				if (!res.error) {
    					Modal.close();
    				}
    			}
    		);
    	};

    	const cancelRequest = async () => {
    		Modal.open(
    			DeleteModal,
    			{
    				content: `You chose to cancel the request to join the team "${$TeamStore.name}"`,
    				btnText: 'Cancel request'
    			},
    			async () => {
    				let res = await teamModel.cancelRequest();

    				if (!res.error) {
    					Modal.close();
    				}
    			}
    		);
    	};

    	const leaveTeam = async () => {
    		if (isLeader) Modal.open(
    			DeleteModal,
    			{
    				title: 'Cant leave!!', //}
    				content: `You need to appoint a leader before you can leave the team.`,
    				btnText: 'OK',
    				hideCancel: true
    			},
    			async () => {
    				// let res = await teamModel.leaveTeam();
    				// if(!res.error){
    				Modal.close();
    			}
    		); else Modal.open(
    			DeleteModal,
    			{
    				content: `You chose to leave the team "${$TeamStore.name}"`,
    				btnText: 'Leave team'
    			},
    			async () => {
    				let res = await teamModel.leaveTeam();

    				if (!res.error) {
    					Modal.close();
    				}
    			}
    		);
    	};

    	const deleteTeam = async () => {
    		Modal.open(
    			DeleteModal,
    			{
    				content: 'You chose to delete the team you have created. You cannot reverse this.',
    				btnText: 'Delete team'
    			},
    			async () => {
    				let res = await teamModel.deleteTeam();

    				if (!res.error) {
    					Modal.close();
    				}
    			}
    		);
    	};

    	const invitePlayer = async e => {
    		e.preventDefault();
    		let img = await window.fetch('/images/WhatsAppShare.png');
    		img = await img.arrayBuffer();
    		let fileName = "JoinTheTeam.png";

    		let filedata = new File([img],
    		fileName,
    		{
    				type: "image/png",
    				lastModified: Date.now()
    			});

    		let fileArray = [filedata];
    		Object.freeze(fileArray);

    		if (window.navigator && window.navigator.canShare && window.navigator.canShare({ files: fileArray })) {
    			navigator.share({
    				files: fileArray,
    				title: 'Join the battle!',
    				text: `I am inviting you to join my team ${$TeamStore.name}. Please signup at https://snapdragonconquest.com and use the code ${$TeamStore.code} to join my team.`,
    				url: 'https://snapdragonconquest.com/invite/' + $TeamStore.code
    			}).then(() => {
    				console.log('Thanks for sharing!');
    			}).catch(console.error);
    		} else // if (window.navigator && window.navigator.share) {
    		// 	navigator.share({
    		// 		title: 'Invite to team',
    		// 		text: `I am inviting you to join my team ${$TeamStore.name}. Please signup at https://conquestesports.in and use the code ${$TeamStore.code} to join my team.`,
    		// 		url: 'https://share.conquestesports.in/team/info/'+$TeamStore.code
    		// 	}).then(() => {
    		// 		console.log('Thanks for sharing!');
    		// 	})
    		// 	.catch(console.error);
    		// }
    		{
    			Modal.open(TeamInviteModal);
    		}
    	};

    	const showHideTeam = async e => {
    		let res;

    		if (hideTeam) {
    			res = await teamModel.hideTeam();
    		} else {
    			res = await teamModel.showTeam();
    		}

    		if (!res.error) {
    			notyf.success('Updated visibility');
    		} else {
    			notyf.error('Failed to update visibility');
    		}
    	};

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<YourTeam> was created with unknown prop '${key}'`);
    	});

    	const mouseup_handler = e => {
    		if ($TeamStore.players && !e.target.classList.contains('dropbtn')) {
    			setTimeout(
    				() => {
    					set_store_value(TeamStore, $TeamStore.players = $TeamStore.players.map(p => ({ ...p, showMenu: false })), $TeamStore);
    				},
    				200
    			);
    		}
    	};

    	const func_1 = p => p.id != $TeamStore.leader.id;
    	const func_2 = p => p.id != $TeamStore.leader.id;

    	$$self.$capture_state = () => ({
    		RequestModal,
    		DeleteModal,
    		TeamInviteModal,
    		Modal,
    		TeamStore,
    		Team,
    		User,
    		Profile,
    		StatusCard,
    		TeamMenu,
    		Switch,
    		Toast: notyf,
    		dropdonwMenu,
    		currentUser,
    		teamModel,
    		isLeader,
    		leaderObj,
    		hideTeam,
    		updateRequests,
    		kickPlayer,
    		makeLeader,
    		cancelRequest,
    		leaveTeam,
    		deleteTeam,
    		invitePlayer,
    		showHideTeam,
    		$TeamStore,
    		$currentUser
    	});

    	$$self.$inject_state = $$props => {
    		if ('dropdonwMenu' in $$props) dropdonwMenu = $$props.dropdonwMenu;
    		if ('isLeader' in $$props) $$invalidate(0, isLeader = $$props.isLeader);
    		if ('leaderObj' in $$props) $$invalidate(3, leaderObj = $$props.leaderObj);
    		if ('hideTeam' in $$props) hideTeam = $$props.hideTeam;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isLeader, $currentUser, $TeamStore*/ 7) {
    			($$invalidate(3, leaderObj = isLeader ? { ...$currentUser } : $TeamStore.leader));
    		}
    	};

    	return [
    		isLeader,
    		$TeamStore,
    		$currentUser,
    		leaderObj,
    		currentUser,
    		mouseup_handler,
    		func_1,
    		func_2
    	];
    }

    class YourTeam extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "YourTeam",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src/components/modal/UserEdit.svelte generated by Svelte v3.41.0 */
    const file$i = "src/components/modal/UserEdit.svelte";

    function create_fragment$k(ctx) {
    	let div0;
    	let h2;
    	let t1;
    	let div2;
    	let div1;
    	let registration;
    	let current;
    	registration = new Registration({ props: { edit: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Edit";
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(registration.$$.fragment);
    			attr_dev(h2, "class", "popup-title");
    			add_location(h2, file$i, 5, 1, 115);
    			attr_dev(div0, "class", "svelte-modal-header");
    			add_location(div0, file$i, 4, 0, 80);
    			attr_dev(div1, "class", "col-12 mt-4");
    			add_location(div1, file$i, 10, 4, 194);
    			attr_dev(div2, "class", "row no-gutters");
    			add_location(div2, file$i, 9, 0, 161);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			mount_component(registration, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(registration.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(registration.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(registration);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UserEdit', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserEdit> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Registration });
    	return [];
    }

    class UserEdit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserEdit",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src/pages/users/Dashboard.svelte generated by Svelte v3.41.0 */
    const file$h = "src/pages/users/Dashboard.svelte";

    // (68:4) {#if $currentUser.role == 'admin'}
    function create_if_block_1$5(ctx) {
    	let li;

    	const block = {
    		c: function create() {
    			li = element("li");
    			toggle_class(li, "active", /*selectedTab*/ ctx[1] == 1);
    			add_location(li, file$h, 68, 5, 1806);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedTab*/ 2) {
    				toggle_class(li, "active", /*selectedTab*/ ctx[1] == 1);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(68:4) {#if $currentUser.role == 'admin'}",
    		ctx
    	});

    	return block;
    }

    // (141:4) {:else}
    function create_else_block$4(ctx) {
    	let ul;
    	let li0;
    	let strong0;
    	let t1;
    	let div2;
    	let div0;
    	let input0;
    	let label0;
    	let t3;
    	let div1;
    	let input1;
    	let label1;
    	let t5;
    	let li1;
    	let strong1;
    	let t7;
    	let span0;
    	let t8_value = /*$currentUser*/ ctx[2].free_fire_id + "";
    	let t8;
    	let t9;
    	let li2;
    	let strong2;
    	let t11;
    	let span1;
    	let t12_value = /*$currentUser*/ ctx[2].mobile + "";
    	let t12;
    	let t13;
    	let li3;
    	let strong3;
    	let t15;
    	let span2;
    	let t16_value = /*$currentUser*/ ctx[2].email + "";
    	let t16;
    	let t17;
    	let div3;
    	let button0;
    	let t19;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			strong0 = element("strong");
    			strong0.textContent = "Name";
    			t1 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			label0 = element("label");
    			label0.textContent = "First name";
    			t3 = space();
    			div1 = element("div");
    			input1 = element("input");
    			label1 = element("label");
    			label1.textContent = "Last name";
    			t5 = space();
    			li1 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Free Fire ID";
    			t7 = space();
    			span0 = element("span");
    			t8 = text$1(t8_value);
    			t9 = space();
    			li2 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Mobile Number";
    			t11 = space();
    			span1 = element("span");
    			t12 = text$1(t12_value);
    			t13 = space();
    			li3 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Email";
    			t15 = space();
    			span2 = element("span");
    			t16 = text$1(t16_value);
    			t17 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Save";
    			t19 = space();
    			button1 = element("button");
    			button1.textContent = "Cancel";
    			add_location(strong0, file$h, 145, 7, 3640);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$h, 149, 32, 3744);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$h, 149, 109, 3821);
    			attr_dev(div0, "class", "form-group");
    			add_location(div0, file$h, 149, 8, 3720);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$h, 150, 32, 3892);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$h, 150, 108, 3968);
    			attr_dev(div1, "class", "form-group");
    			add_location(div1, file$h, 150, 8, 3868);
    			attr_dev(div2, "class", "form-inline");
    			add_location(div2, file$h, 148, 7, 3686);
    			add_location(li0, file$h, 142, 6, 3480);
    			add_location(strong1, file$h, 154, 7, 4050);
    			add_location(span0, file$h, 157, 7, 4104);
    			add_location(li1, file$h, 153, 6, 4038);
    			add_location(strong2, file$h, 162, 7, 4192);
    			add_location(span1, file$h, 165, 7, 4247);
    			add_location(li2, file$h, 161, 6, 4180);
    			add_location(strong3, file$h, 170, 7, 4329);
    			add_location(span2, file$h, 173, 7, 4376);
    			add_location(li3, file$h, 169, 6, 4317);
    			attr_dev(ul, "class", "profil-info");
    			add_location(ul, file$h, 141, 5, 3449);
    			attr_dev(button0, "class", "btn plain-btn mb-3");
    			add_location(button0, file$h, 179, 6, 4487);
    			attr_dev(button1, "class", "btn plain-btn");
    			add_location(button1, file$h, 180, 6, 4542);
    			attr_dev(div3, "class", "text-center");
    			add_location(div3, file$h, 178, 5, 4455);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, strong0);
    			append_dev(li0, t1);
    			append_dev(li0, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$currentUser*/ ctx[2].first_name);
    			append_dev(div0, label0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input1);
    			set_input_value(input1, /*$currentUser*/ ctx[2].last_name);
    			append_dev(div1, label1);
    			append_dev(ul, t5);
    			append_dev(ul, li1);
    			append_dev(li1, strong1);
    			append_dev(li1, t7);
    			append_dev(li1, span0);
    			append_dev(span0, t8);
    			append_dev(ul, t9);
    			append_dev(ul, li2);
    			append_dev(li2, strong2);
    			append_dev(li2, t11);
    			append_dev(li2, span1);
    			append_dev(span1, t12);
    			append_dev(ul, t13);
    			append_dev(ul, li3);
    			append_dev(li3, strong3);
    			append_dev(li3, t15);
    			append_dev(li3, span2);
    			append_dev(span2, t16);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, button0);
    			append_dev(div3, t19);
    			append_dev(div3, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$currentUser*/ 4 && input0.value !== /*$currentUser*/ ctx[2].first_name) {
    				set_input_value(input0, /*$currentUser*/ ctx[2].first_name);
    			}

    			if (dirty & /*$currentUser*/ 4 && input1.value !== /*$currentUser*/ ctx[2].last_name) {
    				set_input_value(input1, /*$currentUser*/ ctx[2].last_name);
    			}

    			if (dirty & /*$currentUser*/ 4 && t8_value !== (t8_value = /*$currentUser*/ ctx[2].free_fire_id + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*$currentUser*/ 4 && t12_value !== (t12_value = /*$currentUser*/ ctx[2].mobile + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$currentUser*/ 4 && t16_value !== (t16_value = /*$currentUser*/ ctx[2].email + "")) set_data_dev(t16, t16_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(141:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (94:4) {#if !editing}
    function create_if_block$a(ctx) {
    	let ul;
    	let li0;
    	let strong0;
    	let t1;
    	let span0;
    	let t2_value = /*$currentUser*/ ctx[2].first_name + "";
    	let t2;
    	let t3;
    	let t4_value = /*$currentUser*/ ctx[2].last_name + "";
    	let t4;
    	let t5;
    	let li1;
    	let strong1;
    	let t7;
    	let span1;
    	let t8_value = /*$currentUser*/ ctx[2].free_fire_id + "";
    	let t8;
    	let t9;
    	let li2;
    	let strong2;
    	let t11;
    	let span2;
    	let t12_value = /*$currentUser*/ ctx[2].mobile + "";
    	let t12;
    	let t13;
    	let li3;
    	let strong3;
    	let t15;
    	let span3;
    	let t16_value = /*$currentUser*/ ctx[2].email + "";
    	let t16;
    	let t17;
    	let div;
    	let button;
    	let t19;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			strong0 = element("strong");
    			strong0.textContent = "Name";
    			t1 = space();
    			span0 = element("span");
    			t2 = text$1(t2_value);
    			t3 = space();
    			t4 = text$1(t4_value);
    			t5 = space();
    			li1 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Free Fire ID";
    			t7 = space();
    			span1 = element("span");
    			t8 = text$1(t8_value);
    			t9 = space();
    			li2 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Mobile Number";
    			t11 = space();
    			span2 = element("span");
    			t12 = text$1(t12_value);
    			t13 = space();
    			li3 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Email";
    			t15 = space();
    			span3 = element("span");
    			t16 = text$1(t16_value);
    			t17 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Edit";
    			t19 = space();
    			a = element("a");
    			a.textContent = "Log Out";
    			add_location(strong0, file$h, 98, 7, 2547);
    			add_location(span0, file$h, 101, 7, 2593);
    			add_location(li0, file$h, 95, 6, 2387);
    			add_location(strong1, file$h, 106, 7, 2704);
    			add_location(span1, file$h, 109, 7, 2758);
    			add_location(li1, file$h, 105, 6, 2692);
    			add_location(strong2, file$h, 114, 7, 2846);
    			add_location(span2, file$h, 117, 7, 2901);
    			add_location(li2, file$h, 113, 6, 2834);
    			add_location(strong3, file$h, 122, 7, 2983);
    			add_location(span3, file$h, 125, 7, 3030);
    			add_location(li3, file$h, 121, 6, 2971);
    			attr_dev(ul, "class", "profil-info");
    			add_location(ul, file$h, 94, 5, 2356);
    			attr_dev(button, "class", "btn plain-btn mb-3 d-none");
    			add_location(button, file$h, 131, 6, 3141);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "btn plain-btn");
    			add_location(a, file$h, 132, 6, 3239);
    			attr_dev(div, "class", "text-center");
    			add_location(div, file$h, 130, 5, 3109);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, strong0);
    			append_dev(li0, t1);
    			append_dev(li0, span0);
    			append_dev(span0, t2);
    			append_dev(span0, t3);
    			append_dev(span0, t4);
    			append_dev(ul, t5);
    			append_dev(ul, li1);
    			append_dev(li1, strong1);
    			append_dev(li1, t7);
    			append_dev(li1, span1);
    			append_dev(span1, t8);
    			append_dev(ul, t9);
    			append_dev(ul, li2);
    			append_dev(li2, strong2);
    			append_dev(li2, t11);
    			append_dev(li2, span2);
    			append_dev(span2, t12);
    			append_dev(ul, t13);
    			append_dev(ul, li3);
    			append_dev(li3, strong3);
    			append_dev(li3, t15);
    			append_dev(li3, span3);
    			append_dev(span3, t16);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(div, t19);
    			append_dev(div, a);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false),
    					listen_dev(a, "click", /*click_handler_1*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$currentUser*/ 4 && t2_value !== (t2_value = /*$currentUser*/ ctx[2].first_name + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$currentUser*/ 4 && t4_value !== (t4_value = /*$currentUser*/ ctx[2].last_name + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$currentUser*/ 4 && t8_value !== (t8_value = /*$currentUser*/ ctx[2].free_fire_id + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*$currentUser*/ 4 && t12_value !== (t12_value = /*$currentUser*/ ctx[2].mobile + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$currentUser*/ 4 && t16_value !== (t16_value = /*$currentUser*/ ctx[2].email + "")) set_data_dev(t16, t16_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(94:4) {#if !editing}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let section0;
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let section1;
    	let div3;
    	let div2;
    	let ul;
    	let li0;
    	let a0;
    	let t3;
    	let li1;
    	let a1;
    	let t5;
    	let t6;
    	let div7;
    	let div6;
    	let div4;
    	let a2;
    	let span;
    	let t7;
    	let t8;
    	let div5;
    	let switch_instance;
    	let current;
    	let if_block0 = /*$currentUser*/ ctx[2].role == 'admin' && create_if_block_1$5(ctx);

    	function select_block_type(ctx, dirty) {
    		if (!/*editing*/ ctx[0]) return create_if_block$a;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);
    	var switch_value = /*tabs*/ ctx[4][/*selectedTab*/ ctx[1]];

    	function switch_props(ctx) {
    		return {
    			props: { onTeamCreate: /*func*/ ctx[10] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Dashboard";
    			t1 = space();
    			section1 = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Profile";
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Your Team";
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div4 = element("div");
    			a2 = element("a");
    			span = element("span");
    			t7 = space();
    			if_block1.c();
    			t8 = space();
    			div5 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$h, 47, 3, 1385);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$h, 46, 2, 1356);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$h, 45, 1, 1330);
    			attr_dev(section0, "class", "banner");
    			add_location(section0, file$h, 44, 0, 1304);
    			attr_dev(a0, "href", "/dashboard");
    			add_location(a0, file$h, 58, 5, 1599);
    			toggle_class(li0, "active", /*selectedTab*/ ctx[1] == 0);
    			add_location(li0, file$h, 57, 4, 1559);
    			attr_dev(a1, "href", "/dashboard/team");
    			add_location(a1, file$h, 63, 5, 1699);
    			toggle_class(li1, "active", /*selectedTab*/ ctx[1] == 1);
    			add_location(li1, file$h, 62, 4, 1659);
    			add_location(ul, file$h, 56, 3, 1550);
    			attr_dev(div2, "class", "container");
    			add_location(div2, file$h, 55, 2, 1523);
    			attr_dev(div3, "class", "profile-menu");
    			add_location(div3, file$h, 54, 1, 1494);
    			attr_dev(span, "class", "bg-icon");
    			add_location(span, file$h, 91, 5, 2293);
    			attr_dev(a2, "href", "#");
    			attr_dev(a2, "class", "upload-img");
    			add_location(a2, file$h, 90, 4, 2256);
    			attr_dev(div4, "class", "col-lg-4 col-sm-12 col-xs-12 border-right text-center d-lg-block");
    			toggle_class(div4, "d-none", /*selectedTab*/ ctx[1] == 1);
    			add_location(div4, file$h, 89, 3, 2143);
    			attr_dev(div5, "class", "col-lg-8 col-sm-12 col-xs-12 pl-50");
    			add_location(div5, file$h, 186, 3, 4676);
    			attr_dev(div6, "class", "row no-gutters");
    			add_location(div6, file$h, 88, 2, 2111);
    			attr_dev(div7, "class", "container");
    			add_location(div7, file$h, 87, 1, 2085);
    			attr_dev(section1, "class", "main-content");
    			add_location(section1, file$h, 53, 0, 1462);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div3);
    			append_dev(div3, div2);
    			append_dev(div2, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(ul, t5);
    			if (if_block0) if_block0.m(ul, null);
    			append_dev(section1, t6);
    			append_dev(section1, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div4);
    			append_dev(div4, a2);
    			append_dev(a2, span);
    			append_dev(div4, t7);
    			if_block1.m(div4, null);
    			append_dev(div6, t8);
    			append_dev(div6, div5);

    			if (switch_instance) {
    				mount_component(switch_instance, div5, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selectedTab*/ 2) {
    				toggle_class(li0, "active", /*selectedTab*/ ctx[1] == 0);
    			}

    			if (dirty & /*selectedTab*/ 2) {
    				toggle_class(li1, "active", /*selectedTab*/ ctx[1] == 1);
    			}

    			if (/*$currentUser*/ ctx[2].role == 'admin') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					if_block0.m(ul, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div4, null);
    				}
    			}

    			if (dirty & /*selectedTab*/ 2) {
    				toggle_class(div4, "d-none", /*selectedTab*/ ctx[1] == 1);
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*selectedTab*/ 2) switch_instance_changes.onTeamCreate = /*func*/ ctx[10];

    			if (switch_value !== (switch_value = /*tabs*/ ctx[4][/*selectedTab*/ ctx[1]])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div5, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section1);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $currentUser;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dashboard', slots, []);
    	let newTeamName = '';
    	let currentUser = User.getUser();
    	validate_store(currentUser, 'currentUser');
    	component_subscribe($$self, currentUser, value => $$invalidate(2, $currentUser = value));
    	let teamModel = Team.getInstance();
    	let currentTeam;
    	let editing = false;

    	const createTeam = async name => {
    		currentTeam = await teamModel.createTeam({ name });
    	};

    	if (window.localStorage.getItem('firstLogin') && $currentUser.contest) {
    		Modal.open(SuccessfullyEnteredContestModal);
    		window.localStorage.removeItem('firstLogin');
    	}

    	const currentPath = getHistory().currentPath;
    	let selectedTab = 0;
    	const tabs = [Profile, YourTeam];

    	currentPath.subscribe(p => {
    		if (p == '/dashboard') {
    			$$invalidate(1, selectedTab = 0);
    		} else if (p == '/dashboard/team') {
    			$$invalidate(1, selectedTab = 1);
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dashboard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(0, editing = true);
    	};

    	const click_handler_1 = e => {
    		//e.preventDefault();
    		User.logout();
    	}; //window.location.href = '/';

    	function input0_input_handler() {
    		$currentUser.first_name = this.value;
    		currentUser.set($currentUser);
    	}

    	function input1_input_handler() {
    		$currentUser.last_name = this.value;
    		currentUser.set($currentUser);
    	}

    	const click_handler_2 = e => {
    		$$invalidate(0, editing = false);
    	};

    	const func = () => {
    		$$invalidate(1, selectedTab = 1);
    	};

    	$$self.$capture_state = () => ({
    		InviteModal,
    		FindTeamModal,
    		Modal,
    		User,
    		Team,
    		TeamStore,
    		Profile,
    		YourTeam,
    		getHistory,
    		UserEdit,
    		Notify: notyf,
    		SuccessModal: SuccessfullyEnteredContestModal,
    		newTeamName,
    		currentUser,
    		teamModel,
    		currentTeam,
    		editing,
    		createTeam,
    		currentPath,
    		selectedTab,
    		tabs,
    		$currentUser
    	});

    	$$self.$inject_state = $$props => {
    		if ('newTeamName' in $$props) newTeamName = $$props.newTeamName;
    		if ('currentUser' in $$props) $$invalidate(3, currentUser = $$props.currentUser);
    		if ('teamModel' in $$props) teamModel = $$props.teamModel;
    		if ('currentTeam' in $$props) currentTeam = $$props.currentTeam;
    		if ('editing' in $$props) $$invalidate(0, editing = $$props.editing);
    		if ('selectedTab' in $$props) $$invalidate(1, selectedTab = $$props.selectedTab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		editing,
    		selectedTab,
    		$currentUser,
    		currentUser,
    		tabs,
    		click_handler,
    		click_handler_1,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler_2,
    		func
    	];
    }

    class Dashboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/pages/users/Dashboard-day-zero-player.svelte generated by Svelte v3.41.0 */
    const file$g = "src/pages/users/Dashboard-day-zero-player.svelte";

    function create_fragment$i(ctx) {
    	let section0;
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let section1;
    	let div3;
    	let div2;
    	let ul0;
    	let li0;
    	let a0;
    	let t3;
    	let li1;
    	let a1;
    	let t5;
    	let li2;
    	let a2;
    	let t7;
    	let li3;
    	let a3;
    	let t9;
    	let div26;
    	let div25;
    	let div5;
    	let ul1;
    	let li4;
    	let img0;
    	let img0_src_value;
    	let t10;
    	let strong0;
    	let t12;
    	let span0;
    	let t16;
    	let li5;
    	let strong1;
    	let t18;
    	let span1;
    	let t20;
    	let li6;
    	let strong2;
    	let t22;
    	let span2;
    	let t24;
    	let div4;
    	let button;
    	let t26;
    	let div24;
    	let div10;
    	let div9;
    	let div6;
    	let img1;
    	let img1_src_value;
    	let t27;
    	let div7;
    	let ul2;
    	let li7;
    	let strong3;
    	let t29;
    	let span3;
    	let t31;
    	let li8;
    	let strong4;
    	let t33;
    	let span4;
    	let t35;
    	let div8;
    	let ul3;
    	let li9;
    	let strong5;
    	let t37;
    	let span5;
    	let t39;
    	let div23;
    	let div19;
    	let div18;
    	let h6;
    	let t41;
    	let p;
    	let t43;
    	let div17;
    	let div12;
    	let img2;
    	let img2_src_value;
    	let t44;
    	let div11;
    	let strong6;
    	let t46;
    	let span6;
    	let t48;
    	let div14;
    	let img3;
    	let img3_src_value;
    	let t49;
    	let div13;
    	let strong7;
    	let t51;
    	let span7;
    	let t53;
    	let div15;
    	let img4;
    	let img4_src_value;
    	let t54;
    	let div16;
    	let img5;
    	let img5_src_value;
    	let t55;
    	let div22;
    	let div21;
    	let div20;
    	let a4;

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Dashboard";
    			t1 = space();
    			section1 = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Profile";
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Your Team";
    			t5 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "Schedule";
    			t7 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "Standings";
    			t9 = space();
    			div26 = element("div");
    			div25 = element("div");
    			div5 = element("div");
    			ul1 = element("ul");
    			li4 = element("li");
    			img0 = element("img");
    			t10 = space();
    			strong0 = element("strong");
    			strong0.textContent = "Name";
    			t12 = space();
    			span0 = element("span");
    			span0.textContent = `${/*currentUser*/ ctx[0].first_name}  ${/*currentUser*/ ctx[0].last_name}`;
    			t16 = space();
    			li5 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Free Fire ID";
    			t18 = space();
    			span1 = element("span");
    			span1.textContent = `${/*currentUser*/ ctx[0].free_fire_id}`;
    			t20 = space();
    			li6 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Mobile Number";
    			t22 = space();
    			span2 = element("span");
    			span2.textContent = `${/*currentUser*/ ctx[0].mobile_number}`;
    			t24 = space();
    			div4 = element("div");
    			button = element("button");
    			button.textContent = "Log Out";
    			t26 = space();
    			div24 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div6 = element("div");
    			img1 = element("img");
    			t27 = space();
    			div7 = element("div");
    			ul2 = element("ul");
    			li7 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Team Name";
    			t29 = space();
    			span3 = element("span");
    			span3.textContent = "Team Name Long";
    			t31 = space();
    			li8 = element("li");
    			strong4 = element("strong");
    			strong4.textContent = "Team ID";
    			t33 = space();
    			span4 = element("span");
    			span4.textContent = "QERT1124897";
    			t35 = space();
    			div8 = element("div");
    			ul3 = element("ul");
    			li9 = element("li");
    			strong5 = element("strong");
    			strong5.textContent = "Status";
    			t37 = space();
    			span5 = element("span");
    			span5.textContent = "Awaiting response";
    			t39 = space();
    			div23 = element("div");
    			div19 = element("div");
    			div18 = element("div");
    			h6 = element("h6");
    			h6.textContent = "Awaiting response";
    			t41 = space();
    			p = element("p");
    			p.textContent = "You request to join “TEAM NAME LONG” has been sent to the team leader. You will be notified if the team leader accepts your request to join the team.";
    			t43 = space();
    			div17 = element("div");
    			div12 = element("div");
    			img2 = element("img");
    			t44 = space();
    			div11 = element("div");
    			strong6 = element("strong");
    			strong6.textContent = "Victor Pacheco";
    			t46 = space();
    			span6 = element("span");
    			span6.textContent = "Team Leader";
    			t48 = space();
    			div14 = element("div");
    			img3 = element("img");
    			t49 = space();
    			div13 = element("div");
    			strong7 = element("strong");
    			strong7.textContent = "Jube Bowman";
    			t51 = space();
    			span7 = element("span");
    			span7.textContent = "Pending approval";
    			t53 = space();
    			div15 = element("div");
    			img4 = element("img");
    			t54 = space();
    			div16 = element("div");
    			img5 = element("img");
    			t55 = space();
    			div22 = element("div");
    			div21 = element("div");
    			div20 = element("div");
    			a4 = element("a");
    			a4.textContent = "Cancel & leave team";
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$g, 8, 3, 177);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$g, 7, 2, 148);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$g, 6, 1, 122);
    			attr_dev(section0, "class", "banner");
    			add_location(section0, file$g, 5, 0, 96);
    			attr_dev(a0, "href", "/userdashboarddayzero");
    			add_location(a0, file$g, 19, 5, 361);
    			add_location(li0, file$g, 18, 4, 351);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$g, 24, 5, 457);
    			attr_dev(li1, "class", "active");
    			add_location(li1, file$g, 23, 4, 432);
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$g, 29, 5, 520);
    			add_location(li2, file$g, 28, 4, 510);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$g, 34, 5, 582);
    			add_location(li3, file$g, 33, 4, 572);
    			add_location(ul0, file$g, 17, 3, 342);
    			attr_dev(div2, "class", "container");
    			add_location(div2, file$g, 16, 2, 315);
    			attr_dev(div3, "class", "profile-menu");
    			add_location(div3, file$g, 15, 1, 286);
    			attr_dev(img0, "class", "profile-pic-md rounded");
    			if (!src_url_equal(img0.src, img0_src_value = "images/profile-pic.jpg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "align", "Profile-pic");
    			add_location(img0, file$g, 46, 6, 783);
    			attr_dev(strong0, "class", "svelte-1bhd7ij");
    			add_location(strong0, file$g, 47, 6, 875);
    			attr_dev(span0, "class", "svelte-1bhd7ij");
    			add_location(span0, file$g, 50, 6, 918);
    			attr_dev(li4, "class", "svelte-1bhd7ij");
    			add_location(li4, file$g, 45, 5, 772);
    			attr_dev(strong1, "class", "svelte-1bhd7ij");
    			add_location(strong1, file$g, 55, 6, 1022);
    			attr_dev(span1, "class", "svelte-1bhd7ij");
    			add_location(span1, file$g, 58, 6, 1073);
    			attr_dev(li5, "class", "svelte-1bhd7ij");
    			add_location(li5, file$g, 54, 5, 1011);
    			attr_dev(strong2, "class", "svelte-1bhd7ij");
    			add_location(strong2, file$g, 63, 6, 1155);
    			attr_dev(span2, "class", "svelte-1bhd7ij");
    			add_location(span2, file$g, 66, 6, 1207);
    			attr_dev(li6, "class", "svelte-1bhd7ij");
    			add_location(li6, file$g, 62, 5, 1144);
    			attr_dev(ul1, "class", "profil-info");
    			add_location(ul1, file$g, 44, 4, 742);
    			attr_dev(button, "class", "btn plain-btn");
    			add_location(button, file$g, 72, 5, 1319);
    			attr_dev(div4, "class", "text-center");
    			add_location(div4, file$g, 71, 4, 1288);
    			attr_dev(div5, "class", "col-4 border-right");
    			add_location(div5, file$g, 43, 3, 705);
    			attr_dev(img1, "class", "team-logo svelte-1bhd7ij");
    			if (!src_url_equal(img1.src, img1_src_value = "images/team-pic.jpg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "Team");
    			add_location(img1, file$g, 81, 7, 1540);
    			attr_dev(div6, "class", "col-4");
    			add_location(div6, file$g, 80, 6, 1513);
    			attr_dev(strong3, "class", "svelte-1bhd7ij");
    			add_location(strong3, file$g, 86, 9, 1695);
    			attr_dev(span3, "class", "svelte-1bhd7ij");
    			add_location(span3, file$g, 87, 9, 1731);
    			attr_dev(li7, "class", "svelte-1bhd7ij");
    			add_location(li7, file$g, 85, 8, 1681);
    			attr_dev(strong4, "class", "svelte-1bhd7ij");
    			add_location(strong4, file$g, 90, 9, 1795);
    			attr_dev(span4, "class", "svelte-1bhd7ij");
    			add_location(span4, file$g, 91, 9, 1829);
    			attr_dev(li8, "class", "svelte-1bhd7ij");
    			add_location(li8, file$g, 89, 8, 1781);
    			attr_dev(ul2, "class", "team-details svelte-1bhd7ij");
    			add_location(ul2, file$g, 84, 7, 1647);
    			attr_dev(div7, "class", "col-4");
    			add_location(div7, file$g, 83, 6, 1620);
    			attr_dev(strong5, "class", "svelte-1bhd7ij");
    			add_location(strong5, file$g, 98, 9, 1975);
    			attr_dev(span5, "class", "svelte-1bhd7ij");
    			add_location(span5, file$g, 99, 9, 2008);
    			attr_dev(li9, "class", "svelte-1bhd7ij");
    			add_location(li9, file$g, 97, 8, 1961);
    			attr_dev(ul3, "class", "team-details svelte-1bhd7ij");
    			add_location(ul3, file$g, 96, 7, 1927);
    			attr_dev(div8, "class", "col-4");
    			add_location(div8, file$g, 95, 6, 1900);
    			attr_dev(div9, "class", "row");
    			add_location(div9, file$g, 79, 5, 1489);
    			attr_dev(div10, "class", "survey-block teacm-full-details p-40");
    			add_location(div10, file$g, 78, 4, 1433);
    			attr_dev(h6, "class", "title svelte-1bhd7ij");
    			add_location(h6, file$g, 108, 7, 2217);
    			attr_dev(p, "class", "response-desc svelte-1bhd7ij");
    			add_location(p, file$g, 111, 7, 2282);
    			attr_dev(img2, "class", "pic profile-pic-sm rounded svelte-1bhd7ij");
    			if (!src_url_equal(img2.src, img2_src_value = "images/profile-pic.jpg")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "align", "Profile-pic");
    			add_location(img2, file$g, 116, 9, 2544);
    			attr_dev(strong6, "class", "player-name svelte-1bhd7ij");
    			add_location(strong6, file$g, 118, 10, 2679);
    			attr_dev(span6, "class", "player-position svelte-1bhd7ij");
    			add_location(span6, file$g, 121, 10, 2764);
    			attr_dev(div11, "class", "player-info svelte-1bhd7ij");
    			add_location(div11, file$g, 117, 9, 2643);
    			attr_dev(div12, "class", "player svelte-1bhd7ij");
    			add_location(div12, file$g, 115, 8, 2514);
    			attr_dev(img3, "class", "pic profile-pic-sm rounded svelte-1bhd7ij");
    			if (!src_url_equal(img3.src, img3_src_value = "images/profile-pic.jpg")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "align", "Profile-pic");
    			add_location(img3, file$g, 127, 9, 2920);
    			attr_dev(strong7, "class", "player-name svelte-1bhd7ij");
    			add_location(strong7, file$g, 129, 10, 3055);
    			attr_dev(span7, "class", "player-position svelte-1bhd7ij");
    			add_location(span7, file$g, 132, 10, 3137);
    			attr_dev(div13, "class", "player-info svelte-1bhd7ij");
    			add_location(div13, file$g, 128, 9, 3019);
    			attr_dev(div14, "class", "player player-pending svelte-1bhd7ij");
    			add_location(div14, file$g, 126, 8, 2875);
    			attr_dev(img4, "class", "pic profile-pic-sm rounded svelte-1bhd7ij");
    			if (!src_url_equal(img4.src, img4_src_value = "images/profile-pic.jpg")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "align", "Profile-pic");
    			add_location(img4, file$g, 138, 9, 3298);
    			attr_dev(div15, "class", "player player-pending svelte-1bhd7ij");
    			add_location(div15, file$g, 137, 8, 3253);
    			attr_dev(img5, "class", "pic profile-pic-sm rounded svelte-1bhd7ij");
    			if (!src_url_equal(img5.src, img5_src_value = "images/profile-pic.jpg")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "align", "Profile-pic");
    			add_location(img5, file$g, 142, 9, 3466);
    			attr_dev(div16, "class", "player player-pending svelte-1bhd7ij");
    			add_location(div16, file$g, 141, 8, 3421);
    			attr_dev(div17, "class", "d-flex");
    			add_location(div17, file$g, 114, 7, 2485);
    			attr_dev(div18, "class", "col-12");
    			add_location(div18, file$g, 107, 6, 2189);
    			attr_dev(div19, "class", "row");
    			add_location(div19, file$g, 106, 5, 2165);
    			attr_dev(a4, "href", "#");
    			attr_dev(a4, "class", "btn secondary-btn");
    			add_location(a4, file$g, 150, 8, 3695);
    			attr_dev(div20, "class", "mt-40");
    			add_location(div20, file$g, 149, 7, 3667);
    			attr_dev(div21, "class", "col-12");
    			add_location(div21, file$g, 148, 6, 3639);
    			attr_dev(div22, "class", "row");
    			add_location(div22, file$g, 147, 5, 3615);
    			attr_dev(div23, "class", "survey-block awating-response p-40 mt-2");
    			add_location(div23, file$g, 105, 4, 2106);
    			attr_dev(div24, "class", "col-8 pl-50");
    			add_location(div24, file$g, 77, 3, 1403);
    			attr_dev(div25, "class", "row");
    			add_location(div25, file$g, 42, 2, 684);
    			attr_dev(div26, "class", "container");
    			add_location(div26, file$g, 41, 1, 658);
    			attr_dev(section1, "class", "main-content");
    			add_location(section1, file$g, 14, 0, 254);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div3);
    			append_dev(div3, div2);
    			append_dev(div2, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a0);
    			append_dev(ul0, t3);
    			append_dev(ul0, li1);
    			append_dev(li1, a1);
    			append_dev(ul0, t5);
    			append_dev(ul0, li2);
    			append_dev(li2, a2);
    			append_dev(ul0, t7);
    			append_dev(ul0, li3);
    			append_dev(li3, a3);
    			append_dev(section1, t9);
    			append_dev(section1, div26);
    			append_dev(div26, div25);
    			append_dev(div25, div5);
    			append_dev(div5, ul1);
    			append_dev(ul1, li4);
    			append_dev(li4, img0);
    			append_dev(li4, t10);
    			append_dev(li4, strong0);
    			append_dev(li4, t12);
    			append_dev(li4, span0);
    			append_dev(ul1, t16);
    			append_dev(ul1, li5);
    			append_dev(li5, strong1);
    			append_dev(li5, t18);
    			append_dev(li5, span1);
    			append_dev(ul1, t20);
    			append_dev(ul1, li6);
    			append_dev(li6, strong2);
    			append_dev(li6, t22);
    			append_dev(li6, span2);
    			append_dev(div5, t24);
    			append_dev(div5, div4);
    			append_dev(div4, button);
    			append_dev(div25, t26);
    			append_dev(div25, div24);
    			append_dev(div24, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div6);
    			append_dev(div6, img1);
    			append_dev(div9, t27);
    			append_dev(div9, div7);
    			append_dev(div7, ul2);
    			append_dev(ul2, li7);
    			append_dev(li7, strong3);
    			append_dev(li7, t29);
    			append_dev(li7, span3);
    			append_dev(ul2, t31);
    			append_dev(ul2, li8);
    			append_dev(li8, strong4);
    			append_dev(li8, t33);
    			append_dev(li8, span4);
    			append_dev(div9, t35);
    			append_dev(div9, div8);
    			append_dev(div8, ul3);
    			append_dev(ul3, li9);
    			append_dev(li9, strong5);
    			append_dev(li9, t37);
    			append_dev(li9, span5);
    			append_dev(div24, t39);
    			append_dev(div24, div23);
    			append_dev(div23, div19);
    			append_dev(div19, div18);
    			append_dev(div18, h6);
    			append_dev(div18, t41);
    			append_dev(div18, p);
    			append_dev(div18, t43);
    			append_dev(div18, div17);
    			append_dev(div17, div12);
    			append_dev(div12, img2);
    			append_dev(div12, t44);
    			append_dev(div12, div11);
    			append_dev(div11, strong6);
    			append_dev(div11, t46);
    			append_dev(div11, span6);
    			append_dev(div17, t48);
    			append_dev(div17, div14);
    			append_dev(div14, img3);
    			append_dev(div14, t49);
    			append_dev(div14, div13);
    			append_dev(div13, strong7);
    			append_dev(div13, t51);
    			append_dev(div13, span7);
    			append_dev(div17, t53);
    			append_dev(div17, div15);
    			append_dev(div15, img4);
    			append_dev(div17, t54);
    			append_dev(div17, div16);
    			append_dev(div16, img5);
    			append_dev(div23, t55);
    			append_dev(div23, div22);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, a4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dashboard_day_zero_player', slots, []);
    	let currentUser = User.getUser();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dashboard_day_zero_player> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ User, currentUser });

    	$$self.$inject_state = $$props => {
    		if ('currentUser' in $$props) $$invalidate(0, currentUser = $$props.currentUser);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentUser];
    }

    class Dashboard_day_zero_player extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard_day_zero_player",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src/pages/PrivacyPolicy.svelte generated by Svelte v3.41.0 */

    const file$f = "src/pages/PrivacyPolicy.svelte";

    function create_fragment$h(ctx) {
    	let section;
    	let div0;
    	let h1;
    	let t1;
    	let div7;
    	let div6;
    	let div1;
    	let p0;
    	let t3;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let h30;
    	let t5;
    	let p1;
    	let t7;
    	let h31;
    	let t9;
    	let pwe;
    	let p2;
    	let strong0;
    	let t11;
    	let t12;
    	let p3;
    	let strong1;
    	let t14;
    	let t15;
    	let p4;
    	let strong2;
    	let t17;
    	let t18;
    	let p5;
    	let t19;
    	let a0;
    	let t21;
    	let t22;
    	let p6;
    	let t24;
    	let p7;
    	let strong3;
    	let t26;
    	let a1;
    	let t28;
    	let p8;
    	let strong4;
    	let t30;
    	let t31;
    	let h32;
    	let t33;
    	let p9;
    	let t35;
    	let ul;
    	let li0;
    	let t37;
    	let li1;
    	let t39;
    	let li2;
    	let t41;
    	let li3;
    	let t43;
    	let li4;
    	let t45;
    	let li5;
    	let t47;
    	let p10;
    	let t49;
    	let h33;
    	let t51;
    	let p11;
    	let t53;
    	let p12;
    	let t55;
    	let h34;
    	let t57;
    	let p13;
    	let t59;
    	let h35;
    	let t61;
    	let p14;
    	let strong5;
    	let t63;
    	let t64;
    	let p15;
    	let strong6;
    	let t66;
    	let a2;
    	let t68;
    	let p16;
    	let strong7;
    	let t70;
    	let t71;
    	let p17;
    	let strong8;
    	let t73;
    	let t74;
    	let h36;
    	let t76;
    	let p18;
    	let t78;
    	let h37;
    	let t80;
    	let p19;
    	let t82;
    	let h38;
    	let t84;
    	let p20;
    	let t86;
    	let h39;
    	let t88;
    	let p21;
    	let t90;
    	let h310;
    	let t92;
    	let p22;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Privacy Policy";
    			t1 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = "In this Privacy Policy (\"Policy\"), we, Qualcomm Incorporated and our subsidiaries (collectively \"we\", \"us\", or \"our\"), provide information about how we collect, use, process, and transfer personal data. Qualcomm Incorporated and our subsidiaries are a global organization sharing the data we manage across businesses (legal entities), business processes, and information systems around the world. Therefore, for this Policy, we use the term \"personal data\" broadly to cover the many privacy and data protection laws applicable to us; generally \"personal data\" means information related to an identified natural person or that could reasonably be used (by itself or in combination with other data available) to identify a natural person.";
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			h30 = element("h3");
    			h30.textContent = "Scope";
    			t5 = space();
    			p1 = element("p");
    			p1.textContent = "This Policy applies to our websites, products, services, software, or apps on which we post a direct link to this Policy or refer to within this Policy (collectively the \"Services\"). This Policy covers data collected through the Services and not any data collection or processing practices of other services that maintain their own, separate privacy policies. Occasionally, we refer to this Policy in relation to surveys and special-purpose web pages, for example, our Careers web pages; under such circumstances, this Policy applies as modified in the particular notice or consent request (e.g., with respect to types of data collected or purposes of collection).";
    			t7 = space();
    			h31 = element("h3");
    			h31.textContent = "Types of Data and Collection Methods";
    			t9 = space();
    			pwe = element("pwe");
    			p2 = element("p");
    			strong0 = element("strong");
    			strong0.textContent = "Data you submit.";
    			t11 = text$1(" We collect your name, email address(es), mailing address(es), telephone number(s), and data related to the business you represent when you request information from us, register,\n\t\t                        order a product or service, or otherwise intentionally send us such information. In connection with chargeable services, we will also collect payment information (e.g., credit card number and related verification\n\t\t                        data), phone number, and billing and shipping addresses.");
    			t12 = space();
    			p3 = element("p");
    			strong1 = element("strong");
    			strong1.textContent = "Data we automatically collect from our websites.";
    			t14 = text$1(" When you visit one of our websites, we collect general data from your computer or mobile device such as your browser type, operating system, IP\n\t\t                        address and the domain name from which you accessed the site, and if you are accessing our site with your mobile device, type of mobile device. In addition, we collect data about how you use our websites, such as the\n\t\t                        date and time you visit the site, the areas or pages of the site that you visit, the amount of time you spend viewing the site, the number of times you return to the site and other click-stream data.");
    			t15 = space();
    			p4 = element("p");
    			strong2 = element("strong");
    			strong2.textContent = "Cookies.";
    			t17 = text$1("We use cookies, web beacons, or similar technologies to collect data about your use of our websites or web apps. A cookie is a small text file that is stored on the hard drive of your\n\t\t                        computer or device when you access the site. We use cookies to help operate our sites and services, including to: (1) remember you so you don’t have to enter the same information when you return to the site, (2)\n\t\t                        provide you with customized content or offers on the site; (3) develop aggregate statistics to help monitor site performance, conduct research, improve our content and services, and (4) help protect the security of\n\t\t                        our sites and services.");
    			t18 = space();
    			p5 = element("p");
    			t19 = text$1("We also allow other companies such as web analytics partners, advertisers, or ad networks to set or access their cookies or web beacons (also referred to as 1x1 pixel.gifs or action tags) on the site. For example, we\n\t\t                        use third party advertising companies to serve ads on our behalf across the Internet. These third-party advertising companies employ cookies and web beacons to measure and improve the effectiveness of ads for their\n\t\t                        clients, including us. To do so, these companies use data about your visits to our site and other websites over time. This data may include: date/time of banner ad shown, a unique identifier contained in their\n\t\t                        cookie, and the IP address of your device. This data can also be used to personalize ads so that you are more likely to see ads about goods and services of interest to you. If you would like more information about\n\t\t                        this practice and your choices about personalized advertising, visit ");
    			a0 = element("a");
    			a0.textContent = "this opt out article";
    			t21 = text$1(".");
    			t22 = space();
    			p6 = element("p");
    			p6.textContent = "You are free to decline cookies, but by doing so, you may not be able to use some features on the site or take full advantage of our offerings. Check the \"Help\" menu of your browser to learn how to change your cookie\n\t\t                        preferences. For further information, please see our Cookie Policy.";
    			t24 = space();
    			p7 = element("p");
    			strong3 = element("strong");
    			strong3.textContent = "Software and apps:";
    			t26 = text$1("Qualcomm Incorporated's subsidiaries create a variety of software and applications for mobile devices that may help improve mobile device performance, conserve battery power,\n\t\t                        improve device security, or offer other benefits. Through these software applications, we may collect location data, unique identifiers (such as a chipset serial number or international subscriber ID), data about the\n\t\t                        applications installed and/or running on the device, configuration data such as the make, model, and wireless carrier, the operating system and version data, software build data, and data about the performance of the\n\t\t                        device such as performance of the chipset, battery use, and thermal data. ");
    			a1 = element("a");
    			a1.textContent = "Learn More";
    			t28 = space();
    			p8 = element("p");
    			strong4 = element("strong");
    			strong4.textContent = "Third Party Sources: ";
    			t30 = text$1("We may also obtain personal data from third party sources such as data brokers, social networks, other partners, or public sources.");
    			t31 = space();
    			h32 = element("h3");
    			h32.textContent = "Collection Purposes, Use of Data";
    			t33 = space();
    			p9 = element("p");
    			p9.textContent = "We collect and process personal data about you with your consent and/or as necessary to provide the products you use, operate our business, meet our contractual and legal obligations, protect the security of our\n\t\t                        systems and our customers, or fulfil other legitimate interests. The purposes for which we collect and use data include:";
    			t35 = space();
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "To respond to the request that you sent us such as your request for information, or your request to subscribe to a service or purchase a product;";
    			t37 = space();
    			li1 = element("li");
    			li1.textContent = "To provide, manage, maintain, and secure the Service(s) you request;";
    			t39 = space();
    			li2 = element("li");
    			li2.textContent = "To operate and improve our business, including to administer, protect, and improve our services and our systems, to develop new products and services, and for other internal business purposes;";
    			t41 = space();
    			li3 = element("li");
    			li3.textContent = "To better understand the preferences of the users of our Services, compile aggregated statistics about usage of our Services, and help personalize your experience of our website and Services;";
    			t43 = space();
    			li4 = element("li");
    			li4.textContent = "To provide you with information about our technologies, product or service releases, news, and other communications; and";
    			t45 = space();
    			li5 = element("li");
    			li5.textContent = "Any other use we describe in this Policy or at the point where we collect the data.";
    			t47 = space();
    			p10 = element("p");
    			p10.textContent = "To achieve these purposes, and to the extent permitted by applicable law, we may combine the various types of data that we collect from different on and offline sources.";
    			t49 = space();
    			h33 = element("h3");
    			h33.textContent = "Where We Store and Process Data";
    			t51 = space();
    			p11 = element("p");
    			p11.textContent = "We store and process data in the United States and on servers around in the world, including, without limitation, Asia and the European Economic Area. Wherever we store or process personal data pursuant to this\n\t\t                        Policy, we take measures designed to ensure that the data is processed in accordance with this Policy and in compliance with applicable law.";
    			t53 = space();
    			p12 = element("p");
    			p12.textContent = "We transfer personal data from the European Economic Area to other countries, some of which have not been determined by the European Commission to have an adequate level of data protection. When we do so, we use a\n\t\t                        variety of legal mechanisms to effectuate the transfer (such as your consent or legal contracts).";
    			t55 = space();
    			h34 = element("h3");
    			h34.textContent = "Disclosures of Personal Data";
    			t57 = space();
    			p13 = element("p");
    			p13.textContent = "We do not sell your personal data. We do, however, share your data with Qualcomm subsidiaries. For example, we may share your request to subscribe to newsletter regarding certain products or services with the\n\t\t                        applicable Qualcomm subsidiary. We may also share your personal data with service providers who process the data on our behalf for the purposes set forth in this Policy. We may also offer training or other services\n\t\t                        to the employees and workers of our business customers. In such cases, we may share data relating to the use of our training and other services with the identified business customers for their business use. We may\n\t\t                        also share your data as required by law or in the interest of protecting or exercising our or others' legal rights, e.g., without limitation, in connection with requests from law enforcement officials and in\n\t\t                        connection with court proceedings. We may share or transfer your data in connection with a prospective or actual sale, merger, transfer or other reorganization of all or parts of our business, including related\n\t\t                        negotiations. Finally, we may also share your personal data where you have granted us permission.";
    			t59 = space();
    			h35 = element("h3");
    			h35.textContent = "Your Choices";
    			t61 = space();
    			p14 = element("p");
    			strong5 = element("strong");
    			strong5.textContent = "Opt-In/Out.";
    			t63 = text$1(" In some circumstances, such as email marketing, we offer you the ability to opt-in or opt-out of some kinds of data collection, use, or sharing. In such circumstances, we will respect\n\t\t                        your choice.");
    			t64 = space();
    			p15 = element("p");
    			strong6 = element("strong");
    			strong6.textContent = "Data Subject Rights.";
    			t66 = text$1(" The laws of some countries or states allow you to request access, correction, deletion, restriction, or other rights with respect to your personal data.\n\t\t                        ");
    			a2 = element("a");
    			a2.textContent = "Click here to exercise those rights.";
    			t68 = space();
    			p16 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Do Not Track. ";
    			t70 = text$1("We do not currently respond to \"Do Not Track\" (\"DNT\") signals sent by web browsers. A uniform standard has not yet been adopted to determine how DNT signals should be interpreted and\n\t\t                        what actions should be taken by websites and third parties that receive them. However, you may use a variety of other means of controlling data collection and use, including cookie controls in your browser settings\n\t\t                        and the personalized advertising controls described in the Cookies section above.");
    			t71 = space();
    			p17 = element("p");
    			strong8 = element("strong");
    			strong8.textContent = "Non-Discrimination/Financial Incentives. ";
    			t73 = text$1("The laws of some countries or states prohibit us from discriminating against you for exercising your rights described above and imposes requirements on any\n\t\t                        financial incentives offered to you related to your information. If we offer any such financial incentives, we will describe them in more detail here.");
    			t74 = space();
    			h36 = element("h3");
    			h36.textContent = "Retention";
    			t76 = space();
    			p18 = element("p");
    			p18.textContent = "We retain personal data while your account is active, or as needed to provide you services. We will delete or de-identify personal data within a reasonable time after the data is no longer necessary for the business\n\t\t                        purpose for which it was collected. We will, however, retain and use personal data as necessary to comply with our legal obligations, resolve disputes, and enforce our agreements.";
    			t78 = space();
    			h37 = element("h3");
    			h37.textContent = "Security";
    			t80 = space();
    			p19 = element("p");
    			p19.textContent = "Transmissions over the Internet are never 100% secure or error-free. However, we take reasonable steps to protect your data from loss, misuse, and unauthorized access, disclosure, alteration, and destruction. It is\n\t\t                        your responsibility to safeguard your passwords and User IDs and to notify us using one of the contact methods listed below if you ever suspect that your password or User ID for one of our Services has been\n\t\t                        compromised. You are solely responsible for any unauthorized use of our Services conducted via your password and User ID.";
    			t82 = space();
    			h38 = element("h3");
    			h38.textContent = "Children's Privacy";
    			t84 = space();
    			p20 = element("p");
    			p20.textContent = "Our Services are intended for adults. We do not intentionally or knowingly collect personally-identifiable information from children as defined by applicable law and we request that children not submit any personal\n\t\t                        data to us.";
    			t86 = space();
    			h39 = element("h3");
    			h39.textContent = "Amendments";
    			t88 = space();
    			p21 = element("p");
    			p21.textContent = "We reserve the right to change, modify, add, or remove portions of this Policy at any time, but will alert you that changes have been made by indicating on the Policy the date it was last updated. If we change the\n\t\t                        Policy in a material way, we will provide appropriate online notice to you at least thirty days in advance and/or obtain your express consent as required by law. When you visit our websites or use our Services, you\n\t\t                        are accepting the current version of this Policy. We recommend that users revisit this Policy on occasion to learn of any changes.";
    			t90 = space();
    			h310 = element("h3");
    			h310.textContent = "Contact Us";
    			t92 = space();
    			p22 = element("p");
    			p22.textContent = "To contact us, send us an email at privacy[at]qualcomm[dot]com, or write to us at Qualcomm Incorporated, Attn. Privacy Counsel, 5775 Morehouse Drive, San Diego, CA 92121.";
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$f, 2, 2, 52);
    			attr_dev(div0, "class", "container");
    			add_location(div0, file$f, 1, 1, 26);
    			attr_dev(section, "class", "banner");
    			add_location(section, file$f, 0, 0, 0);
    			add_location(p0, file$f, 10, 4, 199);
    			attr_dev(div1, "class", "policy");
    			add_location(div1, file$f, 9, 2, 174);
    			add_location(h30, file$f, 18, 18, 1289);
    			add_location(p1, file$f, 19, 18, 1322);
    			add_location(h31, file$f, 22, 18, 2054);
    			add_location(strong0, file$f, 25, 26, 2379);
    			add_location(p2, file$f, 24, 22, 2349);
    			add_location(strong1, file$f, 30, 26, 2992);
    			add_location(p3, file$f, 29, 22, 2962);
    			add_location(strong2, file$f, 35, 26, 3750);
    			add_location(p4, file$f, 34, 22, 3720);
    			attr_dev(a0, "href", "http://www.networkadvertising.org/choices/");
    			add_location(a0, file$f, 45, 95, 5596);
    			add_location(p5, file$f, 40, 22, 4537);
    			add_location(p6, file$f, 47, 22, 5724);
    			add_location(strong3, file$f, 52, 26, 6144);
    			attr_dev(a1, "href", "https://www.qualcomm.com/site/privacy/services");
    			add_location(a1, file$f, 55, 100, 6940);
    			add_location(p7, file$f, 51, 22, 6114);
    			add_location(strong4, file$f, 57, 25, 7064);
    			add_location(p8, file$f, 57, 22, 7061);
    			add_location(h32, file$f, 58, 22, 7260);
    			add_location(p9, file$f, 59, 22, 7324);
    			add_location(li0, file$f, 64, 26, 7793);
    			add_location(li1, file$f, 65, 26, 7974);
    			add_location(li2, file$f, 66, 26, 8078);
    			add_location(li3, file$f, 67, 26, 8306);
    			add_location(li4, file$f, 68, 26, 8533);
    			add_location(li5, file$f, 69, 26, 8689);
    			add_location(ul, file$f, 63, 22, 7762);
    			add_location(p10, file$f, 71, 22, 8832);
    			add_location(h33, file$f, 72, 22, 9031);
    			add_location(p11, file$f, 73, 22, 9094);
    			add_location(p12, file$f, 77, 22, 9551);
    			add_location(h34, file$f, 81, 22, 9968);
    			add_location(p13, file$f, 82, 22, 10028);
    			add_location(h35, file$f, 90, 22, 11392);
    			add_location(strong5, file$f, 92, 26, 11466);
    			add_location(p14, file$f, 91, 22, 11436);
    			add_location(strong6, file$f, 96, 26, 11797);
    			attr_dev(a2, "href", "https://app.onetrust.com/app/#/webform/7ab89abb-0d42-492a-a324-0570883e2c11");
    			add_location(a2, file$f, 97, 26, 12014);
    			add_location(p15, file$f, 95, 22, 11767);
    			add_location(strong7, file$f, 100, 26, 12220);
    			add_location(p16, file$f, 99, 22, 12190);
    			add_location(strong8, file$f, 105, 26, 12862);
    			add_location(p17, file$f, 104, 22, 12832);
    			add_location(h36, file$f, 108, 22, 13302);
    			add_location(p18, file$f, 109, 22, 13343);
    			add_location(h37, file$f, 113, 22, 13844);
    			add_location(p19, file$f, 114, 22, 13884);
    			add_location(h38, file$f, 119, 22, 14559);
    			add_location(p20, file$f, 120, 22, 14609);
    			add_location(h39, file$f, 124, 22, 14941);
    			add_location(p21, file$f, 125, 22, 14983);
    			add_location(h310, file$f, 130, 22, 15674);
    			add_location(p22, file$f, 131, 22, 15716);
    			attr_dev(pwe, "means", "");
    			attr_dev(pwe, "a", "");
    			attr_dev(pwe, "are", "");
    			attr_dev(pwe, "asked", "");
    			attr_dev(pwe, "below.", "");
    			attr_dev(pwe, "choices", "");
    			attr_dev(pwe, "collect", "");
    			attr_dev(pwe, "collect.", "");
    			attr_dev(pwe, "data", "");
    			attr_dev(pwe, "described", "");
    			attr_dev(pwe, "have", "");
    			attr_dev(pwe, "about", "");
    			attr_dev(pwe, "of", "");
    			attr_dev(pwe, "personal", "");
    			attr_dev(pwe, "provide", "");
    			attr_dev(pwe, "the", "");
    			attr_dev(pwe, "through", "");
    			attr_dev(pwe, "to", "");
    			attr_dev(pwe, "us", "");
    			attr_dev(pwe, "variety", "");
    			attr_dev(pwe, "we", "");
    			attr_dev(pwe, "when", "");
    			attr_dev(pwe, "you", "");
    			add_location(pwe, file$f, 23, 18, 2118);
    			attr_dev(div2, "class", "box__Box-wl6cgm-0 hGvUHW html__StyledRawHtml-sc-1lp5b6w-0 lfIMjV");
    			attr_dev(div2, "theme", "[object Object]");
    			add_location(div2, file$f, 17, 14, 1168);
    			attr_dev(div3, "class", "box__Box-wl6cgm-0 DIEuN");
    			add_location(div3, file$f, 16, 10, 1116);
    			attr_dev(div4, "class", "flex__Flex-sc-1eu16dv-0 bMsmdi wrappers__WrapperElement-sc-1ja1m3i-0 kXKNsg");
    			add_location(div4, file$f, 15, 6, 1016);
    			attr_dev(div5, "class", "policy-name");
    			add_location(div5, file$f, 14, 2, 984);
    			attr_dev(div6, "class", "policy-text svelte-136g15l");
    			add_location(div6, file$f, 8, 1, 146);
    			attr_dev(div7, "class", "container");
    			add_location(div7, file$f, 7, 0, 121);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div1);
    			append_dev(div1, p0);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, h30);
    			append_dev(div2, t5);
    			append_dev(div2, p1);
    			append_dev(div2, t7);
    			append_dev(div2, h31);
    			append_dev(div2, t9);
    			append_dev(div2, pwe);
    			append_dev(pwe, p2);
    			append_dev(p2, strong0);
    			append_dev(p2, t11);
    			append_dev(pwe, t12);
    			append_dev(pwe, p3);
    			append_dev(p3, strong1);
    			append_dev(p3, t14);
    			append_dev(pwe, t15);
    			append_dev(pwe, p4);
    			append_dev(p4, strong2);
    			append_dev(p4, t17);
    			append_dev(pwe, t18);
    			append_dev(pwe, p5);
    			append_dev(p5, t19);
    			append_dev(p5, a0);
    			append_dev(p5, t21);
    			append_dev(pwe, t22);
    			append_dev(pwe, p6);
    			append_dev(pwe, t24);
    			append_dev(pwe, p7);
    			append_dev(p7, strong3);
    			append_dev(p7, t26);
    			append_dev(p7, a1);
    			append_dev(pwe, t28);
    			append_dev(pwe, p8);
    			append_dev(p8, strong4);
    			append_dev(p8, t30);
    			append_dev(pwe, t31);
    			append_dev(pwe, h32);
    			append_dev(pwe, t33);
    			append_dev(pwe, p9);
    			append_dev(pwe, t35);
    			append_dev(pwe, ul);
    			append_dev(ul, li0);
    			append_dev(ul, t37);
    			append_dev(ul, li1);
    			append_dev(ul, t39);
    			append_dev(ul, li2);
    			append_dev(ul, t41);
    			append_dev(ul, li3);
    			append_dev(ul, t43);
    			append_dev(ul, li4);
    			append_dev(ul, t45);
    			append_dev(ul, li5);
    			append_dev(pwe, t47);
    			append_dev(pwe, p10);
    			append_dev(pwe, t49);
    			append_dev(pwe, h33);
    			append_dev(pwe, t51);
    			append_dev(pwe, p11);
    			append_dev(pwe, t53);
    			append_dev(pwe, p12);
    			append_dev(pwe, t55);
    			append_dev(pwe, h34);
    			append_dev(pwe, t57);
    			append_dev(pwe, p13);
    			append_dev(pwe, t59);
    			append_dev(pwe, h35);
    			append_dev(pwe, t61);
    			append_dev(pwe, p14);
    			append_dev(p14, strong5);
    			append_dev(p14, t63);
    			append_dev(pwe, t64);
    			append_dev(pwe, p15);
    			append_dev(p15, strong6);
    			append_dev(p15, t66);
    			append_dev(p15, a2);
    			append_dev(pwe, t68);
    			append_dev(pwe, p16);
    			append_dev(p16, strong7);
    			append_dev(p16, t70);
    			append_dev(pwe, t71);
    			append_dev(pwe, p17);
    			append_dev(p17, strong8);
    			append_dev(p17, t73);
    			append_dev(pwe, t74);
    			append_dev(pwe, h36);
    			append_dev(pwe, t76);
    			append_dev(pwe, p18);
    			append_dev(pwe, t78);
    			append_dev(pwe, h37);
    			append_dev(pwe, t80);
    			append_dev(pwe, p19);
    			append_dev(pwe, t82);
    			append_dev(pwe, h38);
    			append_dev(pwe, t84);
    			append_dev(pwe, p20);
    			append_dev(pwe, t86);
    			append_dev(pwe, h39);
    			append_dev(pwe, t88);
    			append_dev(pwe, p21);
    			append_dev(pwe, t90);
    			append_dev(pwe, h310);
    			append_dev(pwe, t92);
    			append_dev(pwe, p22);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PrivacyPolicy', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PrivacyPolicy> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class PrivacyPolicy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PrivacyPolicy",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/pages/Cookies.svelte generated by Svelte v3.41.0 */

    const file$e = "src/pages/Cookies.svelte";

    function create_fragment$g(ctx) {
    	let section;
    	let div0;
    	let h1;
    	let t1;
    	let div5;
    	let div4;
    	let div1;
    	let p0;
    	let t2;
    	let strong0;
    	let t4;
    	let a0;
    	let t6;
    	let strong1;
    	let t8;
    	let t9;
    	let div3;
    	let div2;
    	let p1;
    	let t11;
    	let h30;
    	let t13;
    	let p2;
    	let t14;
    	let a1;
    	let t16;
    	let t17;
    	let h31;
    	let t19;
    	let p3;
    	let t21;
    	let ol0;
    	let li0;
    	let strong2;
    	let t23;
    	let t24;
    	let li1;
    	let strong3;
    	let t26;
    	let t27;
    	let li2;
    	let strong4;
    	let t29;
    	let t30;
    	let li3;
    	let strong5;
    	let t32;
    	let t33;
    	let h32;
    	let t35;
    	let p4;
    	let t37;
    	let h33;
    	let t39;
    	let p5;
    	let t41;
    	let p6;
    	let t43;
    	let ol2;
    	let li9;
    	let strong6;
    	let t45;
    	let br;
    	let t46;
    	let ol1;
    	let li4;
    	let a2;
    	let t48;
    	let li5;
    	let a3;
    	let t50;
    	let li6;
    	let a4;
    	let t52;
    	let li7;
    	let a5;
    	let t54;
    	let li8;
    	let a6;
    	let t56;
    	let li10;
    	let strong7;
    	let t58;
    	let a7;
    	let t60;
    	let a8;
    	let t62;
    	let a9;
    	let t64;
    	let a10;
    	let t66;
    	let t67;
    	let li11;
    	let strong8;
    	let t69;
    	let a11;
    	let t71;
    	let a12;
    	let t73;
    	let t74;
    	let p7;
    	let t76;
    	let h34;
    	let t78;
    	let p8;
    	let t80;
    	let h35;
    	let t82;
    	let p9;
    	let t83;
    	let a13;
    	let t85;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Cookie Policy";
    			t1 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			t2 = text$1("In these Web Site Terms of Use (\"");
    			strong0 = element("strong");
    			strong0.textContent = "TOU";
    			t4 = text$1("\"), we, Qualcomm Incorporated and our subsidiaries (\"Qualcomm\"), set forth the terms under which you may use our sites including ");
    			a0 = element("a");
    			a0.textContent = "www.qualcomm.com";
    			t6 = text$1(" and other web sites that we operate and on which we post a direct link to this statement (collectively, the \"");
    			strong1 = element("strong");
    			strong1.textContent = "Site";
    			t8 = text$1("\"). By using the Site, you are agreeing to this TOU. If you do not agree to this TOU, you may not and should not use the Site.");
    			t9 = space();
    			div3 = element("div");
    			div2 = element("div");
    			p1 = element("p");
    			p1.textContent = "Qualcomm Incorporated and its subsidiaries (collectively “we”, “us” and “our”) use cookies and a variety of similar technologies on its websites. In addition to cookies, such technologies include Local Shared Objects (i.e., Flash Cookies) and web beacons (i.e., single pixel GIFs, clear GIFs, or web bugs). We refer to these technologies collectively as “cookies”. This Cookie Policy explains the use of cookies when you visit any of our websites that provide a link to this Cookie Policy. See “Your Choices” below to manage cookies.";
    			t11 = space();
    			h30 = element("h3");
    			h30.textContent = "What is a Cookie?";
    			t13 = space();
    			p2 = element("p");
    			t14 = text$1("A cookie is a small data file that may be stored on the hard drive of your computer or device in your browser’s file directory when you access our website. When you visit one of our websites, cookies may be set by us (first party cookies) or by other companies (third party cookies) such as cookies from Google Analytics, Typekit, Disqus, and Addthis. When you return to one of our websites, or when you access other web pages within one of our websites, your web browser will send the information stored in the cookie to us or to the third party that set the cookie. For more information explaining cookies, visit ");
    			a1 = element("a");
    			a1.textContent = "www.allaboutcookies.org";
    			t16 = text$1(".");
    			t17 = space();
    			h31 = element("h3");
    			h31.textContent = "How are Cookies used?";
    			t19 = space();
    			p3 = element("p");
    			p3.textContent = "Cookies are used on our websites for a variety of purposes:";
    			t21 = space();
    			ol0 = element("ol");
    			li0 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Basic Functions.";
    			t23 = text$1(" Some of our websites use cookies that are strictly necessary in order to provide a function of the website such as to keep you logged-in where registration is required or to provide a shopping cart. These cookies may be set by us, or by third parties, such as a “Like” button by Facebook or a “Tweet” button by Twitter.");
    			t24 = space();
    			li1 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Site Improvement.";
    			t26 = text$1(" Some of our websites use cookies to better understand how visitors are using our websites to improve the information and functionality of our websites. These cookies help us learn, for example, if some webpages are not being frequently visited or if visitors are having difficulties navigating our websites. These cookies may be set by us, or by third-party companies such as Google or NetInsight.");
    			t27 = space();
    			li2 = element("li");
    			strong4 = element("strong");
    			strong4.textContent = "Personalization.";
    			t29 = text$1(" Some of our websites use cookies to personalize the content that is displayed on our site, or to remember you when you return to our site. For example, we may use a blog tool Disqus.");
    			t30 = space();
    			li3 = element("li");
    			strong5 = element("strong");
    			strong5.textContent = "Advertising.";
    			t32 = text$1(" Third party advertising companies may have our permission to serve ads on our behalf across the Internet or to display ads for other companies on our site. These third party advertising companies use cookies to measure and improve the effectiveness of their advertising. To do so, these companies may use generic information about your visits to our sites and other websites for online preference marketing purposes, in order to provide ads about goods and services of specific interest to you.");
    			t33 = space();
    			h32 = element("h3");
    			h32.textContent = "How Long are Cookies Stored?";
    			t35 = space();
    			p4 = element("p");
    			p4.textContent = "We set cookies to expire after they have fulfilled their purpose. Our websites use cookies that expire when you close your browser (i.e., session cookies) or that expire after a set period of time (i.e., so-called “persistent cookies”). Cookies that are stored by third parties will have their expiration period determined by the third party, not us.";
    			t37 = space();
    			h33 = element("h3");
    			h33.textContent = "Your Choices";
    			t39 = space();
    			p5 = element("p");
    			p5.textContent = "You decide whether cookies are stored on your computer or device and can choose to delete them. By accepting cookies that are stored on your computer when you visit our site, we infer that you have accepted the use of cookies as explained in this Cookie Policy.";
    			t41 = space();
    			p6 = element("p");
    			p6.textContent = "You can manage cookies one or more ways:";
    			t43 = space();
    			ol2 = element("ol");
    			li9 = element("li");
    			strong6 = element("strong");
    			strong6.textContent = "Browser Setting.";
    			t45 = text$1(" Your browser likely supports a variety of settings to control the cookies that are set on your computer or device and to delete cookies. These settings are typically found under the “Tools”, “Settings”, or “Options” menus. You can also check the “help” menu of your browser to learn how to change the cookie preferences through your browser settings. Note that you will need to manage the settings for each browser you use and on each device you use. Further information from several popular browsers can be found at the following sites:");
    			br = element("br");
    			t46 = space();
    			ol1 = element("ol");
    			li4 = element("li");
    			a2 = element("a");
    			a2.textContent = "Apple Safari";
    			t48 = space();
    			li5 = element("li");
    			a3 = element("a");
    			a3.textContent = "Google Chrome";
    			t50 = space();
    			li6 = element("li");
    			a4 = element("a");
    			a4.textContent = "Microsoft IE";
    			t52 = space();
    			li7 = element("li");
    			a5 = element("a");
    			a5.textContent = "Microsoft Edge";
    			t54 = space();
    			li8 = element("li");
    			a6 = element("a");
    			a6.textContent = "Mozilla Firefox";
    			t56 = space();
    			li10 = element("li");
    			strong7 = element("strong");
    			strong7.textContent = "Online Tools.";
    			t58 = text$1(" Some third parties allow you to manage cookies through online tools such as: ");
    			a7 = element("a");
    			a7.textContent = "Network Advertising Initiative";
    			t60 = text$1(", ");
    			a8 = element("a");
    			a8.textContent = "Digital Advertising Alliance";
    			t62 = text$1(", ");
    			a9 = element("a");
    			a9.textContent = "Your Online Choices";
    			t64 = text$1(", and ");
    			a10 = element("a");
    			a10.textContent = "Adobe Flash";
    			t66 = text$1(".");
    			t67 = space();
    			li11 = element("li");
    			strong8 = element("strong");
    			strong8.textContent = "Browser Extensions.";
    			t69 = text$1(" Some third parties have created software can be added to your web browser to manage their or third party cookies such as: ");
    			a11 = element("a");
    			a11.textContent = "Google Analytics";
    			t71 = text$1(", ");
    			a12 = element("a");
    			a12.textContent = "Ghostery";
    			t73 = text$1(" by Evidon, Inc.");
    			t74 = space();
    			p7 = element("p");
    			p7.textContent = "Please note that while you are free to decline cookies, you may not be able to use certain features on this site or take full advantage of all of our offerings if you decline cookies. Our reference to any third party or their software or services is not an endorsement by us of such third party or their products and services and we disclaim any liability for the use or operation of any third-party software or services.";
    			t76 = space();
    			h34 = element("h3");
    			h34.textContent = "Changes";
    			t78 = space();
    			p8 = element("p");
    			p8.textContent = "We reserve the right to change this Cookie Policy from time to time and in our sole discretion. We reserve the right to change, modify, add or remove portions of this Cookie Policy at any time, but will alert you that changes have been made by indicating on the Cookie Policy the date it was last updated. When you visit the site, you are accepting the current version of this Cookie Policy as posted on the site at that time. We recommend that users revisit this Cookie Policy on occasion to learn of any changes.";
    			t80 = space();
    			h35 = element("h3");
    			h35.textContent = "Further Information";
    			t82 = space();
    			p9 = element("p");
    			t83 = text$1("Please feel free to contact us with any comments, questions, complaints or suggestions you might have regarding the information practices described in this statement. Click here to access our ");
    			a13 = element("a");
    			a13.textContent = "Privacy Policy Inquiry form";
    			t85 = text$1(", or write to us at Qualcomm Incorporated, Attn. Legal Department, Privacy Counsel, 5775 Morehouse Drive, San Diego, CA 92121.");
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$e, 2, 2, 52);
    			attr_dev(div0, "class", "container");
    			add_location(div0, file$e, 1, 1, 26);
    			attr_dev(section, "class", "banner");
    			add_location(section, file$e, 0, 0, 0);
    			add_location(strong0, file$e, 10, 39, 233);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", "https://www.qualcomm.com/");
    			add_location(a0, file$e, 10, 188, 382);
    			add_location(strong1, file$e, 10, 370, 564);
    			add_location(p0, file$e, 10, 3, 197);
    			attr_dev(div1, "class", "policy");
    			add_location(div1, file$e, 9, 2, 173);
    			add_location(p1, file$e, 14, 4, 775);
    			add_location(h30, file$e, 15, 4, 1320);
    			attr_dev(a1, "href", "http://www.allaboutcookies.org");
    			add_location(a1, file$e, 16, 622, 1969);
    			add_location(p2, file$e, 16, 4, 1351);
    			add_location(h31, file$e, 17, 4, 2047);
    			add_location(p3, file$e, 18, 4, 2082);
    			add_location(strong2, file$e, 20, 9, 2167);
    			attr_dev(li0, "class", "svelte-qfqkog");
    			add_location(li0, file$e, 20, 5, 2163);
    			add_location(strong3, file$e, 21, 9, 2535);
    			attr_dev(li1, "class", "svelte-qfqkog");
    			add_location(li1, file$e, 21, 5, 2531);
    			add_location(strong4, file$e, 22, 9, 2982);
    			attr_dev(li2, "class", "svelte-qfqkog");
    			add_location(li2, file$e, 22, 5, 2978);
    			add_location(strong5, file$e, 23, 9, 3213);
    			attr_dev(li3, "class", "svelte-qfqkog");
    			add_location(li3, file$e, 23, 5, 3209);
    			attr_dev(ol0, "class", "svelte-qfqkog");
    			add_location(ol0, file$e, 19, 4, 2153);
    			add_location(h32, file$e, 25, 4, 3757);
    			add_location(p4, file$e, 26, 4, 3799);
    			add_location(h33, file$e, 27, 4, 4161);
    			add_location(p5, file$e, 28, 4, 4187);
    			add_location(p6, file$e, 29, 4, 4460);
    			add_location(strong6, file$e, 31, 8, 4524);
    			add_location(br, file$e, 31, 579, 5095);
    			attr_dev(a2, "href", "https://support.apple.com/guide/safari/manage-cookies-and-website-data-sfri11471/mac");
    			add_location(a2, file$e, 33, 9, 5118);
    			attr_dev(li4, "class", "svelte-qfqkog");
    			add_location(li4, file$e, 33, 5, 5114);
    			attr_dev(a3, "href", "https://support.google.com/chrome/bin/answer.py?hl=en&answer=95647&p=cpn_cookies");
    			add_location(a3, file$e, 34, 9, 5244);
    			attr_dev(li5, "class", "svelte-qfqkog");
    			add_location(li5, file$e, 34, 5, 5240);
    			attr_dev(a4, "href", "https://support.microsoft.com/en-us/help/17442/windows-internet-explorer-delete-manage-cookies");
    			add_location(a4, file$e, 35, 9, 5375);
    			attr_dev(li6, "class", "svelte-qfqkog");
    			add_location(li6, file$e, 35, 5, 5371);
    			attr_dev(a5, "href", "https://privacy.microsoft.com/en-us/windows-10-microsoft-edge-and-privacy");
    			add_location(a5, file$e, 36, 9, 5511);
    			attr_dev(li7, "class", "svelte-qfqkog");
    			add_location(li7, file$e, 36, 5, 5507);
    			attr_dev(a6, "href", "http://support.mozilla.org/en-US/kb/cookies-information-websites-store-on-your-computer?redirectlocale=en-US&redirectslug=Cookies");
    			add_location(a6, file$e, 37, 9, 5628);
    			attr_dev(li8, "class", "svelte-qfqkog");
    			add_location(li8, file$e, 37, 5, 5624);
    			attr_dev(ol1, "class", "svelte-qfqkog");
    			add_location(ol1, file$e, 32, 4, 5104);
    			attr_dev(li9, "class", "svelte-qfqkog");
    			add_location(li9, file$e, 31, 4, 4520);
    			add_location(strong7, file$e, 40, 8, 5825);
    			attr_dev(a7, "href", "http://www.networkadvertising.org/choices/");
    			add_location(a7, file$e, 40, 116, 5933);
    			attr_dev(a8, "href", "http://www.aboutads.info/choices/");
    			add_location(a8, file$e, 40, 205, 6022);
    			attr_dev(a9, "href", "http://www.youronlinechoices.com/");
    			add_location(a9, file$e, 40, 283, 6100);
    			attr_dev(a10, "href", "http://helpx.adobe.com/flash-player/kb/disable-local-shared-objects-flash.html");
    			add_location(a10, file$e, 40, 356, 6173);
    			attr_dev(li10, "class", "svelte-qfqkog");
    			add_location(li10, file$e, 40, 4, 5821);
    			add_location(strong8, file$e, 41, 8, 6292);
    			attr_dev(a11, "href", "https://tools.google.com/dlpage/gaoptout/");
    			add_location(a11, file$e, 41, 167, 6451);
    			attr_dev(a12, "href", "http://www.ghostery.com/");
    			add_location(a12, file$e, 41, 241, 6525);
    			attr_dev(li11, "class", "svelte-qfqkog");
    			add_location(li11, file$e, 41, 4, 6288);
    			attr_dev(ol2, "class", "svelte-qfqkog");
    			add_location(ol2, file$e, 30, 3, 4511);
    			add_location(p7, file$e, 43, 3, 6606);
    			add_location(h34, file$e, 44, 3, 7038);
    			add_location(p8, file$e, 45, 3, 7058);
    			add_location(h35, file$e, 46, 3, 7583);
    			attr_dev(a13, "href", "http://www.qualcomm.com/site/privacy/inquiry");
    			add_location(a13, file$e, 47, 198, 7810);
    			add_location(p9, file$e, 47, 3, 7615);
    			attr_dev(div2, "class", "");
    			add_location(div2, file$e, 13, 3, 756);
    			attr_dev(div3, "class", "policy-name");
    			add_location(div3, file$e, 12, 2, 727);
    			attr_dev(div4, "class", "policy-text");
    			add_location(div4, file$e, 8, 1, 145);
    			attr_dev(div5, "class", "container");
    			add_location(div5, file$e, 7, 0, 120);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, p0);
    			append_dev(p0, t2);
    			append_dev(p0, strong0);
    			append_dev(p0, t4);
    			append_dev(p0, a0);
    			append_dev(p0, t6);
    			append_dev(p0, strong1);
    			append_dev(p0, t8);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, p1);
    			append_dev(div2, t11);
    			append_dev(div2, h30);
    			append_dev(div2, t13);
    			append_dev(div2, p2);
    			append_dev(p2, t14);
    			append_dev(p2, a1);
    			append_dev(p2, t16);
    			append_dev(div2, t17);
    			append_dev(div2, h31);
    			append_dev(div2, t19);
    			append_dev(div2, p3);
    			append_dev(div2, t21);
    			append_dev(div2, ol0);
    			append_dev(ol0, li0);
    			append_dev(li0, strong2);
    			append_dev(li0, t23);
    			append_dev(ol0, t24);
    			append_dev(ol0, li1);
    			append_dev(li1, strong3);
    			append_dev(li1, t26);
    			append_dev(ol0, t27);
    			append_dev(ol0, li2);
    			append_dev(li2, strong4);
    			append_dev(li2, t29);
    			append_dev(ol0, t30);
    			append_dev(ol0, li3);
    			append_dev(li3, strong5);
    			append_dev(li3, t32);
    			append_dev(div2, t33);
    			append_dev(div2, h32);
    			append_dev(div2, t35);
    			append_dev(div2, p4);
    			append_dev(div2, t37);
    			append_dev(div2, h33);
    			append_dev(div2, t39);
    			append_dev(div2, p5);
    			append_dev(div2, t41);
    			append_dev(div2, p6);
    			append_dev(div2, t43);
    			append_dev(div2, ol2);
    			append_dev(ol2, li9);
    			append_dev(li9, strong6);
    			append_dev(li9, t45);
    			append_dev(li9, br);
    			append_dev(li9, t46);
    			append_dev(li9, ol1);
    			append_dev(ol1, li4);
    			append_dev(li4, a2);
    			append_dev(ol1, t48);
    			append_dev(ol1, li5);
    			append_dev(li5, a3);
    			append_dev(ol1, t50);
    			append_dev(ol1, li6);
    			append_dev(li6, a4);
    			append_dev(ol1, t52);
    			append_dev(ol1, li7);
    			append_dev(li7, a5);
    			append_dev(ol1, t54);
    			append_dev(ol1, li8);
    			append_dev(li8, a6);
    			append_dev(ol2, t56);
    			append_dev(ol2, li10);
    			append_dev(li10, strong7);
    			append_dev(li10, t58);
    			append_dev(li10, a7);
    			append_dev(li10, t60);
    			append_dev(li10, a8);
    			append_dev(li10, t62);
    			append_dev(li10, a9);
    			append_dev(li10, t64);
    			append_dev(li10, a10);
    			append_dev(li10, t66);
    			append_dev(ol2, t67);
    			append_dev(ol2, li11);
    			append_dev(li11, strong8);
    			append_dev(li11, t69);
    			append_dev(li11, a11);
    			append_dev(li11, t71);
    			append_dev(li11, a12);
    			append_dev(li11, t73);
    			append_dev(div2, t74);
    			append_dev(div2, p7);
    			append_dev(div2, t76);
    			append_dev(div2, h34);
    			append_dev(div2, t78);
    			append_dev(div2, p8);
    			append_dev(div2, t80);
    			append_dev(div2, h35);
    			append_dev(div2, t82);
    			append_dev(div2, p9);
    			append_dev(p9, t83);
    			append_dev(p9, a13);
    			append_dev(p9, t85);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cookies', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cookies> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Cookies extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cookies",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src/pages/TermsOfUse.svelte generated by Svelte v3.41.0 */

    const file$d = "src/pages/TermsOfUse.svelte";

    function create_fragment$f(ctx) {
    	let section;
    	let div0;
    	let h1;
    	let t1;
    	let div4;
    	let div3;
    	let div1;
    	let p0;
    	let t2;
    	let strong0;
    	let t4;
    	let a0;
    	let t6;
    	let strong1;
    	let t8;
    	let t9;
    	let div2;
    	let ol2;
    	let li0;
    	let p1;
    	let strong2;
    	let t11;
    	let t12;
    	let li1;
    	let p2;
    	let strong3;
    	let t14;
    	let t15;
    	let li2;
    	let p3;
    	let strong4;
    	let t17;
    	let t18;
    	let li3;
    	let p4;
    	let strong5;
    	let t20;
    	let t21;
    	let p5;
    	let t23;
    	let li12;
    	let p6;
    	let strong6;
    	let br0;
    	let t25;
    	let t26;
    	let ol0;
    	let li4;
    	let p7;
    	let strong7;
    	let t28;
    	let t29;
    	let li5;
    	let p8;
    	let strong8;
    	let t31;
    	let t32;
    	let li6;
    	let p9;
    	let strong9;
    	let t34;
    	let strong10;
    	let t36;
    	let t37;
    	let li7;
    	let p10;
    	let strong11;
    	let t39;
    	let t40;
    	let li8;
    	let p11;
    	let strong12;
    	let t42;
    	let t43;
    	let li9;
    	let p12;
    	let strong13;
    	let t45;
    	let t46;
    	let li10;
    	let p13;
    	let strong14;
    	let t48;
    	let t49;
    	let li11;
    	let p14;
    	let strong15;
    	let t51;
    	let t52;
    	let li13;
    	let p15;
    	let strong16;
    	let t54;
    	let a1;
    	let t56;
    	let strong17;
    	let t58;
    	let t59;
    	let li14;
    	let p16;
    	let strong18;
    	let t61;
    	let t62;
    	let li15;
    	let p17;
    	let strong19;
    	let t64;
    	let t65;
    	let li26;
    	let p18;
    	let strong20;
    	let t67;
    	let t68;
    	let p19;
    	let t69;
    	let br1;
    	let t70;
    	let br2;
    	let t71;
    	let br3;
    	let t72;
    	let t73;
    	let p20;
    	let t74;
    	let br4;
    	let t75;
    	let br5;
    	let t76;
    	let t77;
    	let p21;
    	let t79;
    	let ol1;
    	let li16;
    	let p22;
    	let t81;
    	let li17;
    	let p23;
    	let t83;
    	let li18;
    	let p24;
    	let t85;
    	let li19;
    	let p25;
    	let t87;
    	let li20;
    	let p26;
    	let t89;
    	let li21;
    	let p27;
    	let t91;
    	let p28;
    	let em0;
    	let t93;
    	let p29;
    	let em1;
    	let t95;
    	let li22;
    	let t97;
    	let li23;
    	let t99;
    	let li24;
    	let t101;
    	let li25;
    	let t103;
    	let li27;
    	let strong21;
    	let t105;
    	let t106;
    	let li28;
    	let strong22;
    	let t108;
    	let t109;
    	let li29;
    	let strong23;
    	let t111;
    	let t112;
    	let li30;
    	let strong24;
    	let t114;
    	let t115;
    	let li31;
    	let strong25;
    	let t117;
    	let t118;
    	let li32;
    	let strong26;
    	let t120;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Terms of Use";
    			t1 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			t2 = text$1("In these Web Site Terms of Use (\"");
    			strong0 = element("strong");
    			strong0.textContent = "TOU";
    			t4 = text$1("\"), we, Qualcomm Incorporated and our subsidiaries (\"Qualcomm\"), set forth the terms under which you may use our sites including ");
    			a0 = element("a");
    			a0.textContent = "www.qualcomm.com";
    			t6 = text$1(" and other web sites that we operate and on which we post a direct link to this statement (collectively, the \"");
    			strong1 = element("strong");
    			strong1.textContent = "Site";
    			t8 = text$1("\"). By using the Site, you are agreeing to this TOU. If you do not agree to this TOU, you may not and should not use the Site.");
    			t9 = space();
    			div2 = element("div");
    			ol2 = element("ol");
    			li0 = element("li");
    			p1 = element("p");
    			strong2 = element("strong");
    			strong2.textContent = "Applicable Agreement(s).";
    			t11 = text$1(" Your access to and use of the materials available on the Site (including but not limited to CreatePoint, Qualcomm ChipCode Software, and Cases websites) may be subject to the terms and conditions of a corresponding agreement(s) in place between the legal entity you represent and Qualcomm Technologies, Inc. or an affiliated company, including but not limited to Qualcomm Technologies International, Ltd. Your access to and use of the materials available on the Site shall not modify or abrogate your obligations under any other agreement with Qualcomm Technologies, Inc. or an affiliated company, including but not limited to Qualcomm Technologies International, Ltd. Nothing in the materials available on the Site is an offer to sell any of the components or devices referenced herein. Unauthorized access to or use of such materials is prohibited.");
    			t12 = space();
    			li1 = element("li");
    			p2 = element("p");
    			strong3 = element("strong");
    			strong3.textContent = "Copyright Notice and Use of the Site.";
    			t14 = text$1(" The Site contains copyrighted material, trademarks, and other proprietary information, including comments, articles, information, brochures, data, text, software, photos, videos and graphics. The contents of the Site are subject to copyrights owned by Qualcomm and other individuals or entities and are protected by United States and international copyright laws. Except as otherwise provided in a written Agreement between you and Qualcomm, you may not modify, copy, reproduce, republish, upload, post, transmit, transfer, or distribute in any way any of the contents of this Site. You may not distribute copies of materials found on the Site in any form (including by e-mail or other electronic means), without prior written permission from Qualcomm. You may, however, download content from this Site solely for your personal, non-commercial use (except as may otherwise be provided in a written agreement between you and Qualcomm), provided you keep intact all copyright and other legal and proprietary notices. To make a complaint about a copyright violation on the Site, see Section 8 below.");
    			t15 = space();
    			li2 = element("li");
    			p3 = element("p");
    			strong4 = element("strong");
    			strong4.textContent = "Broadcom Notice.";
    			t17 = text$1(" Pursuant to its settlement agreement with Broadcom Corporation, Qualcomm is required to notify you that the sale, license, or other transfer of certain Qualcomm products to Buyer does not convey to Buyer any intellectual property rights (including patent rights) of Broadcom Corporation or any of its affiliates in such Qualcomm products and therefore Buyer should not assume that any such sale, license, or other transfer conveys any such rights to Buyer. Buyer should contact Qualcomm with any questions it may have regarding whether Qualcomm's sale, license, or other transfer of specific Qualcomm products to Buyer conveys to Buyer any rights to Broadcom intellectual property. For those Qualcomm products for which this sale, license, or other transfer does not convey to Buyer any intellectual property rights of Broadcom Corporation or any of its affiliates, neither Broadcom Corporation nor any of its affiliates has consented to or authorized (a) the incorporation of such Qualcomm products in, or the use of such Qualcomm products in combination with, any other products or components, (b) Buyer's sale of any products incorporating such Qualcomm products, or (c) the distribution in any jurisdiction of such Qualcomm products where the distribution of such Qualcomm products is deemed to be a putting on the market with Broadcom Corporation's consent or authorization so as to effectuate an exhaustion of rights of any patents. The foregoing shall not modify or abrogate Buyer's obligations under any existing license agreement between Buyer and Broadcom Corporation (or any of its affiliates), including but not limited to Buyer's obligation to pay all royalties and fees specified thereunder, and shall not expand or alter Buyer's rights thereunder.");
    			t18 = space();
    			li3 = element("li");
    			p4 = element("p");
    			strong5 = element("strong");
    			strong5.textContent = "Links.";
    			t20 = text$1(" This Site may contain links to third party web sites which are controlled and operated by third parties. Your use of each third party web site is subject to the terms of use and other guidelines, if any, contained within the relevant web site. You agree to review and accept such terms of use prior to using such third party web sites.");
    			t21 = space();
    			p5 = element("p");
    			p5.textContent = "Qualcomm makes no representations whatsoever about any third party web site which you may access through the Site. When you access a third party web site, you agree that it is independent from Qualcomm, that any content you retrieve from that web site is not distributed by Qualcomm, and that Qualcomm has no control over any content on that web site. In addition, a link to a third party web site does not mean that Qualcomm accepts any responsibility for the content, or the use, of such web site. It is up to you to take precautions to ensure that whatever you select for your use is free of such items as viruses, worms, trojans and other items of a destructive nature.";
    			t23 = space();
    			li12 = element("li");
    			p6 = element("p");
    			strong6 = element("strong");
    			strong6.textContent = "Additional Terms for Forums, Blogs, and Other Social Media.";
    			br0 = element("br");
    			t25 = text$1("\n\t\t\t\t\t\t\tOur Site may provide one or more forums, blogs, or other interactive or social media features (\"Forums\") for visitors to our Site to exchange information with each other and with Qualcomm about Qualcomm’s products and services (the \"Purpose\"). If you use the Forums, in addition to any other terms we may require when you register to use the Forums or otherwise posted at or on the Forums, you agree to and acknowledge the following:");
    			t26 = space();
    			ol0 = element("ol");
    			li4 = element("li");
    			p7 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Restrictions.";
    			t28 = text$1(" You agree not to use the Forums for any reason other than the Purpose. The material on the Forums is protected by international copyright and trademark laws. Except as permitted through a “Share” function which we may provide on the Forums (or with our express written permission), you may not modify, copy, reproduce, republish, upload, post, transmit, or distribute in any way any material from the Forums including any code or software we may provide.");
    			t29 = space();
    			li5 = element("li");
    			p8 = element("p");
    			strong8 = element("strong");
    			strong8.textContent = "Postings Not Necessarily the Opinion of Qualcomm.";
    			t31 = text$1(" Some of the individuals posting to Forums work for Qualcomm; however, opinions expressed on Forums and in any corresponding comments are the personal opinions of the original authors, and do not necessarily reflect the views of Qualcomm.");
    			t32 = space();
    			li6 = element("li");
    			p9 = element("p");
    			strong9 = element("strong");
    			strong9.textContent = "Postings. ";
    			t34 = text$1("Although we may attempt to keep objectionable messages off the Site, it is impossible for us to review all messages. All messages express the views of the author, and Qualcomm will not be held responsible for any message or associated content. You take full responsibility for any and all messages and associated content you post to the Forums or exchange through the Forums.If you post any messages, upload files, input data, or engage in any other form of communication through the Forums (a “");
    			strong10 = element("strong");
    			strong10.textContent = "Posting";
    			t36 = text$1("”), you represent and warrant the following: (i) you own all right, title, and interest in and to the Posting, or you have been granted sufficient rights in and to the Posting allowing you to post such Posting, (ii) you will not post any messages or other materials that are obscene, vulgar, sexually-orientated, hateful, threatening, or otherwise violate any laws, (iii) you must not breach obligations of confidentiality that you owe to another party either in posting or using a Posting, (iv) any Postings you make to the Site do not infringe any third party copyright, trade marks, any other intellectual property rights or any applicable law and (v) you will indemnify us and our affiliates, partners, licensors, service providers, content providers, and their and our directors, officers, employees and agents against all claims, losses, liabilities, costs, damages and expenses incurred by us or them due to any breach by you of this TOU or your use of the Forums. For the purposes of this section, references to “your use” of the Forums shall be deemed to include any use by a third party where such third party accesses the Forums using your computer.");
    			t37 = space();
    			li7 = element("li");
    			p10 = element("p");
    			strong11 = element("strong");
    			strong11.textContent = "Third Party Contributions.";
    			t39 = text$1(" The Forums may include contributions from various sources over which Qualcomm has no control (including any content submitted by third party users). Qualcomm does not pre-screen or exercise editorial control over any Postings, and takes no responsibility for any Postings. Qualcomm reserves the right to edit or remove Postings at any time and in its sole discretion, including those that are in breach of this TOU or in breach of any obligation of confidentiality you owe Qualcomm, infringe or are alleged to infringe the intellectual property rights of any third party, or are defamatory, or otherwise are not relevant to the Forums and Qualcomm will not be liable in relation to the removal of, or failure to remove, any Postings.");
    			t40 = space();
    			li8 = element("li");
    			p11 = element("p");
    			strong12 = element("strong");
    			strong12.textContent = "Messages to Registered Users.";
    			t42 = text$1(" Our Forums may allow you to send messages directly to other Forum users who have made their contact information available for receiving such messages. You agree to only send messages to other Forum users for the purpose of exchanging information about the Purpose and any other use of the ability to send messages to other Forum users is strictly prohibited. Moreover, you shall not use the contact information made available through the Forum for any of the following: (i) to send unsolicited commercial email (i.e., spam) or any other type of unsolicited commercial message, or (ii) to send any message that is vulgar, sexually-orientated, hateful, threatening, or otherwise violates any laws.");
    			t43 = space();
    			li9 = element("li");
    			p12 = element("p");
    			strong13 = element("strong");
    			strong13.textContent = "License.";
    			t45 = text$1(" By adding a Posting to the Forum, you grant Qualcomm a royalty-free, perpetual, non-exclusive, unrestricted, worldwide license to: (i) post, use, copy, sublicense, adapt, transmit, publicly perform or display any such Posting, (ii) use, reproduce, modify, adapt, publish, translate, create derivative works from, distribute, perform, play, host, communicate, make available and publish your Posting without restriction, (iii) make, use, sell, offer for sale, and import products implementing any invention or functionality reflected in your Posting, and (iv) sublicense to third parties the unrestricted right to exercise any of the foregoing rights granted with respect to the Posting. The foregoing grants shall include the right to exploit any ideas, concepts, intellectual property, or proprietary rights in such Posting, including but not limited to rights under copyright, trademark, servicemark or patent laws under any relevant jurisdiction without Qualcomm owing any monies to you whatsoever.");
    			t46 = space();
    			li10 = element("li");
    			p13 = element("p");
    			strong14 = element("strong");
    			strong14.textContent = "Qualcomm Employees.";
    			t48 = text$1(" If you are a Qualcomm employee, you must also follow the Qualcomm Social Media Policy in your Postings.");
    			t49 = space();
    			li11 = element("li");
    			p14 = element("p");
    			strong15 = element("strong");
    			strong15.textContent = "Posting Guidelines.";
    			t51 = text$1(" Our Forums may contain additional rules or posting guidelines. In such case, you agree to conform your Postings to any such additional rules or posting guidelines.");
    			t52 = space();
    			li13 = element("li");
    			p15 = element("p");
    			strong16 = element("strong");
    			strong16.textContent = "Privacy.";
    			t54 = text$1(" In order to operate and provide the Site, we collect certain information about you. Our practices with respect to the information we collect is described in our privacy policy which is available at ");
    			a1 = element("a");
    			a1.textContent = "www.qualcomm.com/privacy";
    			t56 = text$1(" (“");
    			strong17 = element("strong");
    			strong17.textContent = "Privacy Policy";
    			t58 = text$1("”). By agreeing to this TOU you are agreeing to our Privacy Policy. Information, including but not limited to personal information, collected through the Site may be stored and processed in the United States or any other country in which Qualcomm or its affiliates, subsidiaries or agents maintain facilities. By using the service, you consent to any such transfer of information outside of your country.");
    			t59 = space();
    			li14 = element("li");
    			p16 = element("p");
    			strong18 = element("strong");
    			strong18.textContent = "Disclaimer.";
    			t61 = text$1(" The materials on the Site and on the Forums are provided \"as is\" and, to the fullest extent permissible pursuant to applicable law, Qualcomm disclaims all warranties, express or implied, including, but not limited to, implied warranties of merchantability and fitness for a particular purpose, title and non-infringement and any other conditions, warranties and other terms which might otherwise be implied by statute, common law or the law of equity. Qualcomm does not warrant that the Site or functions contained in the materials will be uninterrupted or error-free, that defects will be corrected, or that the Site, or the server that makes it available, are free of viruses or other harmful components. Qualcomm does not warrant or make any representations regarding the use or the results of the use of the materials on the Site in terms of correctness, accuracy, timeliness, reliability, or otherwise. You (and not Qualcomm or its licensors) assume the entire cost of all necessary maintenance, repair, or correction. Commentary and other materials posted on the Site and Forums are not intended to amount to advice on which reliance should be placed and we therefore disclaim all liability and responsibility arising from any such reliance.");
    			t62 = space();
    			li15 = element("li");
    			p17 = element("p");
    			strong19 = element("strong");
    			strong19.textContent = "Limitation of liability.";
    			t64 = text$1(" Under no circumstances, including, but not limited to, negligence, shall Qualcomm, its subsidiaries and parent companies and affiliates be liable for any direct, indirect, incidental, special or consequential damages that arise or result from or are related to the use of, or the inability to use, the Site or any of the Postings made available on or through the Site. Under no circumstances shall Qualcomm’s aggregate liability exceed $5.00. You specifically acknowledge and agree that Qualcomm, its subsidiaries and parent companies and affiliates are not liable for any defamatory, offensive or illegal conduct of any user of the Site or any posting to the Site. If you are dissatisfied with the Site or any materials made available by or through the Site, or with this TOU, your sole and exclusive remedy is to discontinue using the Site.");
    			t65 = space();
    			li26 = element("li");
    			p18 = element("p");
    			strong20 = element("strong");
    			strong20.textContent = "Notices of copyright infringement.";
    			t67 = text$1(" Pursuant to Title 17, United States Code, Section 512(c)(2), notifications of claimed copyright infringement should be sent to Qualcomm's Designated Agent in writing at the following address:");
    			t68 = space();
    			p19 = element("p");
    			t69 = text$1("Qualcomm Incorporated");
    			br1 = element("br");
    			t70 = text$1("\n\t\t\t\t\t\t\tAttn. Corporate Legal, Copyright Agent");
    			br2 = element("br");
    			t71 = text$1("\n\t\t\t\t\t\t\t5775 Morehouse Drive");
    			br3 = element("br");
    			t72 = text$1("\n\t\t\t\t\t\t\tSan Diego, CA 92121-1714");
    			t73 = space();
    			p20 = element("p");
    			t74 = text$1("Telephone Number of Designated Agent: (858) 845-6363");
    			br4 = element("br");
    			t75 = text$1("\n\t\t\t\t\t\t\tFacsimile Number of Designated Agent: (858) 845-1249");
    			br5 = element("br");
    			t76 = text$1("\n\t\t\t\t\t\t\tEmail Address of Designated Agent: copyrightagent [at] qualcomm [dot] com");
    			t77 = space();
    			p21 = element("p");
    			p21.textContent = "To be effective, the notification must be a written communication that includes the following:";
    			t79 = space();
    			ol1 = element("ol");
    			li16 = element("li");
    			p22 = element("p");
    			p22.textContent = "A physical or electronic signature of the owner whose exclusive right is allegedly infringed or a person authorized to act on his or her behalf;";
    			t81 = space();
    			li17 = element("li");
    			p23 = element("p");
    			p23.textContent = "Identification of the copyrighted work claimed to have been infringed, or if multiple copyrighted works at a single online site are covered by a single notification, a representative list of such works at that site;";
    			t83 = space();
    			li18 = element("li");
    			p24 = element("p");
    			p24.textContent = "Identification of the material that is claimed to be infringing or is the subject of infringing activity and that is to be removed or access to which is to be disabled, and information reasonably sufficient to permit Qualcomm to locate the material on the Site;";
    			t85 = space();
    			li19 = element("li");
    			p25 = element("p");
    			p25.textContent = "Information reasonably sufficient to permit Qualcomm to contact the copyright owner or his/her authorized agent including an address, telephone number, and if available, an electronic mail address;";
    			t87 = space();
    			li20 = element("li");
    			p26 = element("p");
    			p26.textContent = "A statement that the copyright owner or authorized agent has a good faith belief that use of the material in the manner complained of is not authorized by the copyright owner, its agent, or the law;";
    			t89 = space();
    			li21 = element("li");
    			p27 = element("p");
    			p27.textContent = "A statement that the information in the notification is accurate, and if submitted by the owner’s authorized agent a statement under penalty of perjury, that the agent is authorized to act on behalf of the owner of an exclusive right that is allegedly infringed.";
    			t91 = space();
    			p28 = element("p");
    			em0 = element("em");
    			em0.textContent = "We may give you notice that we have removed or disabled access to certain material by means of a general notice on the Site, electronic mail to a user’s e-mail address in our records, or written communication sent by first-class mail to a user’s physical address in our records. If you receive such a notice, you may provide a counter-notification in writing to the Designated Agent that includes the information below.";
    			t93 = space();
    			p29 = element("p");
    			em1 = element("em");
    			em1.textContent = "To be effective, a counter notification must be a written communication provided to Qualcomm’s Designated Agent at the above-provided address that includes substantially the following:";
    			t95 = space();
    			li22 = element("li");
    			li22.textContent = "A physical or electronic signature of the alleged infringer;";
    			t97 = space();
    			li23 = element("li");
    			li23.textContent = "Identification of the material that has been removed or to which access has been disabled and the location at which the material appeared before it was removed or access to it was disabled;";
    			t99 = space();
    			li24 = element("li");
    			li24.textContent = "A statement under penalty of perjury that the alleged infringer has a good faith belief that the material was removed or disabled as a result of a mistake or misidentification of the material to be removed or disabled;";
    			t101 = space();
    			li25 = element("li");
    			li25.textContent = "The alleged infringer’s name, address, and telephone number, and a statement that the alleged infringer consents to the jurisdiction of Federal District Court for San Diego County, California, or if the Subscriber's address is outside of the United States, for any judicial district in which Qualcomm may be found, and that the alleged infringer will accept service of process from the person who provided notification or an agent of such person.";
    			t103 = space();
    			li27 = element("li");
    			strong21 = element("strong");
    			strong21.textContent = "Export Restrictions.";
    			t105 = text$1(" You must comply with all domestic and international export laws and regulations that may apply to the software or other materials obtained from this Site.");
    			t106 = space();
    			li28 = element("li");
    			strong22 = element("strong");
    			strong22.textContent = "Trademarks.";
    			t108 = text$1(" Qualcomm trademark of Qualcomm Incorporated, registered in the United States and other countries. Other product names, brand names and company names mentioned on this Site may be trademarks or registered trademarks of their respective owners.");
    			t109 = space();
    			li29 = element("li");
    			strong23 = element("strong");
    			strong23.textContent = "Modification & Termination.";
    			t111 = text$1(" This TOU is effective until modified or terminated by Qualcomm. Qualcomm may modify this TOU from time to time and the new TOU will be effective when posted. Qualcomm may also terminate this TOU at any time without notice to you. In the event of termination, you are no longer authorized to access the Site and the restrictions imposed on you with respect to material downloaded from the Site, the disclaimers and limitations of liabilities, and export restrictions set forth in this agreement, shall survive.");
    			t112 = space();
    			li30 = element("li");
    			strong24 = element("strong");
    			strong24.textContent = "Language";
    			t114 = text$1(" This TOU is solely effective in its English language version and any translations of this TOU are provided solely for information and convenience. In the event this TOU is translated into any language other than English, the English version shall in all respects control and apply in case of any differences or discrepancies.");
    			t115 = space();
    			li31 = element("li");
    			strong25 = element("strong");
    			strong25.textContent = "Governing Law.";
    			t117 = text$1(" This TOU shall be governed by and construed in accordance with the laws of the State of California without giving effect to any principles or conflicts of law.");
    			t118 = space();
    			li32 = element("li");
    			strong26 = element("strong");
    			strong26.textContent = "Severability.";
    			t120 = text$1(" If any provision of this TOU shall be unlawful, void or for any reason unenforceable, then that provision shall be deemed severable from this agreement and shall not affect the validity and enforceability of any remaining provisions.");
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$d, 2, 2, 52);
    			attr_dev(div0, "class", "container");
    			add_location(div0, file$d, 1, 1, 26);
    			attr_dev(section, "class", "banner");
    			add_location(section, file$d, 0, 0, 0);
    			add_location(strong0, file$d, 10, 39, 232);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", "https://www.qualcomm.com/");
    			add_location(a0, file$d, 10, 188, 381);
    			add_location(strong1, file$d, 10, 370, 563);
    			add_location(p0, file$d, 10, 3, 196);
    			attr_dev(div1, "class", "policy");
    			add_location(div1, file$d, 9, 2, 172);
    			add_location(strong2, file$d, 15, 7, 794);
    			add_location(p1, file$d, 15, 4, 791);
    			attr_dev(li0, "class", "svelte-z80hvq");
    			add_location(li0, file$d, 14, 4, 782);
    			add_location(strong3, file$d, 18, 7, 1717);
    			add_location(p2, file$d, 18, 4, 1714);
    			attr_dev(li1, "class", "svelte-z80hvq");
    			add_location(li1, file$d, 17, 4, 1705);
    			add_location(strong4, file$d, 21, 7, 2899);
    			add_location(p3, file$d, 21, 4, 2896);
    			attr_dev(li2, "class", "svelte-z80hvq");
    			add_location(li2, file$d, 20, 4, 2887);
    			add_location(strong5, file$d, 24, 7, 4726);
    			add_location(p4, file$d, 24, 4, 4723);
    			add_location(p5, file$d, 25, 4, 5094);
    			attr_dev(li3, "class", "svelte-z80hvq");
    			add_location(li3, file$d, 23, 4, 4714);
    			add_location(strong6, file$d, 28, 7, 5801);
    			add_location(br0, file$d, 28, 83, 5877);
    			add_location(p6, file$d, 28, 4, 5798);
    			add_location(strong7, file$d, 32, 7, 6352);
    			add_location(p7, file$d, 32, 4, 6349);
    			attr_dev(li4, "class", "svelte-z80hvq");
    			add_location(li4, file$d, 31, 4, 6340);
    			add_location(strong8, file$d, 35, 7, 6868);
    			add_location(p8, file$d, 35, 4, 6865);
    			attr_dev(li5, "class", "svelte-z80hvq");
    			add_location(li5, file$d, 34, 4, 6856);
    			add_location(strong9, file$d, 38, 7, 7203);
    			add_location(strong10, file$d, 38, 534, 7730);
    			add_location(p9, file$d, 38, 4, 7200);
    			attr_dev(li6, "class", "svelte-z80hvq");
    			add_location(li6, file$d, 37, 4, 7191);
    			add_location(strong11, file$d, 41, 7, 8945);
    			add_location(p10, file$d, 41, 4, 8942);
    			attr_dev(li7, "class", "svelte-z80hvq");
    			add_location(li7, file$d, 40, 4, 8933);
    			add_location(strong12, file$d, 44, 7, 9753);
    			add_location(p11, file$d, 44, 4, 9750);
    			attr_dev(li8, "class", "svelte-z80hvq");
    			add_location(li8, file$d, 43, 4, 9741);
    			add_location(strong13, file$d, 47, 7, 10526);
    			add_location(p12, file$d, 47, 4, 10523);
    			attr_dev(li9, "class", "svelte-z80hvq");
    			add_location(li9, file$d, 46, 4, 10514);
    			add_location(strong14, file$d, 50, 7, 11584);
    			add_location(p13, file$d, 50, 4, 11581);
    			attr_dev(li10, "class", "svelte-z80hvq");
    			add_location(li10, file$d, 49, 4, 11572);
    			add_location(strong15, file$d, 53, 7, 11755);
    			add_location(p14, file$d, 53, 4, 11752);
    			attr_dev(li11, "class", "svelte-z80hvq");
    			add_location(li11, file$d, 52, 4, 11743);
    			attr_dev(ol0, "class", "svelte-z80hvq");
    			add_location(ol0, file$d, 30, 4, 6331);
    			attr_dev(li12, "class", "svelte-z80hvq");
    			add_location(li12, file$d, 27, 4, 5789);
    			add_location(strong16, file$d, 58, 7, 12006);
    			attr_dev(a1, "href", "https://www.qualcomm.com/site/privacy");
    			add_location(a1, file$d, 58, 231, 12230);
    			add_location(strong17, file$d, 58, 310, 12309);
    			add_location(p15, file$d, 58, 4, 12003);
    			attr_dev(li13, "class", "svelte-z80hvq");
    			add_location(li13, file$d, 57, 4, 11994);
    			add_location(strong18, file$d, 61, 7, 12775);
    			add_location(p16, file$d, 61, 4, 12772);
    			attr_dev(li14, "class", "svelte-z80hvq");
    			add_location(li14, file$d, 60, 4, 12763);
    			add_location(strong19, file$d, 64, 7, 14082);
    			add_location(p17, file$d, 64, 4, 14079);
    			attr_dev(li15, "class", "svelte-z80hvq");
    			add_location(li15, file$d, 63, 4, 14070);
    			add_location(strong20, file$d, 67, 7, 14997);
    			add_location(p18, file$d, 67, 4, 14994);
    			add_location(br1, file$d, 68, 28, 15273);
    			add_location(br2, file$d, 69, 45, 15323);
    			add_location(br3, file$d, 70, 27, 15355);
    			add_location(p19, file$d, 68, 4, 15249);
    			add_location(br4, file$d, 72, 59, 15455);
    			add_location(br5, file$d, 73, 59, 15519);
    			add_location(p20, file$d, 72, 4, 15400);
    			add_location(p21, file$d, 75, 4, 15613);
    			add_location(p22, file$d, 78, 4, 15737);
    			attr_dev(li16, "class", "svelte-z80hvq");
    			add_location(li16, file$d, 77, 4, 15728);
    			add_location(p23, file$d, 81, 4, 15912);
    			attr_dev(li17, "class", "svelte-z80hvq");
    			add_location(li17, file$d, 80, 4, 15903);
    			add_location(p24, file$d, 84, 4, 16158);
    			attr_dev(li18, "class", "svelte-z80hvq");
    			add_location(li18, file$d, 83, 4, 16149);
    			add_location(p25, file$d, 87, 4, 16450);
    			attr_dev(li19, "class", "svelte-z80hvq");
    			add_location(li19, file$d, 86, 4, 16441);
    			add_location(p26, file$d, 90, 4, 16678);
    			attr_dev(li20, "class", "svelte-z80hvq");
    			add_location(li20, file$d, 89, 4, 16669);
    			add_location(p27, file$d, 93, 4, 16907);
    			add_location(em0, file$d, 94, 7, 17184);
    			add_location(p28, file$d, 94, 4, 17181);
    			add_location(em1, file$d, 95, 7, 17624);
    			add_location(p29, file$d, 95, 4, 17621);
    			attr_dev(li21, "class", "svelte-z80hvq");
    			add_location(li21, file$d, 92, 4, 16898);
    			attr_dev(li22, "class", "svelte-z80hvq");
    			add_location(li22, file$d, 97, 4, 17836);
    			attr_dev(li23, "class", "svelte-z80hvq");
    			add_location(li23, file$d, 98, 4, 17910);
    			attr_dev(li24, "class", "svelte-z80hvq");
    			add_location(li24, file$d, 99, 4, 18113);
    			attr_dev(li25, "class", "svelte-z80hvq");
    			add_location(li25, file$d, 100, 4, 18345);
    			attr_dev(ol1, "class", "svelte-z80hvq");
    			add_location(ol1, file$d, 76, 4, 15719);
    			attr_dev(li26, "class", "svelte-z80hvq");
    			add_location(li26, file$d, 66, 4, 14985);
    			add_location(strong21, file$d, 103, 9, 18830);
    			attr_dev(li27, "class", "svelte-z80hvq");
    			add_location(li27, file$d, 103, 4, 18825);
    			add_location(strong22, file$d, 104, 8, 19036);
    			attr_dev(li28, "class", "svelte-z80hvq");
    			add_location(li28, file$d, 104, 4, 19032);
    			add_location(strong23, file$d, 105, 8, 19321);
    			attr_dev(li29, "class", "svelte-z80hvq");
    			add_location(li29, file$d, 105, 4, 19317);
    			add_location(strong24, file$d, 106, 8, 19893);
    			attr_dev(li30, "class", "svelte-z80hvq");
    			add_location(li30, file$d, 106, 4, 19889);
    			add_location(strong25, file$d, 107, 8, 20258);
    			attr_dev(li31, "class", "svelte-z80hvq");
    			add_location(li31, file$d, 107, 4, 20254);
    			add_location(strong26, file$d, 108, 8, 20468);
    			attr_dev(li32, "class", "svelte-z80hvq");
    			add_location(li32, file$d, 108, 4, 20464);
    			attr_dev(ol2, "class", " svelte-z80hvq");
    			attr_dev(ol2, "type", "1");
    			add_location(ol2, file$d, 13, 3, 755);
    			attr_dev(div2, "class", "policy-name");
    			add_location(div2, file$d, 12, 2, 726);
    			attr_dev(div3, "class", "policy-text");
    			add_location(div3, file$d, 8, 1, 144);
    			attr_dev(div4, "class", "container");
    			add_location(div4, file$d, 7, 0, 119);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, p0);
    			append_dev(p0, t2);
    			append_dev(p0, strong0);
    			append_dev(p0, t4);
    			append_dev(p0, a0);
    			append_dev(p0, t6);
    			append_dev(p0, strong1);
    			append_dev(p0, t8);
    			append_dev(div3, t9);
    			append_dev(div3, div2);
    			append_dev(div2, ol2);
    			append_dev(ol2, li0);
    			append_dev(li0, p1);
    			append_dev(p1, strong2);
    			append_dev(p1, t11);
    			append_dev(ol2, t12);
    			append_dev(ol2, li1);
    			append_dev(li1, p2);
    			append_dev(p2, strong3);
    			append_dev(p2, t14);
    			append_dev(ol2, t15);
    			append_dev(ol2, li2);
    			append_dev(li2, p3);
    			append_dev(p3, strong4);
    			append_dev(p3, t17);
    			append_dev(ol2, t18);
    			append_dev(ol2, li3);
    			append_dev(li3, p4);
    			append_dev(p4, strong5);
    			append_dev(p4, t20);
    			append_dev(li3, t21);
    			append_dev(li3, p5);
    			append_dev(ol2, t23);
    			append_dev(ol2, li12);
    			append_dev(li12, p6);
    			append_dev(p6, strong6);
    			append_dev(p6, br0);
    			append_dev(p6, t25);
    			append_dev(li12, t26);
    			append_dev(li12, ol0);
    			append_dev(ol0, li4);
    			append_dev(li4, p7);
    			append_dev(p7, strong7);
    			append_dev(p7, t28);
    			append_dev(ol0, t29);
    			append_dev(ol0, li5);
    			append_dev(li5, p8);
    			append_dev(p8, strong8);
    			append_dev(p8, t31);
    			append_dev(ol0, t32);
    			append_dev(ol0, li6);
    			append_dev(li6, p9);
    			append_dev(p9, strong9);
    			append_dev(p9, t34);
    			append_dev(p9, strong10);
    			append_dev(p9, t36);
    			append_dev(ol0, t37);
    			append_dev(ol0, li7);
    			append_dev(li7, p10);
    			append_dev(p10, strong11);
    			append_dev(p10, t39);
    			append_dev(ol0, t40);
    			append_dev(ol0, li8);
    			append_dev(li8, p11);
    			append_dev(p11, strong12);
    			append_dev(p11, t42);
    			append_dev(ol0, t43);
    			append_dev(ol0, li9);
    			append_dev(li9, p12);
    			append_dev(p12, strong13);
    			append_dev(p12, t45);
    			append_dev(ol0, t46);
    			append_dev(ol0, li10);
    			append_dev(li10, p13);
    			append_dev(p13, strong14);
    			append_dev(p13, t48);
    			append_dev(ol0, t49);
    			append_dev(ol0, li11);
    			append_dev(li11, p14);
    			append_dev(p14, strong15);
    			append_dev(p14, t51);
    			append_dev(ol2, t52);
    			append_dev(ol2, li13);
    			append_dev(li13, p15);
    			append_dev(p15, strong16);
    			append_dev(p15, t54);
    			append_dev(p15, a1);
    			append_dev(p15, t56);
    			append_dev(p15, strong17);
    			append_dev(p15, t58);
    			append_dev(ol2, t59);
    			append_dev(ol2, li14);
    			append_dev(li14, p16);
    			append_dev(p16, strong18);
    			append_dev(p16, t61);
    			append_dev(ol2, t62);
    			append_dev(ol2, li15);
    			append_dev(li15, p17);
    			append_dev(p17, strong19);
    			append_dev(p17, t64);
    			append_dev(ol2, t65);
    			append_dev(ol2, li26);
    			append_dev(li26, p18);
    			append_dev(p18, strong20);
    			append_dev(p18, t67);
    			append_dev(li26, t68);
    			append_dev(li26, p19);
    			append_dev(p19, t69);
    			append_dev(p19, br1);
    			append_dev(p19, t70);
    			append_dev(p19, br2);
    			append_dev(p19, t71);
    			append_dev(p19, br3);
    			append_dev(p19, t72);
    			append_dev(li26, t73);
    			append_dev(li26, p20);
    			append_dev(p20, t74);
    			append_dev(p20, br4);
    			append_dev(p20, t75);
    			append_dev(p20, br5);
    			append_dev(p20, t76);
    			append_dev(li26, t77);
    			append_dev(li26, p21);
    			append_dev(li26, t79);
    			append_dev(li26, ol1);
    			append_dev(ol1, li16);
    			append_dev(li16, p22);
    			append_dev(ol1, t81);
    			append_dev(ol1, li17);
    			append_dev(li17, p23);
    			append_dev(ol1, t83);
    			append_dev(ol1, li18);
    			append_dev(li18, p24);
    			append_dev(ol1, t85);
    			append_dev(ol1, li19);
    			append_dev(li19, p25);
    			append_dev(ol1, t87);
    			append_dev(ol1, li20);
    			append_dev(li20, p26);
    			append_dev(ol1, t89);
    			append_dev(ol1, li21);
    			append_dev(li21, p27);
    			append_dev(li21, t91);
    			append_dev(li21, p28);
    			append_dev(p28, em0);
    			append_dev(li21, t93);
    			append_dev(li21, p29);
    			append_dev(p29, em1);
    			append_dev(ol1, t95);
    			append_dev(ol1, li22);
    			append_dev(ol1, t97);
    			append_dev(ol1, li23);
    			append_dev(ol1, t99);
    			append_dev(ol1, li24);
    			append_dev(ol1, t101);
    			append_dev(ol1, li25);
    			append_dev(ol2, t103);
    			append_dev(ol2, li27);
    			append_dev(li27, strong21);
    			append_dev(li27, t105);
    			append_dev(ol2, t106);
    			append_dev(ol2, li28);
    			append_dev(li28, strong22);
    			append_dev(li28, t108);
    			append_dev(ol2, t109);
    			append_dev(ol2, li29);
    			append_dev(li29, strong23);
    			append_dev(li29, t111);
    			append_dev(ol2, t112);
    			append_dev(ol2, li30);
    			append_dev(li30, strong24);
    			append_dev(li30, t114);
    			append_dev(ol2, t115);
    			append_dev(ol2, li31);
    			append_dev(li31, strong25);
    			append_dev(li31, t117);
    			append_dev(ol2, t118);
    			append_dev(ol2, li32);
    			append_dev(li32, strong26);
    			append_dev(li32, t120);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TermsOfUse', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TermsOfUse> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class TermsOfUse extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TermsOfUse",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src/pages/users/Dashboard-day-zero-leader.svelte generated by Svelte v3.41.0 */
    const file$c = "src/pages/users/Dashboard-day-zero-leader.svelte";

    // (138:9) {#if dropdonwMenu}
    function create_if_block_3(ctx) {
    	let div;
    	let a0;
    	let t1;
    	let a1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			a0.textContent = "Invite player";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Delete team";
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "svelte-pber58");
    			add_location(a0, file$c, 139, 11, 3332);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "svelte-pber58");
    			add_location(a1, file$c, 140, 11, 3373);
    			attr_dev(div, "class", "dropdown-content svelte-pber58");
    			add_location(div, file$c, 138, 10, 3259);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(div, t1);
    			append_dev(div, a1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a1, "click", /*click_handler_2*/ ctx[3], false, false, false),
    					listen_dev(
    						div,
    						"clickoutside",
    						function () {
    							if (is_function(/*dropdonwMenu*/ ctx[0])) /*dropdonwMenu*/ ctx[0].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(138:9) {#if dropdonwMenu}",
    		ctx
    	});

    	return block;
    }

    // (174:10) {#if dropdonwMenu}
    function create_if_block_2$1(ctx) {
    	let div;
    	let a0;
    	let t1;
    	let a1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			a0.textContent = "Kick Player";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Make Leader";
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "svelte-pber58");
    			add_location(a0, file$c, 175, 12, 4685);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "svelte-pber58");
    			add_location(a1, file$c, 176, 12, 4725);
    			attr_dev(div, "class", "dropdown-content svelte-pber58");
    			add_location(div, file$c, 174, 11, 4642);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(div, t1);
    			append_dev(div, a1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(174:10) {#if dropdonwMenu}",
    		ctx
    	});

    	return block;
    }

    // (195:10) {#if dropdonwMenu}
    function create_if_block_1$4(ctx) {
    	let div;
    	let a0;
    	let t1;
    	let a1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			a0.textContent = "Kick Player";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Make Leader";
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "svelte-pber58");
    			add_location(a0, file$c, 196, 12, 5422);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "svelte-pber58");
    			add_location(a1, file$c, 197, 12, 5462);
    			attr_dev(div, "class", "dropdown-content svelte-pber58");
    			add_location(div, file$c, 195, 11, 5379);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(div, t1);
    			append_dev(div, a1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(195:10) {#if dropdonwMenu}",
    		ctx
    	});

    	return block;
    }

    // (216:10) {#if dropdonwMenu}
    function create_if_block$9(ctx) {
    	let div;
    	let a0;
    	let t1;
    	let a1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			a0.textContent = "Kick Player";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Make Leader";
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "svelte-pber58");
    			add_location(a0, file$c, 217, 12, 6159);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "svelte-pber58");
    			add_location(a1, file$c, 218, 12, 6199);
    			attr_dev(div, "class", "dropdown-content svelte-pber58");
    			add_location(div, file$c, 216, 11, 6116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(div, t1);
    			append_dev(div, a1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(216:10) {#if dropdonwMenu}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let section0;
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let section1;
    	let div3;
    	let div2;
    	let ul0;
    	let li0;
    	let a0;
    	let t3;
    	let li1;
    	let a1;
    	let t5;
    	let li2;
    	let a2;
    	let t7;
    	let li3;
    	let a3;
    	let t9;
    	let div27;
    	let div26;
    	let div5;
    	let ul1;
    	let li4;
    	let img0;
    	let img0_src_value;
    	let t10;
    	let strong0;
    	let t12;
    	let span0;
    	let t14;
    	let li5;
    	let strong1;
    	let t16;
    	let span1;
    	let t18;
    	let li6;
    	let strong2;
    	let t20;
    	let span2;
    	let t22;
    	let div4;
    	let button0;
    	let t24;
    	let div25;
    	let div11;
    	let div10;
    	let div6;
    	let a4;
    	let span3;
    	let t26;
    	let span4;
    	let t28;
    	let small;
    	let t30;
    	let div7;
    	let ul2;
    	let li7;
    	let strong3;
    	let t32;
    	let span5;
    	let t34;
    	let li8;
    	let strong4;
    	let t36;
    	let span6;
    	let t38;
    	let div9;
    	let ul3;
    	let li9;
    	let strong5;
    	let t40;
    	let span7;
    	let t42;
    	let li10;
    	let strong6;
    	let t44;
    	let span8;
    	let t46;
    	let div8;
    	let a5;
    	let t47;
    	let span9;
    	let t49;
    	let div24;
    	let div23;
    	let div22;
    	let h6;
    	let t50;
    	let div12;
    	let button1;
    	let span10;
    	let t52;
    	let t53;
    	let p;
    	let t55;
    	let div21;
    	let div14;
    	let img1;
    	let img1_src_value;
    	let t56;
    	let div13;
    	let strong7;
    	let t58;
    	let span11;
    	let t60;
    	let div16;
    	let a6;
    	let span12;
    	let t61;
    	let span13;
    	let t63;
    	let strong8;
    	let t65;
    	let div15;
    	let button2;
    	let span14;
    	let t67;
    	let t68;
    	let div18;
    	let a7;
    	let span15;
    	let t69;
    	let span16;
    	let t71;
    	let strong9;
    	let t73;
    	let div17;
    	let button3;
    	let span17;
    	let t75;
    	let t76;
    	let div20;
    	let a8;
    	let span18;
    	let t77;
    	let span19;
    	let t79;
    	let strong10;
    	let t81;
    	let div19;
    	let button4;
    	let span20;
    	let t83;
    	let mounted;
    	let dispose;
    	let if_block0 = /*dropdonwMenu*/ ctx[0] && create_if_block_3(ctx);
    	let if_block1 = /*dropdonwMenu*/ ctx[0] && create_if_block_2$1(ctx);
    	let if_block2 = /*dropdonwMenu*/ ctx[0] && create_if_block_1$4(ctx);
    	let if_block3 = /*dropdonwMenu*/ ctx[0] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Dashboard";
    			t1 = space();
    			section1 = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Profile";
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Your Team";
    			t5 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "Schedule";
    			t7 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "Standings";
    			t9 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div5 = element("div");
    			ul1 = element("ul");
    			li4 = element("li");
    			img0 = element("img");
    			t10 = space();
    			strong0 = element("strong");
    			strong0.textContent = "Name";
    			t12 = space();
    			span0 = element("span");
    			span0.textContent = "Victor Pacheco";
    			t14 = space();
    			li5 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Free Fire ID";
    			t16 = space();
    			span1 = element("span");
    			span1.textContent = "victor@qconquest.com";
    			t18 = space();
    			li6 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Mobile Number";
    			t20 = space();
    			span2 = element("span");
    			span2.textContent = "+91 9988776655";
    			t22 = space();
    			div4 = element("div");
    			button0 = element("button");
    			button0.textContent = "Log Out";
    			t24 = space();
    			div25 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			div6 = element("div");
    			a4 = element("a");
    			span3 = element("span");
    			span3.textContent = "backup";
    			t26 = space();
    			span4 = element("span");
    			span4.textContent = "Upload team logo";
    			t28 = space();
    			small = element("small");
    			small.textContent = ".jpg or .png file. Min 500px / 500px";
    			t30 = space();
    			div7 = element("div");
    			ul2 = element("ul");
    			li7 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Team Name";
    			t32 = space();
    			span5 = element("span");
    			span5.textContent = "Team Name Long";
    			t34 = space();
    			li8 = element("li");
    			strong4 = element("strong");
    			strong4.textContent = "Team ID";
    			t36 = space();
    			span6 = element("span");
    			span6.textContent = "QERT1124897";
    			t38 = space();
    			div9 = element("div");
    			ul3 = element("ul");
    			li9 = element("li");
    			strong5 = element("strong");
    			strong5.textContent = "Status";
    			t40 = space();
    			span7 = element("span");
    			span7.textContent = "Incomplete";
    			t42 = space();
    			li10 = element("li");
    			strong6 = element("strong");
    			strong6.textContent = "Requests";
    			t44 = space();
    			span8 = element("span");
    			span8.textContent = "3 new requests";
    			t46 = space();
    			div8 = element("div");
    			a5 = element("a");
    			t47 = text$1("See all reqeusts\n\t\t\t\t\t\t\t\t\t");
    			span9 = element("span");
    			span9.textContent = "keyboard_arrow_right";
    			t49 = space();
    			div24 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			h6 = element("h6");
    			t50 = text$1("Complete your team\n\t\t\t\t\t\t\t\t");
    			div12 = element("div");
    			button1 = element("button");
    			span10 = element("span");
    			span10.textContent = "more_horiz";
    			t52 = space();
    			if (if_block0) if_block0.c();
    			t53 = space();
    			p = element("p");
    			p.textContent = "Make sure you form your team by 12 October 2020. Incomplete teams will not qualify for In-game qualifiers stage. Good luck!";
    			t55 = space();
    			div21 = element("div");
    			div14 = element("div");
    			img1 = element("img");
    			t56 = space();
    			div13 = element("div");
    			strong7 = element("strong");
    			strong7.textContent = "Victor Pacheco";
    			t58 = space();
    			span11 = element("span");
    			span11.textContent = "Team Leader";
    			t60 = space();
    			div16 = element("div");
    			a6 = element("a");
    			span12 = element("span");
    			t61 = space();
    			span13 = element("span");
    			span13.textContent = "add_circle_outline";
    			t63 = space();
    			strong8 = element("strong");
    			strong8.textContent = "Add player";
    			t65 = space();
    			div15 = element("div");
    			button2 = element("button");
    			span14 = element("span");
    			span14.textContent = "more_horiz";
    			t67 = space();
    			if (if_block1) if_block1.c();
    			t68 = space();
    			div18 = element("div");
    			a7 = element("a");
    			span15 = element("span");
    			t69 = space();
    			span16 = element("span");
    			span16.textContent = "add_circle_outline";
    			t71 = space();
    			strong9 = element("strong");
    			strong9.textContent = "Add player";
    			t73 = space();
    			div17 = element("div");
    			button3 = element("button");
    			span17 = element("span");
    			span17.textContent = "more_horiz";
    			t75 = space();
    			if (if_block2) if_block2.c();
    			t76 = space();
    			div20 = element("div");
    			a8 = element("a");
    			span18 = element("span");
    			t77 = space();
    			span19 = element("span");
    			span19.textContent = "add_circle_outline";
    			t79 = space();
    			strong10 = element("strong");
    			strong10.textContent = "Add player";
    			t81 = space();
    			div19 = element("div");
    			button4 = element("button");
    			span20 = element("span");
    			span20.textContent = "more_horiz";
    			t83 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$c, 11, 3, 391);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$c, 10, 2, 362);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$c, 9, 1, 336);
    			attr_dev(section0, "class", "banner");
    			add_location(section0, file$c, 8, 0, 310);
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$c, 22, 5, 575);
    			attr_dev(li0, "class", "svelte-pber58");
    			add_location(li0, file$c, 21, 4, 565);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$c, 27, 5, 651);
    			attr_dev(li1, "class", "active svelte-pber58");
    			add_location(li1, file$c, 26, 4, 626);
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$c, 32, 5, 714);
    			attr_dev(li2, "class", "svelte-pber58");
    			add_location(li2, file$c, 31, 4, 704);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$c, 37, 5, 776);
    			attr_dev(li3, "class", "svelte-pber58");
    			add_location(li3, file$c, 36, 4, 766);
    			attr_dev(ul0, "class", "svelte-pber58");
    			add_location(ul0, file$c, 20, 3, 556);
    			attr_dev(div2, "class", "container");
    			add_location(div2, file$c, 19, 2, 529);
    			attr_dev(div3, "class", "profile-menu");
    			add_location(div3, file$c, 18, 1, 500);
    			attr_dev(img0, "class", "profile-pic-md rounded");
    			if (!src_url_equal(img0.src, img0_src_value = "images/profile-pic.jpg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "align", "Profile-pic");
    			add_location(img0, file$c, 49, 6, 977);
    			attr_dev(strong0, "class", "svelte-pber58");
    			add_location(strong0, file$c, 50, 6, 1069);
    			attr_dev(span0, "class", "svelte-pber58");
    			add_location(span0, file$c, 53, 6, 1112);
    			attr_dev(li4, "class", "svelte-pber58");
    			add_location(li4, file$c, 48, 5, 966);
    			attr_dev(strong1, "class", "svelte-pber58");
    			add_location(strong1, file$c, 58, 6, 1182);
    			attr_dev(span1, "class", "svelte-pber58");
    			add_location(span1, file$c, 61, 6, 1233);
    			attr_dev(li5, "class", "svelte-pber58");
    			add_location(li5, file$c, 57, 5, 1171);
    			attr_dev(strong2, "class", "svelte-pber58");
    			add_location(strong2, file$c, 66, 6, 1309);
    			attr_dev(span2, "class", "svelte-pber58");
    			add_location(span2, file$c, 69, 6, 1361);
    			attr_dev(li6, "class", "svelte-pber58");
    			add_location(li6, file$c, 65, 5, 1298);
    			attr_dev(ul1, "class", "profil-info svelte-pber58");
    			add_location(ul1, file$c, 47, 4, 936);
    			attr_dev(button0, "class", "btn plain-btn");
    			add_location(button0, file$c, 75, 5, 1460);
    			attr_dev(div4, "class", "text-center");
    			add_location(div4, file$c, 74, 4, 1429);
    			attr_dev(div5, "class", "col-4 border-right");
    			add_location(div5, file$c, 46, 3, 899);
    			attr_dev(span3, "class", "material-icons upload-img-static svelte-pber58");
    			add_location(span3, file$c, 85, 8, 1743);
    			attr_dev(span4, "class", "svelte-pber58");
    			add_location(span4, file$c, 88, 8, 1831);
    			attr_dev(small, "class", "svelte-pber58");
    			add_location(small, file$c, 89, 8, 1869);
    			attr_dev(a4, "class", "team-details text-center upload-team-logo svelte-pber58");
    			add_location(a4, file$c, 84, 7, 1681);
    			attr_dev(div6, "class", "col-4");
    			add_location(div6, file$c, 83, 6, 1654);
    			attr_dev(strong3, "class", "svelte-pber58");
    			add_location(strong3, file$c, 95, 9, 2033);
    			attr_dev(span5, "class", "svelte-pber58");
    			add_location(span5, file$c, 96, 9, 2069);
    			attr_dev(li7, "class", "svelte-pber58");
    			add_location(li7, file$c, 94, 8, 2019);
    			attr_dev(strong4, "class", "svelte-pber58");
    			add_location(strong4, file$c, 99, 9, 2133);
    			attr_dev(span6, "class", "svelte-pber58");
    			add_location(span6, file$c, 100, 9, 2167);
    			attr_dev(li8, "class", "svelte-pber58");
    			add_location(li8, file$c, 98, 8, 2119);
    			attr_dev(ul2, "class", "team-details pt-30 svelte-pber58");
    			add_location(ul2, file$c, 93, 7, 1979);
    			attr_dev(div7, "class", "col-4");
    			add_location(div7, file$c, 92, 6, 1952);
    			attr_dev(strong5, "class", "svelte-pber58");
    			add_location(strong5, file$c, 107, 9, 2327);
    			attr_dev(span7, "class", "svelte-pber58");
    			add_location(span7, file$c, 108, 9, 2360);
    			attr_dev(li9, "class", "svelte-pber58");
    			add_location(li9, file$c, 106, 8, 2313);
    			attr_dev(strong6, "class", "svelte-pber58");
    			add_location(strong6, file$c, 111, 9, 2438);
    			attr_dev(span8, "class", "svelte-pber58");
    			add_location(span8, file$c, 112, 9, 2473);
    			attr_dev(li10, "class", "no-margin svelte-pber58");
    			add_location(li10, file$c, 110, 8, 2406);
    			attr_dev(ul3, "class", "team-details reqeust pt-30 svelte-pber58");
    			add_location(ul3, file$c, 105, 7, 2265);
    			attr_dev(span9, "class", "material-icons");
    			add_location(span9, file$c, 118, 9, 2684);
    			attr_dev(a5, "href", "#");
    			attr_dev(a5, "class", "survey-link no-margin");
    			add_location(a5, file$c, 116, 8, 2562);
    			attr_dev(div8, "class", "mt-2");
    			add_location(div8, file$c, 115, 7, 2535);
    			attr_dev(div9, "class", "col-4");
    			add_location(div9, file$c, 104, 6, 2238);
    			attr_dev(div10, "class", "row");
    			add_location(div10, file$c, 82, 5, 1630);
    			attr_dev(div11, "class", "upload-block teacm-full-details p-40 svelte-pber58");
    			add_location(div11, file$c, 81, 4, 1574);
    			attr_dev(span10, "class", "material-icons");
    			add_location(span10, file$c, 133, 10, 3130);
    			attr_dev(button1, "class", "dropbtn svelte-pber58");
    			add_location(button1, file$c, 132, 9, 3049);
    			attr_dev(div12, "class", "dropdown team-actions-dropdown svelte-pber58");
    			add_location(div12, file$c, 131, 8, 2995);
    			attr_dev(h6, "class", "title svelte-pber58");
    			add_location(h6, file$c, 129, 7, 2941);
    			attr_dev(p, "class", "response-desc svelte-pber58");
    			add_location(p, file$c, 145, 7, 3511);
    			attr_dev(img1, "class", "pic profile-pic-sm rounded svelte-pber58");
    			if (!src_url_equal(img1.src, img1_src_value = "images/profile-pic.jpg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "align", "Profile-pic");
    			add_location(img1, file$c, 150, 9, 3758);
    			attr_dev(strong7, "class", "player-name svelte-pber58");
    			add_location(strong7, file$c, 152, 10, 3893);
    			attr_dev(span11, "class", "player-position svelte-pber58");
    			add_location(span11, file$c, 155, 10, 3978);
    			attr_dev(div13, "class", "player-info svelte-pber58");
    			add_location(div13, file$c, 151, 9, 3857);
    			attr_dev(div14, "class", "player svelte-pber58");
    			add_location(div14, file$c, 149, 8, 3728);
    			attr_dev(span12, "class", "bg-icon svelte-pber58");
    			add_location(span12, file$c, 162, 10, 4226);
    			attr_dev(span13, "class", "material-icons svelte-pber58");
    			add_location(span13, file$c, 164, 10, 4277);
    			attr_dev(strong8, "class", "svelte-pber58");
    			add_location(strong8, file$c, 165, 10, 4342);
    			attr_dev(a6, "href", "#");
    			attr_dev(a6, "class", "upload-img add-player-upload svelte-pber58");
    			add_location(a6, file$c, 161, 9, 4119);
    			attr_dev(span14, "class", "material-icons");
    			add_location(span14, file$c, 169, 11, 4508);
    			attr_dev(button2, "class", "dropbtn svelte-pber58");
    			add_location(button2, file$c, 168, 10, 4426);
    			attr_dev(div15, "class", "dropdown svelte-pber58");
    			add_location(div15, file$c, 167, 9, 4393);
    			attr_dev(div16, "class", "player svelte-pber58");
    			add_location(div16, file$c, 160, 8, 4089);
    			attr_dev(span15, "class", "bg-icon svelte-pber58");
    			add_location(span15, file$c, 183, 10, 4963);
    			attr_dev(span16, "class", "material-icons svelte-pber58");
    			add_location(span16, file$c, 185, 10, 5014);
    			attr_dev(strong9, "class", "svelte-pber58");
    			add_location(strong9, file$c, 186, 10, 5079);
    			attr_dev(a7, "href", "#");
    			attr_dev(a7, "class", "upload-img add-player-upload svelte-pber58");
    			add_location(a7, file$c, 182, 9, 4856);
    			attr_dev(span17, "class", "material-icons");
    			add_location(span17, file$c, 190, 11, 5245);
    			attr_dev(button3, "class", "dropbtn svelte-pber58");
    			add_location(button3, file$c, 189, 10, 5163);
    			attr_dev(div17, "class", "dropdown svelte-pber58");
    			add_location(div17, file$c, 188, 9, 5130);
    			attr_dev(div18, "class", "player svelte-pber58");
    			add_location(div18, file$c, 181, 8, 4826);
    			attr_dev(span18, "class", "bg-icon svelte-pber58");
    			add_location(span18, file$c, 204, 10, 5700);
    			attr_dev(span19, "class", "material-icons svelte-pber58");
    			add_location(span19, file$c, 206, 10, 5751);
    			attr_dev(strong10, "class", "svelte-pber58");
    			add_location(strong10, file$c, 207, 10, 5816);
    			attr_dev(a8, "href", "#");
    			attr_dev(a8, "class", "upload-img add-player-upload svelte-pber58");
    			add_location(a8, file$c, 203, 9, 5593);
    			attr_dev(span20, "class", "material-icons");
    			add_location(span20, file$c, 211, 11, 5982);
    			attr_dev(button4, "class", "dropbtn svelte-pber58");
    			add_location(button4, file$c, 210, 10, 5900);
    			attr_dev(div19, "class", "dropdown svelte-pber58");
    			add_location(div19, file$c, 209, 9, 5867);
    			attr_dev(div20, "class", "player svelte-pber58");
    			add_location(div20, file$c, 202, 8, 5563);
    			attr_dev(div21, "class", "d-flex overflow-x");
    			add_location(div21, file$c, 148, 7, 3688);
    			attr_dev(div22, "class", "col-12");
    			add_location(div22, file$c, 128, 6, 2913);
    			attr_dev(div23, "class", "row");
    			add_location(div23, file$c, 127, 5, 2889);
    			attr_dev(div24, "class", "upload-block awating-response p-40 mt-20 svelte-pber58");
    			add_location(div24, file$c, 126, 4, 2829);
    			attr_dev(div25, "class", "col-8 pl-50");
    			add_location(div25, file$c, 80, 3, 1544);
    			attr_dev(div26, "class", "row");
    			add_location(div26, file$c, 45, 2, 878);
    			attr_dev(div27, "class", "container");
    			add_location(div27, file$c, 44, 1, 852);
    			attr_dev(section1, "class", "main-content");
    			add_location(section1, file$c, 17, 0, 468);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div3);
    			append_dev(div3, div2);
    			append_dev(div2, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a0);
    			append_dev(ul0, t3);
    			append_dev(ul0, li1);
    			append_dev(li1, a1);
    			append_dev(ul0, t5);
    			append_dev(ul0, li2);
    			append_dev(li2, a2);
    			append_dev(ul0, t7);
    			append_dev(ul0, li3);
    			append_dev(li3, a3);
    			append_dev(section1, t9);
    			append_dev(section1, div27);
    			append_dev(div27, div26);
    			append_dev(div26, div5);
    			append_dev(div5, ul1);
    			append_dev(ul1, li4);
    			append_dev(li4, img0);
    			append_dev(li4, t10);
    			append_dev(li4, strong0);
    			append_dev(li4, t12);
    			append_dev(li4, span0);
    			append_dev(ul1, t14);
    			append_dev(ul1, li5);
    			append_dev(li5, strong1);
    			append_dev(li5, t16);
    			append_dev(li5, span1);
    			append_dev(ul1, t18);
    			append_dev(ul1, li6);
    			append_dev(li6, strong2);
    			append_dev(li6, t20);
    			append_dev(li6, span2);
    			append_dev(div5, t22);
    			append_dev(div5, div4);
    			append_dev(div4, button0);
    			append_dev(div26, t24);
    			append_dev(div26, div25);
    			append_dev(div25, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div6);
    			append_dev(div6, a4);
    			append_dev(a4, span3);
    			append_dev(a4, t26);
    			append_dev(a4, span4);
    			append_dev(a4, t28);
    			append_dev(a4, small);
    			append_dev(div10, t30);
    			append_dev(div10, div7);
    			append_dev(div7, ul2);
    			append_dev(ul2, li7);
    			append_dev(li7, strong3);
    			append_dev(li7, t32);
    			append_dev(li7, span5);
    			append_dev(ul2, t34);
    			append_dev(ul2, li8);
    			append_dev(li8, strong4);
    			append_dev(li8, t36);
    			append_dev(li8, span6);
    			append_dev(div10, t38);
    			append_dev(div10, div9);
    			append_dev(div9, ul3);
    			append_dev(ul3, li9);
    			append_dev(li9, strong5);
    			append_dev(li9, t40);
    			append_dev(li9, span7);
    			append_dev(ul3, t42);
    			append_dev(ul3, li10);
    			append_dev(li10, strong6);
    			append_dev(li10, t44);
    			append_dev(li10, span8);
    			append_dev(div9, t46);
    			append_dev(div9, div8);
    			append_dev(div8, a5);
    			append_dev(a5, t47);
    			append_dev(a5, span9);
    			append_dev(div25, t49);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, h6);
    			append_dev(h6, t50);
    			append_dev(h6, div12);
    			append_dev(div12, button1);
    			append_dev(button1, span10);
    			append_dev(div12, t52);
    			if (if_block0) if_block0.m(div12, null);
    			append_dev(div22, t53);
    			append_dev(div22, p);
    			append_dev(div22, t55);
    			append_dev(div22, div21);
    			append_dev(div21, div14);
    			append_dev(div14, img1);
    			append_dev(div14, t56);
    			append_dev(div14, div13);
    			append_dev(div13, strong7);
    			append_dev(div13, t58);
    			append_dev(div13, span11);
    			append_dev(div21, t60);
    			append_dev(div21, div16);
    			append_dev(div16, a6);
    			append_dev(a6, span12);
    			append_dev(a6, t61);
    			append_dev(a6, span13);
    			append_dev(a6, t63);
    			append_dev(a6, strong8);
    			append_dev(div16, t65);
    			append_dev(div16, div15);
    			append_dev(div15, button2);
    			append_dev(button2, span14);
    			append_dev(div15, t67);
    			if (if_block1) if_block1.m(div15, null);
    			append_dev(div21, t68);
    			append_dev(div21, div18);
    			append_dev(div18, a7);
    			append_dev(a7, span15);
    			append_dev(a7, t69);
    			append_dev(a7, span16);
    			append_dev(a7, t71);
    			append_dev(a7, strong9);
    			append_dev(div18, t73);
    			append_dev(div18, div17);
    			append_dev(div17, button3);
    			append_dev(button3, span17);
    			append_dev(div17, t75);
    			if (if_block2) if_block2.m(div17, null);
    			append_dev(div21, t76);
    			append_dev(div21, div20);
    			append_dev(div20, a8);
    			append_dev(a8, span18);
    			append_dev(a8, t77);
    			append_dev(a8, span19);
    			append_dev(a8, t79);
    			append_dev(a8, strong10);
    			append_dev(div20, t81);
    			append_dev(div20, div19);
    			append_dev(div19, button4);
    			append_dev(button4, span20);
    			append_dev(div19, t83);
    			if (if_block3) if_block3.m(div19, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a5, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false),
    					listen_dev(a6, "click", /*click_handler_3*/ ctx[4], false, false, false),
    					listen_dev(button2, "click", /*click_handler_4*/ ctx[5], false, false, false),
    					listen_dev(a7, "click", /*click_handler_5*/ ctx[6], false, false, false),
    					listen_dev(button3, "click", /*click_handler_6*/ ctx[7], false, false, false),
    					listen_dev(a8, "click", /*click_handler_7*/ ctx[8], false, false, false),
    					listen_dev(button4, "click", /*click_handler_8*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*dropdonwMenu*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(div12, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*dropdonwMenu*/ ctx[0]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					if_block1.m(div15, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*dropdonwMenu*/ ctx[0]) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_1$4(ctx);
    					if_block2.c();
    					if_block2.m(div17, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*dropdonwMenu*/ ctx[0]) {
    				if (if_block3) ; else {
    					if_block3 = create_if_block$9(ctx);
    					if_block3.c();
    					if_block3.m(div19, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dashboard_day_zero_leader', slots, []);
    	let dropdonwMenu = false;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dashboard_day_zero_leader> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => Modal.open(RequestModal);
    	const click_handler_1 = () => $$invalidate(0, dropdonwMenu = !dropdonwMenu);
    	const click_handler_2 = () => Modal.open(DeleteModal);
    	const click_handler_3 = () => Modal.open(TeamInviteModal);
    	const click_handler_4 = () => $$invalidate(0, dropdonwMenu = !dropdonwMenu);
    	const click_handler_5 = () => Modal.open(TeamInviteModal);
    	const click_handler_6 = () => $$invalidate(0, dropdonwMenu = !dropdonwMenu);
    	const click_handler_7 = () => Modal.open(TeamInviteModal);
    	const click_handler_8 = () => $$invalidate(0, dropdonwMenu = !dropdonwMenu);

    	$$self.$capture_state = () => ({
    		RequestModal,
    		DeleteModal,
    		TeamInviteModal,
    		Modal,
    		dropdonwMenu
    	});

    	$$self.$inject_state = $$props => {
    		if ('dropdonwMenu' in $$props) $$invalidate(0, dropdonwMenu = $$props.dropdonwMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dropdonwMenu,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8
    	];
    }

    class Dashboard_day_zero_leader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard_day_zero_leader",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/pages/Location.svelte generated by Svelte v3.41.0 */
    const file$b = "src/pages/Location.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (30:4) {#each states as state}
    function create_each_block_1$2(ctx) {
    	let option;
    	let t_value = /*state*/ ctx[16] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*state*/ ctx[16];
    			option.value = option.__value;
    			add_location(option, file$b, 30, 5, 943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*states*/ 2 && t_value !== (t_value = /*state*/ ctx[16] + "")) set_data_dev(t, t_value);

    			if (dirty & /*states*/ 2 && option_value_value !== (option_value_value = /*state*/ ctx[16])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(30:4) {#each states as state}",
    		ctx
    	});

    	return block;
    }

    // (35:2) {#if selectedState}
    function create_if_block_1$3(ctx) {
    	let div;
    	let select;
    	let option0;
    	let option1;
    	let mounted;
    	let dispose;
    	let each_value = /*cities*/ ctx[0].filter(/*func*/ ctx[8]).map(func_1).sort();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select City / Town";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			option1 = element("option");
    			option1.textContent = "Other";
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			option0.hidden = true;
    			add_location(option0, file$b, 37, 5, 1186);
    			option1.__value = "other";
    			option1.value = option1.__value;
    			add_location(option1, file$b, 41, 5, 1407);
    			attr_dev(select, "name", "city");
    			attr_dev(select, "class", "text-box select-box");
    			if (/*selectedCity*/ ctx[3] === void 0) add_render_callback(() => /*select_change_handler_1*/ ctx[9].call(select));
    			add_location(select, file$b, 36, 4, 1071);
    			attr_dev(div, "class", "form-group");
    			add_location(div, file$b, 35, 3, 1041);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select);
    			append_dev(select, option0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(select, option1);
    			select_option(select, /*selectedCity*/ ctx[3]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler_1*/ ctx[9]),
    					listen_dev(select, "change", /*change_handler_1*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cities, selectedState*/ 5) {
    				each_value = /*cities*/ ctx[0].filter(/*func*/ ctx[8]).map(func_1).sort();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, option1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*selectedCity, cities, selectedState*/ 13) {
    				select_option(select, /*selectedCity*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(35:2) {#if selectedState}",
    		ctx
    	});

    	return block;
    }

    // (39:5) {#each cities.filter(c => c.state == selectedState).map(c => c.name).sort() as city}
    function create_each_block$4(ctx) {
    	let option;
    	let t_value = /*city*/ ctx[13] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*city*/ ctx[13];
    			option.value = option.__value;
    			add_location(option, file$b, 39, 6, 1352);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cities, selectedState*/ 5 && t_value !== (t_value = /*city*/ ctx[13] + "")) set_data_dev(t, t_value);

    			if (dirty & /*cities, selectedState, states*/ 7 && option_value_value !== (option_value_value = /*city*/ ctx[13])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(39:5) {#each cities.filter(c => c.state == selectedState).map(c => c.name).sort() as city}",
    		ctx
    	});

    	return block;
    }

    // (46:2) {#if selectedCity == 'other'}
    function create_if_block$8(ctx) {
    	let div;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "form-control text-box");
    			add_location(input, file$b, 47, 4, 1541);
    			attr_dev(div, "class", "form-group");
    			add_location(div, file$b, 46, 3, 1511);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*otherCity*/ ctx[4]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[11]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*otherCity*/ 16 && input.value !== /*otherCity*/ ctx[4]) {
    				set_input_value(input, /*otherCity*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(46:2) {#if selectedCity == 'other'}",
    		ctx
    	});

    	return block;
    }

    // (24:0) <LoginLayout title="Your Location" step={2}>
    function create_default_slot$3(ctx) {
    	let form;
    	let div0;
    	let label;
    	let t0;
    	let select;
    	let option;
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let button;
    	let t5;
    	let button_disabled_value;
    	let t6;
    	let div2;
    	let p;
    	let strong;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*states*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let if_block0 = /*selectedState*/ ctx[2] && create_if_block_1$3(ctx);
    	let if_block1 = /*selectedCity*/ ctx[3] == 'other' && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div0 = element("div");
    			label = element("label");
    			t0 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "Select State";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div1 = element("div");
    			button = element("button");
    			t5 = text$1("Proceed");
    			t6 = space();
    			div2 = element("div");
    			p = element("p");
    			strong = element("strong");
    			strong.textContent = "Note: Players from the states of Andhra Pradesh, Odisha, Sikkim, Nagaland and Assam are not eligible to participate in the tournament due to local governing laws, state regulations and restrictions.";
    			attr_dev(label, "class", "lbl-txt");
    			attr_dev(label, "for", "states");
    			add_location(label, file$b, 26, 3, 678);
    			option.__value = "";
    			option.value = option.__value;
    			option.disabled = true;
    			option.selected = true;
    			option.hidden = true;
    			add_location(option, file$b, 28, 4, 846);
    			attr_dev(select, "name", "states");
    			attr_dev(select, "class", "text-box select-box");
    			if (/*selectedState*/ ctx[2] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[6].call(select));
    			add_location(select, file$b, 27, 3, 726);
    			attr_dev(div0, "class", "form-group");
    			add_location(div0, file$b, 25, 2, 650);
    			attr_dev(button, "class", "btn btn-primary verify-btn submit-btn");
    			button.disabled = button_disabled_value = !/*selectedCity*/ ctx[3] || /*selectedCity*/ ctx[3] == 'other' && /*otherCity*/ ctx[4].length < 3;
    			add_location(button, file$b, 51, 3, 1664);
    			attr_dev(div1, "class", "btn-section");
    			add_location(div1, file$b, 50, 2, 1635);
    			add_location(form, file$b, 24, 1, 641);
    			add_location(strong, file$b, 56, 3, 1878);
    			add_location(p, file$b, 55, 2, 1871);
    			attr_dev(div2, "class", "mt-40");
    			add_location(div2, file$b, 54, 1, 1849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, label);
    			append_dev(div0, t0);
    			append_dev(div0, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*selectedState*/ ctx[2]);
    			append_dev(form, t2);
    			if (if_block0) if_block0.m(form, null);
    			append_dev(form, t3);
    			if (if_block1) if_block1.m(form, null);
    			append_dev(form, t4);
    			append_dev(form, div1);
    			append_dev(div1, button);
    			append_dev(button, t5);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, p);
    			append_dev(p, strong);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[6]),
    					listen_dev(select, "change", /*change_handler*/ ctx[7], false, false, false),
    					listen_dev(button, "click", /*onSubmit*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*states*/ 2) {
    				each_value_1 = /*states*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*selectedState, states*/ 6) {
    				select_option(select, /*selectedState*/ ctx[2]);
    			}

    			if (/*selectedState*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(form, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*selectedCity*/ ctx[3] == 'other') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					if_block1.m(form, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*selectedCity, otherCity, cities, selectedState*/ 29 && button_disabled_value !== (button_disabled_value = !/*selectedCity*/ ctx[3] || /*selectedCity*/ ctx[3] == 'other' && /*otherCity*/ ctx[4].length < 3)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(24:0) <LoginLayout title=\\\"Your Location\\\" step={2}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let loginlayout;
    	let current;

    	loginlayout = new Login$1({
    			props: {
    				title: "Your Location",
    				step: 2,
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loginlayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(loginlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const loginlayout_changes = {};

    			if (dirty & /*$$scope, selectedCity, otherCity, cities, selectedState, states*/ 524319) {
    				loginlayout_changes.$$scope = { dirty, ctx };
    			}

    			loginlayout.$set(loginlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loginlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func_1 = c => c.name;

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Location', slots, []);
    	let user = User.getInstance();
    	let cities = [];
    	let states = [];

    	fetch('/states.json').then(r => r.json()).then(res => {
    		$$invalidate(0, cities = res);
    		$$invalidate(1, states = Array(...new Set(cities.map(i => i.state))).sort());
    	});

    	let selectedState = '';
    	let selectedCity = '';
    	let otherCity = '';

    	const onSubmit = async e => {
    		e.preventDefault();

    		await user.update({
    			state: selectedState,
    			city: selectedCity != 'other' ? selectedCity : otherCity
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Location> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		selectedState = select_value(this);
    		$$invalidate(2, selectedState);
    		$$invalidate(1, states);
    	}

    	const change_handler = () => {
    		$$invalidate(3, selectedCity = '');
    	};

    	const func = c => c.state == selectedState;

    	function select_change_handler_1() {
    		selectedCity = select_value(this);
    		$$invalidate(3, selectedCity);
    		$$invalidate(0, cities);
    		$$invalidate(2, selectedState);
    	}

    	const change_handler_1 = () => {
    		$$invalidate(4, otherCity = '');
    	};

    	function input_input_handler() {
    		otherCity = this.value;
    		$$invalidate(4, otherCity);
    	}

    	$$self.$capture_state = () => ({
    		LoginLayout: Login$1,
    		Select,
    		User,
    		user,
    		cities,
    		states,
    		selectedState,
    		selectedCity,
    		otherCity,
    		onSubmit
    	});

    	$$self.$inject_state = $$props => {
    		if ('user' in $$props) user = $$props.user;
    		if ('cities' in $$props) $$invalidate(0, cities = $$props.cities);
    		if ('states' in $$props) $$invalidate(1, states = $$props.states);
    		if ('selectedState' in $$props) $$invalidate(2, selectedState = $$props.selectedState);
    		if ('selectedCity' in $$props) $$invalidate(3, selectedCity = $$props.selectedCity);
    		if ('otherCity' in $$props) $$invalidate(4, otherCity = $$props.otherCity);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cities,
    		states,
    		selectedState,
    		selectedCity,
    		otherCity,
    		onSubmit,
    		select_change_handler,
    		change_handler,
    		func,
    		select_change_handler_1,
    		change_handler_1,
    		input_input_handler
    	];
    }

    class Location extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Location",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/pages/SuccessfulRegisterion.svelte generated by Svelte v3.41.0 */
    const file$a = "src/pages/SuccessfulRegisterion.svelte";

    function create_fragment$c(ctx) {
    	let form;
    	let div0;
    	let p;
    	let t1;
    	let div1;
    	let a0;
    	let t3;
    	let a1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			form = element("form");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "Congratulations! You've successfully registered your account. To complete your registration for the tournament you can either create your own team and invite your friends or join an existing team. You can change your squad roster or join other teams during the duration of the registration phase. Please ensure that all 4 slots of your team are filled before the registrations ends. Roster changes after the end of the registration phase will not be permitted and incomplete teams will be disqualified.";
    			t1 = space();
    			div1 = element("div");
    			a0 = element("a");
    			a0.textContent = "Proceed to Dashboard";
    			t3 = space();
    			a1 = element("a");
    			a1.textContent = "Back to Home";
    			add_location(p, file$a, 8, 2, 172);
    			attr_dev(div0, "class", "successful-reg-text");
    			add_location(div0, file$a, 7, 1, 136);
    			attr_dev(a0, "href", "/dashboard");
    			attr_dev(a0, "type", "submit");
    			attr_dev(a0, "class", "btn btn-primary verify-btn");
    			add_location(a0, file$a, 13, 2, 726);
    			attr_dev(a1, "href", "/");
    			attr_dev(a1, "type", "submit");
    			attr_dev(a1, "class", "btn btn-primary verify-btn back-to-home-btn");
    			add_location(a1, file$a, 17, 2, 907);
    			attr_dev(div1, "class", "btn-section");
    			add_location(div1, file$a, 12, 1, 698);
    			add_location(form, file$a, 6, 0, 128);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, p);
    			append_dev(form, t1);
    			append_dev(form, div1);
    			append_dev(div1, a0);
    			append_dev(div1, t3);
    			append_dev(div1, a1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SuccessfulRegisterion', slots, []);
    	const userStore = User.getUser();
    	const user = User.getInstance();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SuccessfulRegisterion> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		e.preventDefault();
    		user.update({ reg_complete: true });
    	};

    	const click_handler_1 = e => {
    		e.preventDefault();
    		user.update({ reg_complete: true });
    	};

    	$$self.$capture_state = () => ({ User, userStore, user });
    	return [user, click_handler, click_handler_1];
    }

    class SuccessfulRegisterion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SuccessfulRegisterion",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src/pages/Device_Details.svelte generated by Svelte v3.41.0 */
    const file$9 = "src/pages/Device_Details.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (57:1) {:else}
    function create_else_block$3(ctx) {
    	let successfulregistration;
    	let current;
    	successfulregistration = new SuccessfulRegisterion({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(successfulregistration.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(successfulregistration, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(successfulregistration.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(successfulregistration.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(successfulregistration, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(57:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:1) {#if !updatedUser.device_brand}
    function create_if_block$7(ctx) {
    	let form;
    	let div0;
    	let label;
    	let t0;
    	let select;
    	let t1;
    	let t2;
    	let div1;
    	let button;
    	let t3;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	select = new Select({
    			props: {
    				items: Array.from(new Set(/*devices*/ ctx[0].map(func))),
    				placeholder: "Select make",
    				isClearable: false
    			},
    			$$inline: true
    		});

    	select.$on("select", /*select_handler*/ ctx[5]);
    	let if_block = /*userDevice*/ ctx[1].device_brand && /*userDevice*/ ctx[1].device_brand != 'Others' && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div0 = element("div");
    			label = element("label");
    			t0 = space();
    			create_component(select.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			div1 = element("div");
    			button = element("button");
    			t3 = text$1("Proceed");
    			attr_dev(label, "class", "lbl-txt");
    			attr_dev(label, "for", "states");
    			add_location(label, file$9, 25, 3, 973);
    			attr_dev(div0, "class", "form-group svelte-4fwqcc");
    			add_location(div0, file$9, 24, 2, 945);
    			attr_dev(button, "class", "btn btn-primary verify-btn submit-btn");
    			button.disabled = button_disabled_value = !(/*userDevice*/ ctx[1].device_model || /*userDevice*/ ctx[1].device_brand == 'Others');
    			add_location(button, file$9, 53, 3, 2143);
    			attr_dev(div1, "class", "btn-section");
    			add_location(div1, file$9, 52, 2, 2114);
    			add_location(form, file$9, 23, 1, 936);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, label);
    			append_dev(div0, t0);
    			mount_component(select, div0, null);
    			append_dev(form, t1);
    			if (if_block) if_block.m(form, null);
    			append_dev(form, t2);
    			append_dev(form, div1);
    			append_dev(div1, button);
    			append_dev(button, t3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onSubmit*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const select_changes = {};
    			if (dirty & /*devices*/ 1) select_changes.items = Array.from(new Set(/*devices*/ ctx[0].map(func)));
    			select.$set(select_changes);

    			if (/*userDevice*/ ctx[1].device_brand && /*userDevice*/ ctx[1].device_brand != 'Others') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(form, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*userDevice, Array, Set, devices*/ 3 && button_disabled_value !== (button_disabled_value = !(/*userDevice*/ ctx[1].device_model || /*userDevice*/ ctx[1].device_brand == 'Others'))) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(select);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(23:1) {#if !updatedUser.device_brand}",
    		ctx
    	});

    	return block;
    }

    // (33:2) {#if userDevice.device_brand && userDevice.device_brand != 'Others'}
    function create_if_block_1$2(ctx) {
    	let div;
    	let select;
    	let option0;
    	let option1;
    	let t2;
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let each_value_1 = Array.from(new Set(/*devices*/ ctx[0].filter(/*func_1*/ ctx[6]).map(func_2)));
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let if_block = /*userDevice*/ ctx[1].device_model && /*variantList*/ ctx[3].length > 0 && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select Model";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			option1 = element("option");
    			option1.textContent = "Others";
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.disabled = true;
    			option0.selected = true;
    			option0.hidden = true;
    			add_location(option0, file$9, 35, 5, 1477);
    			option1.__value = "Others";
    			option1.value = option1.__value;
    			add_location(option1, file$9, 39, 5, 1723);
    			attr_dev(select, "name", "model");
    			attr_dev(select, "class", "text-box select-box");
    			if (/*userDevice*/ ctx[1].device_model === void 0) add_render_callback(() => /*select_change_handler*/ ctx[7].call(select));
    			add_location(select, file$9, 34, 4, 1333);
    			attr_dev(div, "class", "form-group svelte-4fwqcc");
    			add_location(div, file$9, 33, 3, 1304);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select);
    			append_dev(select, option0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(select, option1);
    			select_option(select, /*userDevice*/ ctx[1].device_model);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[7]),
    					listen_dev(select, "change", /*change_handler*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Array, Set, devices, userDevice*/ 3) {
    				each_value_1 = Array.from(new Set(/*devices*/ ctx[0].filter(/*func_1*/ ctx[6]).map(func_2)));
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, option1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*userDevice, Array, Set, devices*/ 3) {
    				select_option(select, /*userDevice*/ ctx[1].device_model);
    			}

    			if (/*userDevice*/ ctx[1].device_model && /*variantList*/ ctx[3].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(33:2) {#if userDevice.device_brand && userDevice.device_brand != 'Others'}",
    		ctx
    	});

    	return block;
    }

    // (37:5) {#each Array.from(new Set(devices.filter(d => d.make == userDevice.device_brand).map(item => item.model))) as make}
    function create_each_block_1$1(ctx) {
    	let option;
    	let t_value = /*make*/ ctx[14] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*make*/ ctx[14];
    			option.value = option.__value;
    			add_location(option, file$9, 37, 6, 1668);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*devices, userDevice*/ 3 && t_value !== (t_value = /*make*/ ctx[14] + "")) set_data_dev(t, t_value);

    			if (dirty & /*devices, userDevice, Array, Set*/ 3 && option_value_value !== (option_value_value = /*make*/ ctx[14])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(37:5) {#each Array.from(new Set(devices.filter(d => d.make == userDevice.device_brand).map(item => item.model))) as make}",
    		ctx
    	});

    	return block;
    }

    // (43:3) {#if userDevice.device_model && variantList.length>0}
    function create_if_block_2(ctx) {
    	let div;
    	let select;
    	let mounted;
    	let dispose;
    	let each_value = /*variantList*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(select, "name", "variant");
    			attr_dev(select, "class", "text-box select-box");
    			if (/*userDevice*/ ctx[1].device_variant === void 0) add_render_callback(() => /*select_change_handler_1*/ ctx[9].call(select));
    			add_location(select, file$9, 44, 5, 1877);
    			attr_dev(div, "class", "form-group svelte-4fwqcc");
    			add_location(div, file$9, 43, 4, 1847);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*userDevice*/ ctx[1].device_variant);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler_1*/ ctx[9]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*variantList*/ 8) {
    				each_value = /*variantList*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*userDevice, Array, Set, devices*/ 3) {
    				select_option(select, /*userDevice*/ ctx[1].device_variant);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(43:3) {#if userDevice.device_model && variantList.length>0}",
    		ctx
    	});

    	return block;
    }

    // (46:6) {#each variantList as variant}
    function create_each_block$3(ctx) {
    	let option;
    	let t_value = /*variant*/ ctx[11] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*variant*/ ctx[11];
    			option.value = option.__value;
    			add_location(option, file$9, 46, 7, 2012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*variantList*/ 8 && t_value !== (t_value = /*variant*/ ctx[11] + "")) set_data_dev(t, t_value);

    			if (dirty & /*variantList*/ 8 && option_value_value !== (option_value_value = /*variant*/ ctx[11])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(46:6) {#each variantList as variant}",
    		ctx
    	});

    	return block;
    }

    // (22:0) <LoginLayout title={updatedUser.device_brand ? 'Successfully registered' : 'Your mobile device'} step={3}>
    function create_default_slot$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*updatedUser*/ ctx[2].device_brand) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(22:0) <LoginLayout title={updatedUser.device_brand ? 'Successfully registered' : 'Your mobile device'} step={3}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let loginlayout;
    	let current;

    	loginlayout = new Login$1({
    			props: {
    				title: /*updatedUser*/ ctx[2].device_brand
    				? 'Successfully registered'
    				: 'Your mobile device',
    				step: 3,
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loginlayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(loginlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const loginlayout_changes = {};

    			if (dirty & /*updatedUser*/ 4) loginlayout_changes.title = /*updatedUser*/ ctx[2].device_brand
    			? 'Successfully registered'
    			: 'Your mobile device';

    			if (dirty & /*$$scope, userDevice, variantList, devices, updatedUser*/ 131087) {
    				loginlayout_changes.$$scope = { dirty, ctx };
    			}

    			loginlayout.$set(loginlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loginlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = item => item.make;
    const func_2 = item => item.model;

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Device_Details', slots, []);
    	let devices = [];
    	fetch('/mobiles.json').then(r => r.json()).then(l => $$invalidate(0, devices = l));
    	let user = User.getInstance();

    	let userDevice = {
    		device_brand: null,
    		device_model: '',
    		device_variant: ''
    	};

    	let updatedUser = {};

    	const onSubmit = async e => {
    		e.preventDefault();
    		$$invalidate(2, updatedUser = await user.update(userDevice));
    	};

    	let variantList = [];
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Device_Details> was created with unknown prop '${key}'`);
    	});

    	const select_handler = e => {
    		$$invalidate(1, userDevice.device_brand = e.detail.value, userDevice);
    	};

    	const func_1 = d => d.make == userDevice.device_brand;

    	function select_change_handler() {
    		userDevice.device_model = select_value(this);
    		$$invalidate(1, userDevice);
    		$$invalidate(0, devices);
    	}

    	const change_handler = () => {
    		$$invalidate(1, userDevice.device_variant = '', userDevice);
    	};

    	function select_change_handler_1() {
    		userDevice.device_variant = select_value(this);
    		$$invalidate(1, userDevice);
    		$$invalidate(0, devices);
    	}

    	$$self.$capture_state = () => ({
    		LoginLayout: Login$1,
    		User,
    		SuccessfulRegistration: SuccessfulRegisterion,
    		Select,
    		devices,
    		user,
    		userDevice,
    		updatedUser,
    		onSubmit,
    		variantList
    	});

    	$$self.$inject_state = $$props => {
    		if ('devices' in $$props) $$invalidate(0, devices = $$props.devices);
    		if ('user' in $$props) user = $$props.user;
    		if ('userDevice' in $$props) $$invalidate(1, userDevice = $$props.userDevice);
    		if ('updatedUser' in $$props) $$invalidate(2, updatedUser = $$props.updatedUser);
    		if ('variantList' in $$props) $$invalidate(3, variantList = $$props.variantList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*userDevice, devices*/ 3) {
    			($$invalidate(3, variantList = userDevice.device_model == ''
    			? []
    			: Array.from(new Set(devices.filter(d => d.make == userDevice.device_brand && d.model == userDevice.device_model).map(item => item.Variant))).filter(i => i)));
    		}
    	};

    	return [
    		devices,
    		userDevice,
    		updatedUser,
    		variantList,
    		onSubmit,
    		select_handler,
    		func_1,
    		select_change_handler,
    		change_handler,
    		select_change_handler_1
    	];
    }

    class Device_Details extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Device_Details",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/pages/Support.svelte generated by Svelte v3.41.0 */
    const file$8 = "src/pages/Support.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (57:17) {#if section.active}
    function create_if_block$6(ctx) {
    	let div1;
    	let span;
    	let t0_value = /*section*/ ctx[7].question + "";
    	let t0;
    	let t1;
    	let img;
    	let img_src_value;
    	let t2;
    	let div0;
    	let raw_value = /*section*/ ctx[7].content + "";
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[4](/*section*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			img = element("img");
    			t2 = space();
    			div0 = element("div");
    			attr_dev(span, "class", "question svelte-1y5ke41");
    			add_location(span, file$8, 58, 16, 1705);
    			attr_dev(img, "class", "close-ans svelte-1y5ke41");
    			if (!src_url_equal(img.src, img_src_value = "images/minus.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "open");
    			add_location(img, file$8, 59, 24, 1778);
    			attr_dev(div0, "class", "content svelte-1y5ke41");
    			add_location(div0, file$8, 61, 16, 1910);
    			attr_dev(div1, "class", "slider svelte-1y5ke41");
    			add_location(div1, file$8, 57, 18, 1651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span);
    			append_dev(span, t0);
    			append_dev(div1, t1);
    			append_dev(div1, img);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(img, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*sections*/ 1) && t0_value !== (t0_value = /*section*/ ctx[7].question + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*sections*/ 1) && raw_value !== (raw_value = /*section*/ ctx[7].content + "")) div0.innerHTML = raw_value;		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide$1, {}, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide$1, {}, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(57:17) {#if section.active}",
    		ctx
    	});

    	return block;
    }

    // (48:12) {#each sections as section}
    function create_each_block$2(ctx) {
    	let div1;
    	let button;
    	let t0_value = /*section*/ ctx[7].title + "";
    	let t0;
    	let t1;
    	let div0;
    	let img;
    	let img_src_value;
    	let button_class_value;
    	let t2;
    	let t3;
    	let hr;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*section*/ ctx[7]);
    	}

    	let if_block = /*section*/ ctx[7].active && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			button = element("button");
    			t0 = text$1(t0_value);
    			t1 = space();
    			div0 = element("div");
    			img = element("img");
    			t2 = space();
    			if (if_block) if_block.c();
    			t3 = space();
    			hr = element("hr");
    			attr_dev(img, "class", "open-ans svelte-1y5ke41");
    			if (!src_url_equal(img.src, img_src_value = "images/plus.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "open");
    			add_location(img, file$8, 53, 24, 1482);
    			attr_dev(div0, "class", "plus svelte-1y5ke41");
    			add_location(div0, file$8, 52, 20, 1439);
    			attr_dev(button, "class", button_class_value = "qus-txt " + /*section*/ ctx[7].id + " svelte-1y5ke41");
    			add_location(button, file$8, 49, 17, 1291);
    			attr_dev(div1, "class", "accordion svelte-1y5ke41");
    			add_location(div1, file$8, 48, 16, 1250);
    			add_location(hr, file$8, 65, 16, 2045);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(button, div0);
    			append_dev(div0, img);
    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, hr, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*sections*/ 1) && t0_value !== (t0_value = /*section*/ ctx[7].title + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*sections*/ 1 && button_class_value !== (button_class_value = "qus-txt " + /*section*/ ctx[7].id + " svelte-1y5ke41")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (/*section*/ ctx[7].active) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*sections*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(hr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(48:12) {#each sections as section}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let section;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	let each_value = /*sections*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			section = element("section");
    			t = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(section, "class", "main-section svelte-1y5ke41");
    			add_location(section, file$8, 42, 0, 1087);
    			attr_dev(div0, "class", "support-group svelte-1y5ke41");
    			add_location(div0, file$8, 46, 8, 1166);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$8, 45, 4, 1134);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sections, close, expand*/ 7) {
    				each_value = /*sections*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Support', slots, []);
    	let current = 'foo';
    	let visible = true;

    	let sections = [
    		{
    			id: 1,
    			title: "Question 1",
    			question: "FAQ-1",
    			content: "FAQ Explanation",
    			active: false
    		},
    		{
    			id: 2,
    			title: "Question 2",
    			question: "What is the timeline of the tournament?",
    			content: `<p> Certe, inquam, pertinax non existimant oportere nimium nos amice et ultimum bonorum, quod summum bonum sit voluptatem sequi nesciunt, neque disputatione, quam interrogare aut fugit,</p><p>• ultimum bonorum, quod summum bonum sit voluptatem sequi nesciunt, neque</p><p>• quam interrogare aut fugit, sed ut enim ipsam.</p>`,
    			active: false
    		}
    	];

    	const expand = section => {
    		$$invalidate(0, sections = sections.map(s => {
    			s.active = false;

    			if (s.id === section.id) {
    				s.active = true;
    			}

    			return s;
    		}));
    	};

    	const close = section => {
    		$$invalidate(0, sections = sections.map(s => {
    			if (s.id === section.id) {
    				s.active = false;
    			}

    			return s;
    		}));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Support> was created with unknown prop '${key}'`);
    	});

    	const click_handler = section => expand(section);
    	const click_handler_1 = section => close(section);

    	$$self.$capture_state = () => ({
    		slide: slide$1,
    		current,
    		visible,
    		sections,
    		expand,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('current' in $$props) current = $$props.current;
    		if ('visible' in $$props) visible = $$props.visible;
    		if ('sections' in $$props) $$invalidate(0, sections = $$props.sections);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sections, expand, close, click_handler, click_handler_1];
    }

    class Support extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Support",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/pages/users/In-game-qualifiers.svelte generated by Svelte v3.41.0 */

    const file$7 = "src/pages/users/In-game-qualifiers.svelte";

    function create_fragment$9(ctx) {
    	let section0;
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let section1;
    	let div3;
    	let div2;
    	let ul0;
    	let li0;
    	let a0;
    	let t3;
    	let li1;
    	let a1;
    	let t5;
    	let li2;
    	let a2;
    	let t7;
    	let li3;
    	let a3;
    	let t9;
    	let div20;
    	let div19;
    	let div5;
    	let a4;
    	let span0;
    	let t10;
    	let span1;
    	let t12;
    	let strong0;
    	let t14;
    	let ul1;
    	let li4;
    	let strong1;
    	let t16;
    	let span2;
    	let t18;
    	let li5;
    	let strong2;
    	let t20;
    	let span3;
    	let t22;
    	let li6;
    	let strong3;
    	let t24;
    	let span4;
    	let t26;
    	let div4;
    	let button;
    	let t28;
    	let div18;
    	let div9;
    	let div8;
    	let div7;
    	let div6;
    	let t30;
    	let h40;
    	let t32;
    	let p0;
    	let t34;
    	let div17;
    	let div13;
    	let div12;
    	let span5;
    	let t36;
    	let div10;
    	let t38;
    	let h41;
    	let t40;
    	let p1;
    	let t42;
    	let div11;
    	let a5;
    	let t43;
    	let span6;
    	let t45;
    	let div16;
    	let div15;
    	let span7;
    	let t47;
    	let div14;
    	let t49;
    	let h42;
    	let t51;
    	let p2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Dashboard";
    			t1 = space();
    			section1 = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Profile";
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Your Team";
    			t5 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "Schedule";
    			t7 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "Standings";
    			t9 = space();
    			div20 = element("div");
    			div19 = element("div");
    			div5 = element("div");
    			a4 = element("a");
    			span0 = element("span");
    			t10 = space();
    			span1 = element("span");
    			span1.textContent = "add_circle_outline";
    			t12 = space();
    			strong0 = element("strong");
    			strong0.textContent = "Add Profile Pic";
    			t14 = space();
    			ul1 = element("ul");
    			li4 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Name";
    			t16 = space();
    			span2 = element("span");
    			span2.textContent = "Victor Pacheco";
    			t18 = space();
    			li5 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Free Fire ID";
    			t20 = space();
    			span3 = element("span");
    			span3.textContent = "victor@qconquest.com";
    			t22 = space();
    			li6 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Mobile Number";
    			t24 = space();
    			span4 = element("span");
    			span4.textContent = "+91 9988776655";
    			t26 = space();
    			div4 = element("div");
    			button = element("button");
    			button.textContent = "Log Out";
    			t28 = space();
    			div18 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div6.textContent = "Congratulations. Your team Qualified for";
    			t30 = space();
    			h40 = element("h4");
    			h40.textContent = "In-game Qualifiers Stage";
    			t32 = space();
    			p0 = element("p");
    			p0.textContent = "Quid ex ea voluptate ponit, quod omnium philosophorum sententia tale debet esse, ut ratione neque disputatione, quam ostendis sed quia dolor sit numeranda nec segniorem ad modum, quaeso, interpretaris.";
    			t34 = space();
    			div17 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			span5 = element("span");
    			span5.textContent = "Schedule";
    			t36 = space();
    			div10 = element("div");
    			div10.textContent = "In-game Qualifiers";
    			t38 = space();
    			h41 = element("h4");
    			h41.textContent = "16-24 October 2020";
    			t40 = space();
    			p1 = element("p");
    			p1.textContent = "Play any number of matches with your team. Your top 10 scores will be considered.";
    			t42 = space();
    			div11 = element("div");
    			a5 = element("a");
    			t43 = text$1("See full schedule\n\t\t\t\t\t\t\t\t\t");
    			span6 = element("span");
    			span6.textContent = "keyboard_arrow_right";
    			t45 = space();
    			div16 = element("div");
    			div15 = element("div");
    			span7 = element("span");
    			span7.textContent = "Standings";
    			t47 = space();
    			div14 = element("div");
    			div14.textContent = "In-game Qualifiers";
    			t49 = space();
    			h42 = element("h4");
    			h42.textContent = "Ongoing…";
    			t51 = space();
    			p2 = element("p");
    			p2.textContent = "Check back on 26 October 2020 for results.";
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$7, 5, 3, 100);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$7, 4, 2, 71);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$7, 3, 1, 45);
    			attr_dev(section0, "class", "banner");
    			add_location(section0, file$7, 2, 0, 19);
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$7, 16, 5, 299);
    			attr_dev(li0, "class", "active");
    			add_location(li0, file$7, 15, 4, 274);
    			attr_dev(a1, "href", "/dayzeroplayer");
    			add_location(a1, file$7, 21, 5, 360);
    			add_location(li1, file$7, 20, 4, 350);
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$7, 26, 5, 436);
    			add_location(li2, file$7, 25, 4, 426);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$7, 31, 5, 498);
    			add_location(li3, file$7, 30, 4, 488);
    			add_location(ul0, file$7, 14, 3, 265);
    			attr_dev(div2, "class", "container");
    			add_location(div2, file$7, 13, 2, 238);
    			attr_dev(div3, "class", "profile-menu");
    			add_location(div3, file$7, 12, 1, 209);
    			attr_dev(span0, "class", "bg-icon");
    			add_location(span0, file$7, 42, 5, 707);
    			attr_dev(span1, "class", "material-icons");
    			add_location(span1, file$7, 43, 5, 742);
    			add_location(strong0, file$7, 46, 5, 815);
    			attr_dev(a4, "href", "#");
    			attr_dev(a4, "class", "upload-img");
    			add_location(a4, file$7, 41, 4, 670);
    			add_location(strong1, file$7, 54, 6, 1061);
    			add_location(span2, file$7, 57, 6, 1104);
    			add_location(li4, file$7, 51, 5, 904);
    			add_location(strong2, file$7, 62, 6, 1174);
    			add_location(span3, file$7, 65, 6, 1225);
    			add_location(li5, file$7, 61, 5, 1163);
    			add_location(strong3, file$7, 70, 6, 1301);
    			add_location(span4, file$7, 73, 6, 1353);
    			add_location(li6, file$7, 69, 5, 1290);
    			attr_dev(ul1, "class", "profil-info");
    			add_location(ul1, file$7, 50, 4, 874);
    			attr_dev(button, "class", "btn btn-primary plain-btn");
    			add_location(button, file$7, 79, 5, 1452);
    			attr_dev(div4, "class", "text-center");
    			add_location(div4, file$7, 78, 4, 1421);
    			attr_dev(div5, "class", "col-4 border-right text-center");
    			add_location(div5, file$7, 40, 3, 621);
    			attr_dev(div6, "class", "survey-txt text-color svelte-16n4n4h");
    			add_location(div6, file$7, 88, 7, 1671);
    			attr_dev(h40, "class", "");
    			add_location(h40, file$7, 91, 7, 1777);
    			attr_dev(p0, "class", "survey-info-txt");
    			add_location(p0, file$7, 94, 7, 1844);
    			attr_dev(div7, "class", "col-6");
    			add_location(div7, file$7, 87, 6, 1644);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$7, 86, 5, 1620);
    			attr_dev(div9, "class", "survey-block survey-bg");
    			add_location(div9, file$7, 85, 4, 1578);
    			attr_dev(span5, "class", "team-title text-color svelte-16n4n4h");
    			add_location(span5, file$7, 111, 7, 2421);
    			attr_dev(div10, "class", "survey-txt text-color svelte-16n4n4h");
    			add_location(div10, file$7, 114, 28, 2518);
    			attr_dev(h41, "class", "mt-2 svelte-16n4n4h");
    			add_location(h41, file$7, 117, 7, 2602);
    			attr_dev(p1, "class", "survey-info-txt text-color svelte-16n4n4h");
    			add_location(p1, file$7, 120, 7, 2667);
    			attr_dev(span6, "class", "material-icons");
    			add_location(span6, file$7, 126, 9, 2946);
    			attr_dev(a5, "href", "#");
    			attr_dev(a5, "class", "survey-link margin-zero");
    			add_location(a5, file$7, 124, 8, 2829);
    			add_location(div11, file$7, 123, 7, 2815);
    			attr_dev(div12, "class", "team-box svelte-16n4n4h");
    			add_location(div12, file$7, 110, 6, 2391);
    			attr_dev(div13, "class", "col-6");
    			add_location(div13, file$7, 109, 5, 2365);
    			attr_dev(span7, "class", "team-title text-color svelte-16n4n4h");
    			add_location(span7, file$7, 135, 7, 3147);
    			attr_dev(div14, "class", "survey-txt text-color svelte-16n4n4h");
    			add_location(div14, file$7, 138, 28, 3245);
    			attr_dev(h42, "class", "mt-2 svelte-16n4n4h");
    			add_location(h42, file$7, 141, 7, 3329);
    			attr_dev(p2, "class", "survey-info-txt text-color svelte-16n4n4h");
    			add_location(p2, file$7, 144, 7, 3384);
    			attr_dev(div15, "class", "team-box box-right svelte-16n4n4h");
    			add_location(div15, file$7, 134, 6, 3107);
    			attr_dev(div16, "class", "col-6");
    			add_location(div16, file$7, 133, 5, 3081);
    			attr_dev(div17, "class", "row");
    			add_location(div17, file$7, 108, 4, 2342);
    			attr_dev(div18, "class", "col-8 pl-50");
    			add_location(div18, file$7, 84, 3, 1548);
    			attr_dev(div19, "class", "row");
    			add_location(div19, file$7, 39, 2, 600);
    			attr_dev(div20, "class", "container");
    			add_location(div20, file$7, 38, 1, 574);
    			attr_dev(section1, "class", "main-content");
    			add_location(section1, file$7, 11, 0, 177);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div3);
    			append_dev(div3, div2);
    			append_dev(div2, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a0);
    			append_dev(ul0, t3);
    			append_dev(ul0, li1);
    			append_dev(li1, a1);
    			append_dev(ul0, t5);
    			append_dev(ul0, li2);
    			append_dev(li2, a2);
    			append_dev(ul0, t7);
    			append_dev(ul0, li3);
    			append_dev(li3, a3);
    			append_dev(section1, t9);
    			append_dev(section1, div20);
    			append_dev(div20, div19);
    			append_dev(div19, div5);
    			append_dev(div5, a4);
    			append_dev(a4, span0);
    			append_dev(a4, t10);
    			append_dev(a4, span1);
    			append_dev(a4, t12);
    			append_dev(a4, strong0);
    			append_dev(div5, t14);
    			append_dev(div5, ul1);
    			append_dev(ul1, li4);
    			append_dev(li4, strong1);
    			append_dev(li4, t16);
    			append_dev(li4, span2);
    			append_dev(ul1, t18);
    			append_dev(ul1, li5);
    			append_dev(li5, strong2);
    			append_dev(li5, t20);
    			append_dev(li5, span3);
    			append_dev(ul1, t22);
    			append_dev(ul1, li6);
    			append_dev(li6, strong3);
    			append_dev(li6, t24);
    			append_dev(li6, span4);
    			append_dev(div5, t26);
    			append_dev(div5, div4);
    			append_dev(div4, button);
    			append_dev(div19, t28);
    			append_dev(div19, div18);
    			append_dev(div18, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div7, t30);
    			append_dev(div7, h40);
    			append_dev(div7, t32);
    			append_dev(div7, p0);
    			append_dev(div18, t34);
    			append_dev(div18, div17);
    			append_dev(div17, div13);
    			append_dev(div13, div12);
    			append_dev(div12, span5);
    			append_dev(div12, t36);
    			append_dev(div12, div10);
    			append_dev(div12, t38);
    			append_dev(div12, h41);
    			append_dev(div12, t40);
    			append_dev(div12, p1);
    			append_dev(div12, t42);
    			append_dev(div12, div11);
    			append_dev(div11, a5);
    			append_dev(a5, t43);
    			append_dev(a5, span6);
    			append_dev(div17, t45);
    			append_dev(div17, div16);
    			append_dev(div16, div15);
    			append_dev(div15, span7);
    			append_dev(div15, t47);
    			append_dev(div15, div14);
    			append_dev(div15, t49);
    			append_dev(div15, h42);
    			append_dev(div15, t51);
    			append_dev(div15, p2);

    			if (!mounted) {
    				dispose = listen_dev(a5, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('In_game_qualifiers', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<In_game_qualifiers> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => showModal = true;
    	return [click_handler];
    }

    class In_game_qualifiers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "In_game_qualifiers",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/pages/users/User-dashboard-playoff.svelte generated by Svelte v3.41.0 */

    const file$6 = "src/pages/users/User-dashboard-playoff.svelte";

    function create_fragment$8(ctx) {
    	let section0;
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let section1;
    	let div3;
    	let div2;
    	let ul0;
    	let li0;
    	let a0;
    	let t3;
    	let li1;
    	let a1;
    	let t5;
    	let li2;
    	let a2;
    	let t7;
    	let li3;
    	let a3;
    	let t9;
    	let div21;
    	let div20;
    	let div5;
    	let a4;
    	let span0;
    	let t10;
    	let span1;
    	let t12;
    	let strong0;
    	let t14;
    	let ul1;
    	let li4;
    	let strong1;
    	let t16;
    	let span2;
    	let t18;
    	let li5;
    	let strong2;
    	let t20;
    	let span3;
    	let t22;
    	let li6;
    	let strong3;
    	let t24;
    	let span4;
    	let t26;
    	let div4;
    	let button;
    	let t28;
    	let div19;
    	let div9;
    	let div8;
    	let div7;
    	let div6;
    	let t30;
    	let h40;
    	let t32;
    	let p0;
    	let t34;
    	let div18;
    	let div13;
    	let div12;
    	let span5;
    	let t36;
    	let div10;
    	let t38;
    	let h41;
    	let t40;
    	let p1;
    	let t42;
    	let div11;
    	let a5;
    	let t43;
    	let span6;
    	let t45;
    	let div17;
    	let div16;
    	let span7;
    	let t47;
    	let div14;
    	let t49;
    	let h42;
    	let t51;
    	let p2;
    	let t53;
    	let div15;
    	let a6;
    	let t54;
    	let span8;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Dashboard";
    			t1 = space();
    			section1 = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Profile";
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			a1.textContent = "Your Team";
    			t5 = space();
    			li2 = element("li");
    			a2 = element("a");
    			a2.textContent = "Schedule";
    			t7 = space();
    			li3 = element("li");
    			a3 = element("a");
    			a3.textContent = "Standings";
    			t9 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div5 = element("div");
    			a4 = element("a");
    			span0 = element("span");
    			t10 = space();
    			span1 = element("span");
    			span1.textContent = "add_circle_outline";
    			t12 = space();
    			strong0 = element("strong");
    			strong0.textContent = "Add Profile Pic";
    			t14 = space();
    			ul1 = element("ul");
    			li4 = element("li");
    			strong1 = element("strong");
    			strong1.textContent = "Name";
    			t16 = space();
    			span2 = element("span");
    			span2.textContent = "Victor Pacheco";
    			t18 = space();
    			li5 = element("li");
    			strong2 = element("strong");
    			strong2.textContent = "Free Fire ID";
    			t20 = space();
    			span3 = element("span");
    			span3.textContent = "victor@qconquest.com";
    			t22 = space();
    			li6 = element("li");
    			strong3 = element("strong");
    			strong3.textContent = "Mobile Number";
    			t24 = space();
    			span4 = element("span");
    			span4.textContent = "+91 9988776655";
    			t26 = space();
    			div4 = element("div");
    			button = element("button");
    			button.textContent = "Log Out";
    			t28 = space();
    			div19 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div6.textContent = "Congratulations. Your team Qualified for";
    			t30 = space();
    			h40 = element("h4");
    			h40.textContent = "Playoffs Stage";
    			t32 = space();
    			p0 = element("p");
    			p0.textContent = "Quid ex ea voluptate ponit, quod omnium philosophorum sententia tale debet esse, ut ratione neque disputatione, quam ostendis sed quia dolor sit numeranda nec segniorem ad modum, quaeso, interpretaris.";
    			t34 = space();
    			div18 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			span5 = element("span");
    			span5.textContent = "Next Match";
    			t36 = space();
    			div10 = element("div");
    			div10.textContent = "Playoffs Stage";
    			t38 = space();
    			h41 = element("h4");
    			h41.textContent = "24 October 2020";
    			t40 = space();
    			p1 = element("p");
    			p1.textContent = "3 PM, Wednesday";
    			t42 = space();
    			div11 = element("div");
    			a5 = element("a");
    			t43 = text$1("See full schedule\n\t\t\t\t\t\t\t\t\t");
    			span6 = element("span");
    			span6.textContent = "keyboard_arrow_right";
    			t45 = space();
    			div17 = element("div");
    			div16 = element("div");
    			span7 = element("span");
    			span7.textContent = "Standings";
    			t47 = space();
    			div14 = element("div");
    			div14.textContent = "Playoffs Stage. Day 3";
    			t49 = space();
    			h42 = element("h4");
    			h42.textContent = "3rd Position";
    			t51 = space();
    			p2 = element("p");
    			p2.textContent = "Updated 12 hrs ago";
    			t53 = space();
    			div15 = element("div");
    			a6 = element("a");
    			t54 = text$1("See Leaderboard\n\t\t\t\t\t\t\t\t\t");
    			span8 = element("span");
    			span8.textContent = "keyboard_arrow_right";
    			attr_dev(h1, "class", "main-title");
    			add_location(h1, file$6, 5, 3, 100);
    			attr_dev(div0, "class", "text-center");
    			add_location(div0, file$6, 4, 2, 71);
    			attr_dev(div1, "class", "container");
    			add_location(div1, file$6, 3, 1, 45);
    			attr_dev(section0, "class", "banner");
    			add_location(section0, file$6, 2, 0, 19);
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$6, 16, 5, 299);
    			attr_dev(li0, "class", "active");
    			add_location(li0, file$6, 15, 4, 274);
    			attr_dev(a1, "href", "/dayzeroplayer");
    			add_location(a1, file$6, 21, 5, 360);
    			add_location(li1, file$6, 20, 4, 350);
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$6, 26, 5, 436);
    			add_location(li2, file$6, 25, 4, 426);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$6, 31, 5, 498);
    			add_location(li3, file$6, 30, 4, 488);
    			add_location(ul0, file$6, 14, 3, 265);
    			attr_dev(div2, "class", "container");
    			add_location(div2, file$6, 13, 2, 238);
    			attr_dev(div3, "class", "profile-menu");
    			add_location(div3, file$6, 12, 1, 209);
    			attr_dev(span0, "class", "bg-icon");
    			add_location(span0, file$6, 42, 5, 707);
    			attr_dev(span1, "class", "material-icons");
    			add_location(span1, file$6, 43, 5, 742);
    			add_location(strong0, file$6, 46, 5, 815);
    			attr_dev(a4, "href", "#");
    			attr_dev(a4, "class", "upload-img");
    			add_location(a4, file$6, 41, 4, 670);
    			add_location(strong1, file$6, 54, 6, 1061);
    			add_location(span2, file$6, 57, 6, 1104);
    			add_location(li4, file$6, 51, 5, 904);
    			add_location(strong2, file$6, 62, 6, 1174);
    			add_location(span3, file$6, 65, 6, 1225);
    			add_location(li5, file$6, 61, 5, 1163);
    			add_location(strong3, file$6, 70, 6, 1301);
    			add_location(span4, file$6, 73, 6, 1353);
    			add_location(li6, file$6, 69, 5, 1290);
    			attr_dev(ul1, "class", "profil-info");
    			add_location(ul1, file$6, 50, 4, 874);
    			attr_dev(button, "class", "btn btn-primary plain-btn");
    			add_location(button, file$6, 79, 5, 1452);
    			attr_dev(div4, "class", "text-center");
    			add_location(div4, file$6, 78, 4, 1421);
    			attr_dev(div5, "class", "col-4 border-right text-center");
    			add_location(div5, file$6, 40, 3, 621);
    			attr_dev(div6, "class", "survey-txt text-color svelte-16n4n4h");
    			add_location(div6, file$6, 88, 7, 1671);
    			attr_dev(h40, "class", "");
    			add_location(h40, file$6, 91, 7, 1777);
    			attr_dev(p0, "class", "survey-info-txt");
    			add_location(p0, file$6, 94, 7, 1834);
    			attr_dev(div7, "class", "col-6");
    			add_location(div7, file$6, 87, 6, 1644);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$6, 86, 5, 1620);
    			attr_dev(div9, "class", "survey-block survey-bg");
    			add_location(div9, file$6, 85, 4, 1578);
    			attr_dev(span5, "class", "team-title text-color svelte-16n4n4h");
    			add_location(span5, file$6, 111, 7, 2411);
    			attr_dev(div10, "class", "survey-txt text-color svelte-16n4n4h");
    			add_location(div10, file$6, 114, 28, 2510);
    			attr_dev(h41, "class", " svelte-16n4n4h");
    			add_location(h41, file$6, 117, 7, 2590);
    			attr_dev(p1, "class", "survey-info-txt text-color svelte-16n4n4h");
    			add_location(p1, file$6, 120, 7, 2648);
    			attr_dev(span6, "class", "material-icons");
    			add_location(span6, file$6, 126, 9, 2861);
    			attr_dev(a5, "href", "#");
    			attr_dev(a5, "class", "survey-link margin-zero");
    			add_location(a5, file$6, 124, 8, 2744);
    			add_location(div11, file$6, 123, 7, 2730);
    			attr_dev(div12, "class", "team-box svelte-16n4n4h");
    			add_location(div12, file$6, 110, 6, 2381);
    			attr_dev(div13, "class", "col-6");
    			add_location(div13, file$6, 109, 5, 2355);
    			attr_dev(span7, "class", "team-title text-color svelte-16n4n4h");
    			add_location(span7, file$6, 135, 7, 3062);
    			attr_dev(div14, "class", "survey-txt text-color svelte-16n4n4h");
    			add_location(div14, file$6, 138, 28, 3160);
    			attr_dev(h42, "class", " svelte-16n4n4h");
    			add_location(h42, file$6, 141, 7, 3247);
    			attr_dev(p2, "class", "survey-info-txt text-color svelte-16n4n4h");
    			add_location(p2, file$6, 144, 7, 3302);
    			attr_dev(span8, "class", "material-icons");
    			add_location(span8, file$6, 150, 9, 3501);
    			attr_dev(a6, "href", "#");
    			attr_dev(a6, "class", "survey-link margin-zero");
    			add_location(a6, file$6, 148, 8, 3422);
    			add_location(div15, file$6, 147, 28, 3408);
    			attr_dev(div16, "class", "team-box box-right svelte-16n4n4h");
    			add_location(div16, file$6, 134, 6, 3022);
    			attr_dev(div17, "class", "col-6");
    			add_location(div17, file$6, 133, 5, 2996);
    			attr_dev(div18, "class", "row");
    			add_location(div18, file$6, 108, 4, 2332);
    			attr_dev(div19, "class", "col-8 pl-50");
    			add_location(div19, file$6, 84, 3, 1548);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$6, 39, 2, 600);
    			attr_dev(div21, "class", "container");
    			add_location(div21, file$6, 38, 1, 574);
    			attr_dev(section1, "class", "main-content");
    			add_location(section1, file$6, 11, 0, 177);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div3);
    			append_dev(div3, div2);
    			append_dev(div2, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a0);
    			append_dev(ul0, t3);
    			append_dev(ul0, li1);
    			append_dev(li1, a1);
    			append_dev(ul0, t5);
    			append_dev(ul0, li2);
    			append_dev(li2, a2);
    			append_dev(ul0, t7);
    			append_dev(ul0, li3);
    			append_dev(li3, a3);
    			append_dev(section1, t9);
    			append_dev(section1, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div5);
    			append_dev(div5, a4);
    			append_dev(a4, span0);
    			append_dev(a4, t10);
    			append_dev(a4, span1);
    			append_dev(a4, t12);
    			append_dev(a4, strong0);
    			append_dev(div5, t14);
    			append_dev(div5, ul1);
    			append_dev(ul1, li4);
    			append_dev(li4, strong1);
    			append_dev(li4, t16);
    			append_dev(li4, span2);
    			append_dev(ul1, t18);
    			append_dev(ul1, li5);
    			append_dev(li5, strong2);
    			append_dev(li5, t20);
    			append_dev(li5, span3);
    			append_dev(ul1, t22);
    			append_dev(ul1, li6);
    			append_dev(li6, strong3);
    			append_dev(li6, t24);
    			append_dev(li6, span4);
    			append_dev(div5, t26);
    			append_dev(div5, div4);
    			append_dev(div4, button);
    			append_dev(div20, t28);
    			append_dev(div20, div19);
    			append_dev(div19, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div7, t30);
    			append_dev(div7, h40);
    			append_dev(div7, t32);
    			append_dev(div7, p0);
    			append_dev(div19, t34);
    			append_dev(div19, div18);
    			append_dev(div18, div13);
    			append_dev(div13, div12);
    			append_dev(div12, span5);
    			append_dev(div12, t36);
    			append_dev(div12, div10);
    			append_dev(div12, t38);
    			append_dev(div12, h41);
    			append_dev(div12, t40);
    			append_dev(div12, p1);
    			append_dev(div12, t42);
    			append_dev(div12, div11);
    			append_dev(div11, a5);
    			append_dev(a5, t43);
    			append_dev(a5, span6);
    			append_dev(div18, t45);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, span7);
    			append_dev(div16, t47);
    			append_dev(div16, div14);
    			append_dev(div16, t49);
    			append_dev(div16, h42);
    			append_dev(div16, t51);
    			append_dev(div16, p2);
    			append_dev(div16, t53);
    			append_dev(div16, div15);
    			append_dev(div15, a6);
    			append_dev(a6, t54);
    			append_dev(a6, span8);

    			if (!mounted) {
    				dispose = listen_dev(a5, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('User_dashboard_playoff', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<User_dashboard_playoff> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => showModal = true;
    	return [click_handler];
    }

    class User_dashboard_playoff extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User_dashboard_playoff",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      } else {
        return Array.from(arr);
      }
    } // Older browsers don't support event options, feature detect it.
    // Adopted and modified solution from Bohdan Didukh (2017)
    // https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi


    var hasPassiveEvents = false;

    if (typeof window !== 'undefined') {
      var passiveTestOptions = {
        get passive() {
          hasPassiveEvents = true;
          return undefined;
        }

      };
      window.addEventListener('testPassive', null, passiveTestOptions);
      window.removeEventListener('testPassive', null, passiveTestOptions);
    }

    var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);
    var locks = [];
    var documentListenerAdded = false;
    var initialClientY = -1;
    var previousBodyOverflowSetting = void 0;
    var previousBodyPaddingRight = void 0; // returns true if `el` should be allowed to receive touchmove events.

    var allowTouchMove = function allowTouchMove(el) {
      return locks.some(function (lock) {
        if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
          return true;
        }

        return false;
      });
    };

    var preventDefault = function preventDefault(rawEvent) {
      var e = rawEvent || window.event; // For the case whereby consumers adds a touchmove event listener to document.
      // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
      // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
      // the touchmove event on document will break.

      if (allowTouchMove(e.target)) {
        return true;
      } // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).


      if (e.touches.length > 1) return true;
      if (e.preventDefault) e.preventDefault();
      return false;
    };

    var setOverflowHidden = function setOverflowHidden(options) {
      // If previousBodyPaddingRight is already set, don't set it again.
      if (previousBodyPaddingRight === undefined) {
        var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;

        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

        if (_reserveScrollBarGap && scrollBarGap > 0) {
          previousBodyPaddingRight = document.body.style.paddingRight;
          document.body.style.paddingRight = scrollBarGap + 'px';
        }
      } // If previousBodyOverflowSetting is already set, don't set it again.


      if (previousBodyOverflowSetting === undefined) {
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
      }
    };

    var restoreOverflowSetting = function restoreOverflowSetting() {
      if (previousBodyPaddingRight !== undefined) {
        document.body.style.paddingRight = previousBodyPaddingRight; // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
        // can be set again.

        previousBodyPaddingRight = undefined;
      }

      if (previousBodyOverflowSetting !== undefined) {
        document.body.style.overflow = previousBodyOverflowSetting; // Restore previousBodyOverflowSetting to undefined
        // so setOverflowHidden knows it can be set again.

        previousBodyOverflowSetting = undefined;
      }
    }; // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions


    var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
      return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
    };

    var handleScroll = function handleScroll(event, targetElement) {
      var clientY = event.targetTouches[0].clientY - initialClientY;

      if (allowTouchMove(event.target)) {
        return false;
      }

      if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
        // element is at the top of its scroll.
        return preventDefault(event);
      }

      if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
        // element is at the bottom of its scroll.
        return preventDefault(event);
      }

      event.stopPropagation();
      return true;
    };

    var disableBodyScroll = function disableBodyScroll(targetElement, options) {
      // targetElement must be provided
      if (!targetElement) {
        // eslint-disable-next-line no-console
        console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
        return;
      } // disableBodyScroll must not have been called on this targetElement before


      if (locks.some(function (lock) {
        return lock.targetElement === targetElement;
      })) {
        return;
      }

      var lock = {
        targetElement: targetElement,
        options: options || {}
      };
      locks = [].concat(_toConsumableArray(locks), [lock]);

      if (isIosDevice) {
        targetElement.ontouchstart = function (event) {
          if (event.targetTouches.length === 1) {
            // detect single touch.
            initialClientY = event.targetTouches[0].clientY;
          }
        };

        targetElement.ontouchmove = function (event) {
          if (event.targetTouches.length === 1) {
            // detect single touch.
            handleScroll(event, targetElement);
          }
        };

        if (!documentListenerAdded) {
          document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? {
            passive: false
          } : undefined);
          documentListenerAdded = true;
        }
      } else {
        setOverflowHidden(options);
      }
    };
    var enableBodyScroll = function enableBodyScroll(targetElement) {
      if (!targetElement) {
        // eslint-disable-next-line no-console
        console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');
        return;
      }

      locks = locks.filter(function (lock) {
        return lock.targetElement !== targetElement;
      });

      if (isIosDevice) {
        targetElement.ontouchstart = null;
        targetElement.ontouchmove = null;

        if (documentListenerAdded && locks.length === 0) {
          document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {
            passive: false
          } : undefined);
          documentListenerAdded = false;
        }
      } else if (!locks.length) {
        restoreOverflowSetting();
      }
    };

    /* src/components/ModalRenderer.svelte generated by Svelte v3.41.0 */
    const file$5 = "src/components/ModalRenderer.svelte";

    // (11:0) {#if $Modal.component}
    function create_if_block_1$1(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let button;
    	let span;
    	let t2;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*$Modal*/ ctx[1].component;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			button = element("button");
    			span = element("span");
    			span.textContent = "highlight_off";
    			t2 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div0, "class", "modal-background svelte-tzyy0s");
    			add_location(div0, file$5, 11, 4, 268);
    			attr_dev(span, "class", "material-icons svelte-tzyy0s");
    			add_location(span, file$5, 14, 12, 507);
    			attr_dev(button, "class", "close-btn svelte-tzyy0s");
    			button.autofocus = true;
    			add_location(button, file$5, 13, 8, 427);
    			attr_dev(div1, "class", "svelte-modal");
    			attr_dev(div1, "role", "dialog");
    			attr_dev(div1, "aria-modal", "true");
    			add_location(div1, file$5, 12, 4, 360);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			/*div0_binding*/ ctx[2](div0);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, span);
    			append_dev(div1, t2);

    			if (switch_instance) {
    				mount_component(switch_instance, div1, null);
    			}

    			current = true;
    			button.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(button, "click", /*click_handler_1*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*$Modal*/ ctx[1].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div1, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			/*div0_binding*/ ctx[2](null);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(11:0) {#if $Modal.component}",
    		ctx
    	});

    	return block;
    }

    // (24:1) {#if $Modal.component}
    function create_if_block$5(ctx) {
    	let style;

    	const block = {
    		c: function create() {
    			style = element("style");
    			style.textContent = "body {\n\t\t\t\toverflow: hidden;\n\t\t\t}";
    			add_location(style, file$5, 24, 2, 777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, style, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(style);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(24:1) {#if $Modal.component}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$Modal*/ ctx[1].component && create_if_block_1$1(ctx);
    	let if_block1 = /*$Modal*/ ctx[1].component && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(document.head, null);
    			append_dev(document.head, if_block1_anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$Modal*/ ctx[1].component) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$Modal*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$Modal*/ ctx[1].component) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $Modal;
    	validate_store(Modal, 'Modal');
    	component_subscribe($$self, Modal, $$value => $$invalidate(1, $Modal = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModalRenderer', slots, []);
    	let modalBG;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModalRenderer> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			modalBG = $$value;
    			$$invalidate(0, modalBG);
    		});
    	}

    	const click_handler = () => Modal.close();
    	const click_handler_1 = () => Modal.close();

    	$$self.$capture_state = () => ({
    		Modal,
    		disableBodyScroll,
    		enableBodyScroll,
    		modalBG,
    		$Modal
    	});

    	$$self.$inject_state = $$props => {
    		if ('modalBG' in $$props) $$invalidate(0, modalBG = $$props.modalBG);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$Modal, modalBG*/ 3) {
    			if ($Modal.component) {
    				disableBodyScroll(modalBG);
    			} else {
    				enableBodyScroll(modalBG);
    			}
    		}
    	};

    	return [modalBG, $Modal, div0_binding, click_handler, click_handler_1];
    }

    class ModalRenderer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalRenderer",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/components/SaveInvite.svelte generated by Svelte v3.41.0 */

    function create_fragment$6(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SaveInvite', slots, []);
    	let { code } = $$props;
    	window.localStorage.setItem('inviteCode', code);
    	getHistory().push('/login');
    	const writable_props = ['code'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SaveInvite> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('code' in $$props) $$invalidate(0, code = $$props.code);
    	};

    	$$self.$capture_state = () => ({ getHistory, code });

    	$$self.$inject_state = $$props => {
    		if ('code' in $$props) $$invalidate(0, code = $$props.code);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [code];
    }

    class SaveInvite extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { code: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SaveInvite",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*code*/ ctx[0] === undefined && !('code' in props)) {
    			console.warn("<SaveInvite> was created without expected prop 'code'");
    		}
    	}

    	get code() {
    		throw new Error("<SaveInvite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set code(value) {
    		throw new Error("<SaveInvite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/DevTool.svelte generated by Svelte v3.41.0 */

    function create_fragment$5(ctx) {
    	let t0;
    	let t1_value = (window.localStorage.getItem('dev') ? 'On' : 'Off') + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1("Dev mode is ");
    			t1 = text$1(t1_value);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $path;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DevTool', slots, []);
    	const path = getHistory().currentPath;
    	validate_store(path, 'path');
    	component_subscribe($$self, path, value => $$invalidate(1, $path = value));

    	if ($path == '/devon') {
    		window.localStorage.setItem('dev', 'true');
    	} else {
    		window.localStorage.removeItem('dev');
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DevTool> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ getHistory, path, $path });
    	return [path];
    }

    class DevTool extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DevTool",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/pages/CompleteRegistration.svelte generated by Svelte v3.41.0 */
    const file$4 = "src/pages/CompleteRegistration.svelte";

    // (49:1) {:else}
    function create_else_block$2(ctx) {
    	let successfulregisterion;
    	let current;
    	successfulregisterion = new SuccessfulRegisterion({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(successfulregisterion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(successfulregisterion, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(successfulregisterion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(successfulregisterion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(successfulregisterion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(49:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:1) {#if !$userStore.accept_tnc}
    function create_if_block$4(ctx) {
    	let form;
    	let div0;
    	let p;
    	let t1;
    	let div1;
    	let input0;
    	let t2;
    	let label0;
    	let t4;
    	let div2;
    	let input1;
    	let t5;
    	let label1;
    	let t7;
    	let div3;
    	let input2;
    	let t8;
    	let label2;
    	let t9;
    	let a;
    	let t11;
    	let t12;
    	let div4;
    	let button;
    	let t13;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			form = element("form");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "To be eligible to participate in the tournament your Free Fire account should be a minimum of level 10. Please ensure the same before the end of registrations or else you would be ineligible to participate in the tournament.";
    			t1 = space();
    			div1 = element("div");
    			input0 = element("input");
    			t2 = space();
    			label0 = element("label");
    			label0.textContent = "I confirm that I am an Indian Resident and not residing in the states of Andhra Pradesh, Odisha, Sikkim, Assam and Nagaland.";
    			t4 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t5 = space();
    			label1 = element("label");
    			label1.textContent = "I confirm that I am 12 years of age or older.";
    			t7 = space();
    			div3 = element("div");
    			input2 = element("input");
    			t8 = space();
    			label2 = element("label");
    			t9 = text$1("I have read the ");
    			a = element("a");
    			a.textContent = "Rule book";
    			t11 = text$1(" and accept all the terms and conditions mentioned therein.");
    			t12 = space();
    			div4 = element("div");
    			button = element("button");
    			t13 = text$1("Complete registration");
    			add_location(p, file$4, 22, 4, 775);
    			attr_dev(div0, "class", "successful-reg-text");
    			add_location(div0, file$4, 21, 3, 737);
    			attr_dev(input0, "class", "form-check-input");
    			attr_dev(input0, "type", "checkbox");
    			attr_dev(input0, "id", "defaultCheck4");
    			add_location(input0, file$4, 27, 4, 1060);
    			attr_dev(label0, "class", "form-check-label");
    			attr_dev(label0, "for", "defaultCheck4");
    			add_location(label0, file$4, 28, 4, 1157);
    			attr_dev(div1, "class", "form-check");
    			add_location(div1, file$4, 26, 3, 1031);
    			attr_dev(input1, "class", "form-check-input");
    			attr_dev(input1, "type", "checkbox");
    			attr_dev(input1, "id", "defaultCheck1");
    			add_location(input1, file$4, 33, 4, 1395);
    			attr_dev(label1, "class", "form-check-label");
    			attr_dev(label1, "for", "defaultCheck1");
    			add_location(label1, file$4, 34, 4, 1490);
    			attr_dev(div2, "class", "form-check");
    			add_location(div2, file$4, 32, 3, 1366);
    			attr_dev(input2, "class", "form-check-input");
    			attr_dev(input2, "type", "checkbox");
    			attr_dev(input2, "id", "defaultCheck3");
    			add_location(input2, file$4, 39, 4, 1649);
    			attr_dev(a, "href", "#");
    			add_location(a, file$4, 41, 21, 1820);
    			attr_dev(label2, "class", "form-check-label");
    			attr_dev(label2, "for", "defaultCheck3");
    			add_location(label2, file$4, 40, 4, 1746);
    			attr_dev(div3, "class", "form-check");
    			add_location(div3, file$4, 38, 3, 1620);
    			attr_dev(button, "href", "#");
    			attr_dev(button, "class", "btn btn-primary verify-btn");
    			button.disabled = /*disableSubmit*/ ctx[1];
    			add_location(button, file$4, 45, 4, 1961);
    			attr_dev(div4, "class", "btn-section");
    			add_location(div4, file$4, 44, 3, 1931);
    			add_location(form, file$4, 20, 2, 727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, p);
    			append_dev(form, t1);
    			append_dev(form, div1);
    			append_dev(div1, input0);
    			input0.checked = /*tnc*/ ctx[0].state;
    			append_dev(div1, t2);
    			append_dev(div1, label0);
    			append_dev(form, t4);
    			append_dev(form, div2);
    			append_dev(div2, input1);
    			input1.checked = /*tnc*/ ctx[0].age;
    			append_dev(div2, t5);
    			append_dev(div2, label1);
    			append_dev(form, t7);
    			append_dev(form, div3);
    			append_dev(div3, input2);
    			input2.checked = /*tnc*/ ctx[0].rules;
    			append_dev(div3, t8);
    			append_dev(div3, label2);
    			append_dev(label2, t9);
    			append_dev(label2, a);
    			append_dev(label2, t11);
    			append_dev(form, t12);
    			append_dev(form, div4);
    			append_dev(div4, button);
    			append_dev(button, t13);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[5]),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[6]),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[7]),
    					listen_dev(button, "click", prevent_default(/*onSubmit*/ ctx[4]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tnc*/ 1) {
    				input0.checked = /*tnc*/ ctx[0].state;
    			}

    			if (dirty & /*tnc*/ 1) {
    				input1.checked = /*tnc*/ ctx[0].age;
    			}

    			if (dirty & /*tnc*/ 1) {
    				input2.checked = /*tnc*/ ctx[0].rules;
    			}

    			if (dirty & /*disableSubmit*/ 2) {
    				prop_dev(button, "disabled", /*disableSubmit*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(20:1) {#if !$userStore.accept_tnc}",
    		ctx
    	});

    	return block;
    }

    // (19:0) <LoginLayout title={$userStore.accept_tnc ? 'Registration successful' : 'Final Step'} step={$userStore.accept_tnc ? '' : '4'}>
    function create_default_slot$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*$userStore*/ ctx[2].accept_tnc) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(19:0) <LoginLayout title={$userStore.accept_tnc ? 'Registration successful' : 'Final Step'} step={$userStore.accept_tnc ? '' : '4'}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let loginlayout;
    	let current;

    	loginlayout = new Login$1({
    			props: {
    				title: /*$userStore*/ ctx[2].accept_tnc
    				? 'Registration successful'
    				: 'Final Step',
    				step: /*$userStore*/ ctx[2].accept_tnc ? '' : '4',
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(loginlayout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(loginlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const loginlayout_changes = {};

    			if (dirty & /*$userStore*/ 4) loginlayout_changes.title = /*$userStore*/ ctx[2].accept_tnc
    			? 'Registration successful'
    			: 'Final Step';

    			if (dirty & /*$userStore*/ 4) loginlayout_changes.step = /*$userStore*/ ctx[2].accept_tnc ? '' : '4';

    			if (dirty & /*$$scope, disableSubmit, tnc, $userStore*/ 1031) {
    				loginlayout_changes.$$scope = { dirty, ctx };
    			}

    			loginlayout.$set(loginlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loginlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $userStore;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CompleteRegistration', slots, []);
    	const user = User.getInstance();
    	const userStore = User.getUser();
    	validate_store(userStore, 'userStore');
    	component_subscribe($$self, userStore, value => $$invalidate(2, $userStore = value));
    	let updatedUser = {};
    	user.successfulRegisterion = false;

    	const onSubmit = async e => {
    		updatedUser = await user.update({ accept_tnc: true });
    	};

    	let tnc = {
    		age: false,
    		tnc: false,
    		rules: false,
    		state: false
    	};

    	let disableSubmit = true;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CompleteRegistration> was created with unknown prop '${key}'`);
    	});

    	function input0_change_handler() {
    		tnc.state = this.checked;
    		$$invalidate(0, tnc);
    	}

    	function input1_change_handler() {
    		tnc.age = this.checked;
    		$$invalidate(0, tnc);
    	}

    	function input2_change_handler() {
    		tnc.rules = this.checked;
    		$$invalidate(0, tnc);
    	}

    	$$self.$capture_state = () => ({
    		LoginLayout: Login$1,
    		User,
    		SuccessfulRegisterion,
    		user,
    		userStore,
    		updatedUser,
    		onSubmit,
    		tnc,
    		disableSubmit,
    		$userStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('updatedUser' in $$props) updatedUser = $$props.updatedUser;
    		if ('tnc' in $$props) $$invalidate(0, tnc = $$props.tnc);
    		if ('disableSubmit' in $$props) $$invalidate(1, disableSubmit = $$props.disableSubmit);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*tnc*/ 1) {
    			(() => {
    				$$invalidate(1, disableSubmit = !(tnc.state && tnc.age && tnc.rules));
    			})();
    		}
    	};

    	return [
    		tnc,
    		disableSubmit,
    		$userStore,
    		userStore,
    		onSubmit,
    		input0_change_handler,
    		input1_change_handler,
    		input2_change_handler
    	];
    }

    class CompleteRegistration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CompleteRegistration",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/pages/Stats.svelte generated by Svelte v3.41.0 */
    const file$3 = "src/pages/Stats.svelte";

    // (80:0) {#if isDownloading}
    function create_if_block$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Downloading...";
    			attr_dev(div, "class", "downloading d-flex align-items-center flex-column justify-content-center h-100 w-100 svelte-10cd6h1");
    			add_location(div, file$3, 80, 0, 3821);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(80:0) {#if isDownloading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div2;
    	let div0;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let button;
    	let t3;
    	let button_disabled_value;
    	let t4;
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let if_block = /*isDownloading*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			label = element("label");
    			label.textContent = "Match ID";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			button = element("button");
    			t3 = text$1("Download");
    			t4 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(label, "class", "form-label");
    			attr_dev(label, "for", "");
    			add_location(label, file$3, 72, 8, 3471);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "form-control");
    			add_location(input, file$3, 73, 8, 3530);
    			attr_dev(div0, "class", "form-group");
    			add_location(div0, file$3, 71, 4, 3438);
    			attr_dev(button, "class", "btn btn-primary");
    			button.disabled = button_disabled_value = !/*matchID*/ ctx[1] || /*matchID*/ ctx[1] && /*matchID*/ ctx[1].length == 0;
    			add_location(button, file$3, 76, 8, 3641);
    			attr_dev(div1, "class", "form-group");
    			add_location(div1, file$3, 75, 4, 3608);
    			attr_dev(div2, "class", "conainer");
    			add_location(div2, file$3, 70, 0, 3411);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, label);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			set_input_value(input, /*matchID*/ ctx[1]);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, button);
    			append_dev(button, t3);
    			insert_dev(target, t4, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[3]),
    					listen_dev(button, "click", prevent_default(/*onDownload*/ ctx[2]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*matchID*/ 2 && input.value !== /*matchID*/ ctx[1]) {
    				set_input_value(input, /*matchID*/ ctx[1]);
    			}

    			if (dirty & /*matchID*/ 2 && button_disabled_value !== (button_disabled_value = !/*matchID*/ ctx[1] || /*matchID*/ ctx[1] && /*matchID*/ ctx[1].length == 0)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (/*isDownloading*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t4);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Stats', slots, []);
    	let lastUpdated = new Date();

    	const time = readable(new Date(), function start(set) {
    		const interval = setInterval(
    			() => {
    				set(new Date());
    			},
    			1000
    		);

    		return function stop() {
    			clearInterval(interval);
    		};
    	});

    	const elapsed = derived(time, $time => Math.round(($time - lastUpdated) / 1000));
    	let team = Team.getInstance();
    	let stats = [];
    	let autorefresh = false;

    	const getStats = async () => {
    		stats = await team.getStats();
    		lastUpdated = new Date();

    		if (autorefresh) {
    			setTimeout(getStats, 5 * 60 * 1000);
    		}
    	};

    	let isDownloading = false;

    	const onExport = async () => {
    		$$invalidate(0, isDownloading = true);
    		await team.export();
    		$$invalidate(0, isDownloading = false);
    	};

    	let matchID;

    	const onDownload = async () => {
    		if (matchID) {
    			$$invalidate(0, isDownloading = true);
    			await team.downloadMatch(matchID);
    			$$invalidate(0, isDownloading = false);
    			$$invalidate(1, matchID = '');
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Stats> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		matchID = this.value;
    		$$invalidate(1, matchID);
    	}

    	$$self.$capture_state = () => ({
    		Team,
    		Switch,
    		moment,
    		readable,
    		derived,
    		lastUpdated,
    		time,
    		elapsed,
    		team,
    		stats,
    		autorefresh,
    		getStats,
    		isDownloading,
    		onExport,
    		matchID,
    		onDownload
    	});

    	$$self.$inject_state = $$props => {
    		if ('lastUpdated' in $$props) lastUpdated = $$props.lastUpdated;
    		if ('team' in $$props) team = $$props.team;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('autorefresh' in $$props) autorefresh = $$props.autorefresh;
    		if ('isDownloading' in $$props) $$invalidate(0, isDownloading = $$props.isDownloading);
    		if ('matchID' in $$props) $$invalidate(1, matchID = $$props.matchID);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isDownloading, matchID, onDownload, input_input_handler];
    }

    class Stats extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Stats",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/components/PointsTable.svelte generated by Svelte v3.41.0 */

    const { console: console_1$1 } = globals;
    const file$2 = "src/components/PointsTable.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (242:4) {:else}
    function create_else_block$1(ctx) {
    	let h3;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Leaderboard not yet available";
    			add_location(h3, file$2, 242, 8, 9265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(242:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (203:4) {#if scores.length > 0}
    function create_if_block$2(ctx) {
    	let div0;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let t10;
    	let div1;
    	let button0;
    	let span0;
    	let t12;
    	let t13;
    	let button1;
    	let t14;
    	let span1;
    	let mounted;
    	let dispose;
    	let each_value = /*currentPageRows*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Rank";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Team Name";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Place Pts";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Total Kills";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Total Pts";
    			t9 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t10 = space();
    			div1 = element("div");
    			button0 = element("button");
    			span0 = element("span");
    			span0.textContent = "chevron_left";
    			t12 = text$1("Previous");
    			t13 = space();
    			button1 = element("button");
    			t14 = text$1("Next");
    			span1 = element("span");
    			span1.textContent = "chevron_right";
    			attr_dev(th0, "scope", "col");
    			attr_dev(th0, "class", "text-center svelte-1ct8zf2");
    			add_location(th0, file$2, 207, 24, 7385);
    			attr_dev(th1, "scope", "col");
    			attr_dev(th1, "class", "svelte-1ct8zf2");
    			add_location(th1, file$2, 208, 24, 7455);
    			attr_dev(th2, "scope", "col");
    			attr_dev(th2, "class", "text-center svelte-1ct8zf2");
    			add_location(th2, file$2, 210, 24, 7586);
    			attr_dev(th3, "scope", "col");
    			attr_dev(th3, "class", "text-center svelte-1ct8zf2");
    			add_location(th3, file$2, 211, 24, 7661);
    			attr_dev(th4, "scope", "col");
    			attr_dev(th4, "class", "text-center svelte-1ct8zf2");
    			add_location(th4, file$2, 213, 24, 7804);
    			add_location(tr, file$2, 206, 20, 7356);
    			add_location(thead, file$2, 205, 16, 7328);
    			add_location(tbody, file$2, 216, 16, 7922);
    			attr_dev(table, "class", "table svelte-1ct8zf2");
    			add_location(table, file$2, 204, 12, 7290);
    			attr_dev(div0, "class", "table-section container svelte-1ct8zf2");
    			add_location(div0, file$2, 203, 8, 7240);
    			attr_dev(span0, "class", "material-icons");
    			add_location(span0, file$2, 237, 19, 8979);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn-next-prev svelte-1ct8zf2");
    			toggle_class(button0, "active", /*page*/ ctx[0] !== 0);
    			add_location(button0, file$2, 234, 12, 8803);
    			attr_dev(span1, "class", "material-icons");
    			add_location(span1, file$2, 238, 121, 9166);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn-next-prev svelte-1ct8zf2");
    			toggle_class(button1, "active", /*page*/ ctx[0] !== 1);
    			add_location(button1, file$2, 238, 12, 9057);
    			attr_dev(div1, "class", "next-prev-btns d-flex justify-content-md-end");
    			add_location(div1, file$2, 233, 8, 8732);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(table, t9);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			insert_dev(target, t10, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button0);
    			append_dev(button0, span0);
    			append_dev(button0, t12);
    			append_dev(div1, t13);
    			append_dev(div1, button1);
    			append_dev(button1, t14);
    			append_dev(button1, span1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentPageRows*/ 2) {
    				each_value = /*currentPageRows*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*page*/ 1) {
    				toggle_class(button0, "active", /*page*/ ctx[0] !== 0);
    			}

    			if (dirty & /*page*/ 1) {
    				toggle_class(button1, "active", /*page*/ ctx[0] !== 1);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(203:4) {#if scores.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (218:20) {#each currentPageRows as score}
    function create_each_block$1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*score*/ ctx[14]["Rank"] + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*score*/ ctx[14]["Team Name"] + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*score*/ ctx[14]["Position Points"] + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*score*/ ctx[14]["Kills"] + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*score*/ ctx[14]["Overall Points"] + "";
    	let t8;
    	let t9;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			attr_dev(td0, "class", "text-center svelte-1ct8zf2");
    			add_location(td0, file$2, 219, 28, 8040);
    			attr_dev(td1, "class", "svelte-1ct8zf2");
    			add_location(td1, file$2, 220, 28, 8113);
    			attr_dev(td2, "class", "text-center svelte-1ct8zf2");
    			add_location(td2, file$2, 222, 28, 8250);
    			attr_dev(td3, "class", "text-center svelte-1ct8zf2");
    			add_location(td3, file$2, 223, 28, 8334);
    			attr_dev(td4, "class", "cell-value text-center svelte-1ct8zf2");
    			add_location(td4, file$2, 225, 28, 8477);
    			add_location(tr, file$2, 218, 24, 8007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentPageRows*/ 2 && t0_value !== (t0_value = /*score*/ ctx[14]["Rank"] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*currentPageRows*/ 2 && t2_value !== (t2_value = /*score*/ ctx[14]["Team Name"] + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*currentPageRows*/ 2 && t4_value !== (t4_value = /*score*/ ctx[14]["Position Points"] + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*currentPageRows*/ 2 && t6_value !== (t6_value = /*score*/ ctx[14]["Kills"] + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*currentPageRows*/ 2 && t8_value !== (t8_value = /*score*/ ctx[14]["Overall Points"] + "")) set_data_dev(t8, t8_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(218:20) {#each currentPageRows as score}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div0;
    	let h2;
    	let t1;
    	let h4;
    	let t2_value = /*leaderboard*/ ctx[4].title + "";
    	let t2;
    	let t3;
    	let div1;

    	function select_block_type(ctx, dirty) {
    		if (/*scores*/ ctx[3].length > 0) return create_if_block$2;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Overall Point Standings";
    			t1 = space();
    			h4 = element("h4");
    			t2 = text$1(t2_value);
    			t3 = space();
    			div1 = element("div");
    			if_block.c();
    			attr_dev(h2, "class", "overal-points-title svelte-1ct8zf2");
    			add_location(h2, file$2, 197, 4, 7048);
    			attr_dev(h4, "class", "table-title svelte-1ct8zf2");
    			add_location(h4, file$2, 198, 4, 7113);
    			attr_dev(div0, "class", "points-table-title-area");
    			add_location(div0, file$2, 196, 0, 7006);
    			attr_dev(div1, "class", "overal-points-table svelte-1ct8zf2");
    			add_location(div1, file$2, 201, 0, 7170);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h2);
    			append_dev(div0, t1);
    			append_dev(div0, h4);
    			append_dev(h4, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			if_block.m(div1, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*leaderboard*/ 16 && t2_value !== (t2_value = /*leaderboard*/ ctx[4].title + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PointsTable', slots, []);
    	let rows = [];
    	let page = 0;
    	let totalPages = [];
    	let currentPageRows = [];
    	let itemsPerPage = 12;
    	let loading = true;
    	let activebtn;

    	const paginate = items => {
    		const pages = Math.ceil(items.length / itemsPerPage);

    		const paginatedItems = Array.from({ length: pages }, (_, index) => {
    			const start = index * itemsPerPage;
    			return items.slice(start, start + itemsPerPage);
    		});

    		//console.log("paginatedItems are", paginatedItems);
    		$$invalidate(6, totalPages = [...paginatedItems]);
    	};

    	onMount(() => {
    		paginate(scores);
    	});

    	const setPage = p => {
    		if (p >= 0 && p < totalPages.length) {
    			$$invalidate(0, page = p);
    		}
    	};

    	let scores = [];

    	let leaderboard = {
    		data: [
    			{
    				id: 1,
    				status: "published",
    				owner: 1,
    				created_on: "2021-01-27T20:13:38+00:00",
    				modified_by: 2,
    				modified_on: "2021-03-15T10:36:08+00:00",
    				scores: [
    					{
    						Rank: 1,
    						"Team Name": "4 Unknown",
    						"No. of matches played": 12,
    						Kills: 70,
    						"Kill Points": 140,
    						"Position Points": 167,
    						"Overall Points": 307
    					},
    					{
    						Rank: 2,
    						"Team Name": "Team Elite",
    						"No. of matches played": 12,
    						Kills: 55,
    						"Kill Points": 110,
    						"Position Points": 151,
    						"Overall Points": 261
    					},
    					{
    						Rank: 3,
    						"Team Name": "LIFE HACKERS",
    						"No. of matches played": 12,
    						Kills: 50,
    						"Kill Points": 100,
    						"Position Points": 129,
    						"Overall Points": 229
    					},
    					{
    						Rank: 4,
    						"Team Name": "Team Chaos",
    						"No. of matches played": 12,
    						Kills: 52,
    						"Kill Points": 104,
    						"Position Points": 125,
    						"Overall Points": 229
    					},
    					{
    						Rank: 5,
    						"Team Name": "Hex Esports",
    						"No. of matches played": 12,
    						Kills: 33,
    						"Kill Points": 66,
    						"Position Points": 122,
    						"Overall Points": 188
    					},
    					{
    						Rank: 6,
    						"Team Name": "TEAM MAYHEM",
    						"No. of matches played": 12,
    						Kills: 35,
    						"Kill Points": 70,
    						"Position Points": 117,
    						"Overall Points": 187
    					},
    					{
    						Rank: 7,
    						"Team Name": "Galaxy Racer",
    						"No. of matches played": 12,
    						Kills: 42,
    						"Kill Points": 84,
    						"Position Points": 98,
    						"Overall Points": 182
    					},
    					{
    						Rank: 8,
    						"Team Name": "Sixth Sense",
    						"No. of matches played": 12,
    						Kills: 39,
    						"Kill Points": 78,
    						"Position Points": 82,
    						"Overall Points": 160
    					},
    					{
    						Rank: 9,
    						"Team Name": "Total Gaming Esports",
    						"No. of matches played": 12,
    						Kills: 31,
    						"Kill Points": 62,
    						"Position Points": 96,
    						"Overall Points": 158
    					},
    					{
    						Rank: 10,
    						"Team Name": "survivior-4am",
    						"No. of matches played": 12,
    						Kills: 27,
    						"Kill Points": 54,
    						"Position Points": 87,
    						"Overall Points": 141
    					},
    					{
    						Rank: 11,
    						"Team Name": "Blood bashers",
    						"No. of matches played": 12,
    						Kills: 23,
    						"Kill Points": 46,
    						"Position Points": 87,
    						"Overall Points": 133
    					},
    					{
    						Rank: 12,
    						"Team Name": "Raven esports",
    						"No. of matches played": 12,
    						Kills: 26,
    						"Kill Points": 52,
    						"Position Points": 71,
    						"Overall Points": 123
    					},
    					{
    						Rank: 13,
    						"Team Name": "Raven esports",
    						"No. of matches played": 12,
    						Kills: 26,
    						"Kill Points": 52,
    						"Position Points": 71,
    						"Overall Points": 123
    					},
    					{
    						Rank: 14,
    						"Team Name": "Raven esports",
    						"No. of matches played": 12,
    						Kills: 26,
    						"Kill Points": 52,
    						"Position Points": 71,
    						"Overall Points": 123
    					},
    					{
    						Rank: 15,
    						"Team Name": "Raven esports",
    						"No. of matches played": 12,
    						Kills: 26,
    						"Kill Points": 52,
    						"Position Points": 71,
    						"Overall Points": 123
    					}
    				],
    				xlsx: 104,
    				title: "Grand Finals, End of Day 2"
    			}
    		],
    		public: true
    	};

    	// fetch('https://qsdc.tesseractesports.com/conquest/items/leaderboard').then(async res => {
    	let data = leaderboard;

    	data = data.data[0];
    	leaderboard = data;

    	if (data.status == "published") {
    		scores = data.scores.sort((a, b) => a.Rank < b.Rank);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<PointsTable> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		setPage(page - 1);
    		$$invalidate(2, activebtn = true);
    	};

    	const click_handler_1 = () => setPage(page + 1);

    	$$self.$capture_state = () => ({
    		onMount,
    		rows,
    		page,
    		totalPages,
    		currentPageRows,
    		itemsPerPage,
    		loading,
    		activebtn,
    		paginate,
    		setPage,
    		scores,
    		leaderboard,
    		data
    	});

    	$$self.$inject_state = $$props => {
    		if ('rows' in $$props) rows = $$props.rows;
    		if ('page' in $$props) $$invalidate(0, page = $$props.page);
    		if ('totalPages' in $$props) $$invalidate(6, totalPages = $$props.totalPages);
    		if ('currentPageRows' in $$props) $$invalidate(1, currentPageRows = $$props.currentPageRows);
    		if ('itemsPerPage' in $$props) itemsPerPage = $$props.itemsPerPage;
    		if ('loading' in $$props) loading = $$props.loading;
    		if ('activebtn' in $$props) $$invalidate(2, activebtn = $$props.activebtn);
    		if ('scores' in $$props) $$invalidate(3, scores = $$props.scores);
    		if ('leaderboard' in $$props) $$invalidate(4, leaderboard = $$props.leaderboard);
    		if ('data' in $$props) data = $$props.data;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*totalPages, page*/ 65) {
    			$$invalidate(1, currentPageRows = totalPages.length > 0 ? totalPages[page] : []);
    		}

    		if ($$self.$$.dirty & /*page*/ 1) {
    			console.log("Page is", page);
    		}
    	};

    	return [
    		page,
    		currentPageRows,
    		activebtn,
    		scores,
    		leaderboard,
    		setPage,
    		totalPages,
    		click_handler,
    		click_handler_1
    	];
    }

    class PointsTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PointsTable",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    function is_date(obj) {
      return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
      if (a === b || a !== a) return () => a;
      const type = typeof a;

      if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
      }

      if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
          return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
      }

      if (type === 'object') {
        if (!a || !b) throw new Error('Object cannot be null');

        if (is_date(a) && is_date(b)) {
          a = a.getTime();
          b = b.getTime();
          const delta = b - a;
          return t => new Date(a + t * delta);
        }

        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
          interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
          const result = {};
          keys.forEach(key => {
            result[key] = interpolators[key](t);
          });
          return result;
        };
      }

      if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
      }

      throw new Error(`Cannot interpolate ${type} values`);
    }

    function tweened(value, defaults = {}) {
      const store = writable(value);
      let task;
      let target_value = value;

      function set(new_value, opts) {
        if (value == null) {
          store.set(value = new_value);
          return Promise.resolve();
        }

        target_value = new_value;
        let previous_task = task;
        let started = false;
        let {
          delay = 0,
          duration = 400,
          easing = identity$2,
          interpolate = get_interpolator
        } = assign(assign({}, defaults), opts);

        if (duration === 0) {
          if (previous_task) {
            previous_task.abort();
            previous_task = null;
          }

          store.set(value = target_value);
          return Promise.resolve();
        }

        const start = now$1() + delay;
        let fn;
        task = loop$1(now => {
          if (now < start) return true;

          if (!started) {
            fn = interpolate(value, new_value);
            if (typeof duration === 'function') duration = duration(value, new_value);
            started = true;
          }

          if (previous_task) {
            previous_task.abort();
            previous_task = null;
          }

          const elapsed = now - start;

          if (elapsed > duration) {
            store.set(value = new_value);
            return false;
          } // @ts-ignore


          store.set(value = fn(easing(elapsed / duration)));
          return true;
        });
        return task.promise;
      }

      return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
      };
    }

    /* src/pages/TeamsAndStandings.svelte generated by Svelte v3.41.0 */

    const { console: console_1 } = globals;
    const file$1 = "src/pages/TeamsAndStandings.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (806:9) {#each teams.filter(t => t.group == selectedGroup) as team}
    function create_each_block_1(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_4(...args) {
    		return /*click_handler_4*/ ctx[11](/*team*/ ctx[19], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t = space();
    			if (!src_url_equal(img.src, img_src_value = "images/teamLogos/" + /*team*/ ctx[19].logo)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$1, 811, 11, 22323);
    			attr_dev(div, "class", "logo-click-card svelte-1yvyzy0");
    			toggle_class(div, "active", /*selectedTeam*/ ctx[2] == /*team*/ ctx[19].name);
    			add_location(div, file$1, 806, 10, 22134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", prevent_default(click_handler_4), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*selectedGroup*/ 1 && !src_url_equal(img.src, img_src_value = "images/teamLogos/" + /*team*/ ctx[19].logo)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*selectedTeam, teams, selectedGroup*/ 37) {
    				toggle_class(div, "active", /*selectedTeam*/ ctx[2] == /*team*/ ctx[19].name);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(806:9) {#each teams.filter(t => t.group == selectedGroup) as team}",
    		ctx
    	});

    	return block;
    }

    // (819:9) {#if selectedTeam}
    function create_if_block$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*teams*/ ctx[5].find(/*func_1*/ ctx[14]).players;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*teams, selectedTeam*/ 36) {
    				each_value = /*teams*/ ctx[5].find(/*func_1*/ ctx[14]).players;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(819:9) {#if selectedTeam}",
    		ctx
    	});

    	return block;
    }

    // (824:39) {:else}
    function create_else_block(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*player*/ ctx[16].logo)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "align-self-center mr-3");
    			attr_dev(img, "alt", "");
    			add_location(img, file$1, 824, 39, 23002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedTeam*/ 4 && !src_url_equal(img.src, img_src_value = /*player*/ ctx[16].logo)) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(824:39) {:else}",
    		ctx
    	});

    	return block;
    }

    // (822:36) {#if player.logo.length <1}
    function create_if_block_1(ctx) {
    	let div;
    	let t_value = /*player*/ ctx[16].name[0] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(t_value);
    			attr_dev(div, "class", "init-name");
    			add_location(div, file$1, 822, 39, 22870);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectedTeam*/ 4 && t_value !== (t_value = /*player*/ ctx[16].name[0] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(822:36) {#if player.logo.length <1}",
    		ctx
    	});

    	return block;
    }

    // (820:10) {#each teams.find(t => t.name == selectedTeam).players as player }
    function create_each_block(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let h5;
    	let t1_value = /*player*/ ctx[16].inGameName + "";
    	let t1;
    	let t2;
    	let p0;
    	let t3_value = /*player*/ ctx[16].name + "";
    	let t3;
    	let t4;
    	let p1;
    	let t5_value = /*player*/ ctx[16].role + "";
    	let t5;
    	let t6;

    	function select_block_type(ctx, dirty) {
    		if (/*player*/ ctx[16].logo.length < 1) return create_if_block_1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if_block.c();
    			t0 = space();
    			div0 = element("div");
    			h5 = element("h5");
    			t1 = text$1(t1_value);
    			t2 = space();
    			p0 = element("p");
    			t3 = text$1(t3_value);
    			t4 = space();
    			p1 = element("p");
    			t5 = text$1(t5_value);
    			t6 = space();
    			attr_dev(h5, "class", "mt-0 ingame-name");
    			add_location(h5, file$1, 827, 13, 23156);
    			attr_dev(p0, "class", "actual-name");
    			add_location(p0, file$1, 828, 13, 23223);
    			attr_dev(p1, "class", "mb-0 role");
    			add_location(p1, file$1, 829, 13, 23277);
    			attr_dev(div0, "class", "media-body");
    			add_location(div0, file$1, 826, 12, 23118);
    			attr_dev(div1, "class", "media player-data-card");
    			add_location(div1, file$1, 820, 11, 22730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if_block.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, h5);
    			append_dev(h5, t1);
    			append_dev(div0, t2);
    			append_dev(div0, p0);
    			append_dev(p0, t3);
    			append_dev(div0, t4);
    			append_dev(div0, p1);
    			append_dev(p1, t5);
    			append_dev(div1, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, t0);
    				}
    			}

    			if (dirty & /*selectedTeam*/ 4 && t1_value !== (t1_value = /*player*/ ctx[16].inGameName + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*selectedTeam*/ 4 && t3_value !== (t3_value = /*player*/ ctx[16].name + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*selectedTeam*/ 4 && t5_value !== (t5_value = /*player*/ ctx[16].role + "")) set_data_dev(t5, t5_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(820:10) {#each teams.find(t => t.name == selectedTeam).players as player }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div0;
    	let h1;
    	let t1;
    	let div14;
    	let div13;
    	let div6;
    	let div5;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div12;
    	let div11;
    	let div10;
    	let div9;
    	let div7;
    	let div7_resize_listener;
    	let t10;
    	let progress_1;
    	let t11;
    	let div8;
    	let h5;
    	let t12;
    	let t13;
    	let t14;
    	let pointstable;
    	let t15;
    	let insider;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*teams*/ ctx[5].filter(/*func*/ ctx[10]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block = /*selectedTeam*/ ctx[2] && create_if_block$1(ctx);
    	pointstable = new PointsTable({ $$inline: true });
    	insider = new Insider({ $$inline: true });

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Competing Teams";
    			t1 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div1 = element("div");
    			div1.textContent = "Group A";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Group B";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "Group C";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "Group D";
    			t9 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div7 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t10 = space();
    			progress_1 = element("progress");
    			t11 = space();
    			div8 = element("div");
    			h5 = element("h5");
    			t12 = text$1(/*selectedTeam*/ ctx[2]);
    			t13 = space();
    			if (if_block) if_block.c();
    			t14 = space();
    			create_component(pointstable.$$.fragment);
    			t15 = space();
    			create_component(insider.$$.fragment);
    			attr_dev(h1, "class", "title svelte-1yvyzy0");
    			add_location(h1, file$1, 782, 2, 20684);
    			attr_dev(div0, "class", "top-section teams-and-standings svelte-1yvyzy0");
    			add_location(div0, file$1, 781, 1, 20636);
    			attr_dev(div1, "class", "tab-btn");
    			toggle_class(div1, "active", /*selectedGroup*/ ctx[0] == "Group A");
    			add_location(div1, file$1, 790, 5, 20984);
    			attr_dev(div2, "class", "tab-btn");
    			toggle_class(div2, "active", /*selectedGroup*/ ctx[0] == "Group B");
    			add_location(div2, file$1, 791, 5, 21123);
    			attr_dev(div3, "class", "tab-btn");
    			toggle_class(div3, "active", /*selectedGroup*/ ctx[0] == "Group C");
    			add_location(div3, file$1, 792, 5, 21262);
    			attr_dev(div4, "class", "tab-btn");
    			toggle_class(div4, "active", /*selectedGroup*/ ctx[0] == "Group D");
    			add_location(div4, file$1, 793, 5, 21401);
    			attr_dev(div5, "class", "nav");
    			add_location(div5, file$1, 789, 4, 20961);
    			attr_dev(div6, "class", "tab-list nav-section");
    			add_location(div6, file$1, 788, 3, 20922);
    			attr_dev(div7, "class", "team-logos-sec ");
    			add_render_callback(() => /*div7_elementresize_handler*/ ctx[12].call(div7));
    			add_location(div7, file$1, 800, 8, 21746);
    			progress_1.value = /*$progress*/ ctx[3];
    			attr_dev(progress_1, "max", "100");
    			attr_dev(progress_1, "class", "progress-bar-teams");
    			add_location(progress_1, file$1, 815, 24, 22444);
    			attr_dev(h5, "class", "selected-team");
    			add_location(h5, file$1, 817, 9, 22568);
    			attr_dev(div8, "class", "team-player-sec");
    			add_location(div8, file$1, 816, 8, 22529);
    			attr_dev(div9, "class", "teams-details d-flex");
    			add_location(div9, file$1, 799, 6, 21703);
    			attr_dev(div10, "class", "col-md-8 col-sm-12 col-xs-12 teams-view-container");
    			add_location(div10, file$1, 798, 5, 21633);
    			attr_dev(div11, "class", "row justify-content-center");
    			add_location(div11, file$1, 797, 4, 21587);
    			attr_dev(div12, "class", "container");
    			add_location(div12, file$1, 796, 3, 21559);
    			attr_dev(div13, "class", "tabs");
    			add_location(div13, file$1, 787, 2, 20900);
    			attr_dev(div14, "class", "teams-details-container");
    			add_location(div14, file$1, 786, 1, 20860);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, h1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div1);
    			append_dev(div5, t3);
    			append_dev(div5, div2);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div13, t9);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div7, null);
    			}

    			div7_resize_listener = add_resize_listener(div7, /*div7_elementresize_handler*/ ctx[12].bind(div7));
    			append_dev(div9, t10);
    			append_dev(div9, progress_1);
    			append_dev(div9, t11);
    			append_dev(div9, div8);
    			append_dev(div8, h5);
    			append_dev(h5, t12);
    			append_dev(div8, t13);
    			if (if_block) if_block.m(div8, null);
    			insert_dev(target, t14, anchor);
    			mount_component(pointstable, target, anchor);
    			insert_dev(target, t15, anchor);
    			mount_component(insider, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", prevent_default(/*click_handler*/ ctx[6]), false, true, false),
    					listen_dev(div2, "click", prevent_default(/*click_handler_1*/ ctx[7]), false, true, false),
    					listen_dev(div3, "click", prevent_default(/*click_handler_2*/ ctx[8]), false, true, false),
    					listen_dev(div4, "click", prevent_default(/*click_handler_3*/ ctx[9]), false, true, false),
    					listen_dev(div7, "scroll", /*scroll_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selectedGroup*/ 1) {
    				toggle_class(div1, "active", /*selectedGroup*/ ctx[0] == "Group A");
    			}

    			if (dirty & /*selectedGroup*/ 1) {
    				toggle_class(div2, "active", /*selectedGroup*/ ctx[0] == "Group B");
    			}

    			if (dirty & /*selectedGroup*/ 1) {
    				toggle_class(div3, "active", /*selectedGroup*/ ctx[0] == "Group C");
    			}

    			if (dirty & /*selectedGroup*/ 1) {
    				toggle_class(div4, "active", /*selectedGroup*/ ctx[0] == "Group D");
    			}

    			if (dirty & /*selectedTeam, teams, selectedGroup*/ 37) {
    				each_value_1 = /*teams*/ ctx[5].filter(/*func*/ ctx[10]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div7, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (!current || dirty & /*$progress*/ 8) {
    				prop_dev(progress_1, "value", /*$progress*/ ctx[3]);
    			}

    			if (!current || dirty & /*selectedTeam*/ 4) set_data_dev(t12, /*selectedTeam*/ ctx[2]);

    			if (/*selectedTeam*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(div8, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointstable.$$.fragment, local);
    			transition_in(insider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pointstable.$$.fragment, local);
    			transition_out(insider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div14);
    			destroy_each(each_blocks, detaching);
    			div7_resize_listener();
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t14);
    			destroy_component(pointstable, detaching);
    			if (detaching) detach_dev(t15);
    			destroy_component(insider, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $progress;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TeamsAndStandings', slots, []);
    	let clientWidth;
    	const progress = tweened(0, { duration: 400, easing: cubicOut });
    	validate_store(progress, 'progress');
    	component_subscribe($$self, progress, value => $$invalidate(3, $progress = value));

    	let teams = [
    		{
    			"name": "Head Hunters",
    			"logo": "HeadHunters.jpg",
    			"group": "Group A",
    			"players": [
    				{
    					"logo": "test.png",
    					"name": "Satyam Thakur",
    					"inGameName": "HH.Viper24",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "Nilesh Gattani",
    					"inGameName": "HH-Maimungda",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Priyanshu Halder Saha",
    					"inGameName": "HH-SONTY",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Md. Abdul Moghni",
    					"inGameName": "HH-Reaper",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Md. dsds Moghni",
    					"inGameName": "HH-Reaper",
    					"role": "Rusher"
    				}
    			]
    		},
    		{
    			"name": "4 Unknown",
    			"logo": "4UNKNOWNLOGO.jpg",
    			"group": "Group A",
    			"players": [
    				{
    					"logo": "",
    					"name": "Mohd Zuber",
    					"inGameName": "4UN-DEADSOUL",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Swastik Madhukar Dushing ",
    					"inGameName": "4UN-SWASTIK",
    					"role": "Rusher "
    				},
    				{
    					"logo": "",
    					"name": "Anand Madhukar Dushing ",
    					"inGameName": "4UN-ANAND",
    					"role": "Sniper "
    				},
    				{
    					"logo": "",
    					"name": "Vadher Anil Devashibhai",
    					"inGameName": "4UN-WIZARDO",
    					"role": "Assaulter "
    				}
    			]
    		},
    		{
    			"name": "Survivors",
    			"logo": "SURVIVORS.jpg",
    			"group": "Group A",
    			"players": [
    				{
    					"logo": "",
    					"name": "Karanjot Mehta",
    					"inGameName": "SRV INSANE",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Harsh Singh",
    					"inGameName": "SRV-HARSH19",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Ashwani yadav",
    					"inGameName": "SRV-IGNITE",
    					"role": "Support"
    				},
    				{
    					"logo": "",
    					"name": "ALEXIS.C Arthur",
    					"inGameName": "SRV-ALEX",
    					"role": "Sniper"
    				}
    			]
    		},
    		{
    			"name": "Mayhem",
    			"logo": "TEAMMAYHEM.jpg",
    			"group": "Group A",
    			"players": [
    				{
    					"logo": "",
    					"name": "Anish Das",
    					"inGameName": "mYm-NINJA",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Nikhil arjun C",
    					"inGameName": "mYm-NIKHIL",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Shivam Kumar",
    					"inGameName": "mYm-FARFROST",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Abhishek Rao",
    					"inGameName": "mYm-???????",
    					"role": "Filter"
    				}
    			]
    		},
    		{
    			"name": "Evil Army",
    			"logo": "TBD",
    			"group": "Group A",
    			"players": [
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				}
    			]
    		},
    		{
    			"name": "Galaxy Racer",
    			"logo": "TBD",
    			"group": "Group A",
    			"players": [
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				}
    			]
    		},
    		{
    			"name": "Team Chaos",
    			"logo": "TEAMCHAOS.jpg",
    			"group": "Group B",
    			"players": [
    				{
    					"logo": "",
    					"name": "Somesh Yadav",
    					"inGameName": "TC-SCARY",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Kamal Kapoor",
    					"inGameName": "TC-TECHKK",
    					"role": "Support"
    				},
    				{
    					"logo": "",
    					"name": "Vivek Sharma",
    					"inGameName": "TC-VIVEK",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Mirza Arsalan Athar Baig",
    					"inGameName": "TC-ARSALAN",
    					"role": "Rusher"
    				}
    			]
    		},
    		{
    			"name": "PVS Gaming",
    			"logo": "PVSLOGO.jpg",
    			"group": "Group B",
    			"players": [
    				{
    					"logo": "",
    					"name": "P. Praveen",
    					"inGameName": "PVS-LOV2RBOY",
    					"role": "IGL "
    				},
    				{
    					"logo": "",
    					"name": "A. Mudassir",
    					"inGameName": "PVS-NOBITA",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "V. Sanjay Nair",
    					"inGameName": "PVS-SANJ4Y",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "L. Sriram",
    					"inGameName": "PVS-INNOCENT�",
    					"role": "Supporter"
    				}
    			]
    		},
    		{
    			"name": "Team Elite",
    			"logo": "TEAMELITE.jpg",
    			"group": "Group B",
    			"players": [
    				{
    					"logo": "",
    					"name": "Dev Kumar�",
    					"inGameName": "TE-ICONIC",
    					"role": "Flanker"
    				},
    				{
    					"logo": "",
    					"name": "Lokesh Karakoti ",
    					"inGameName": "TE-Pahadi",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "Aditya Sing Sikarwar",
    					"inGameName": "TE-KILLER",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Ajay Kumar Banga",
    					"inGameName": "TE - JONTY",
    					"role": "IGL"
    				}
    			]
    		},
    		{
    			"name": "Raven Esports",
    			"logo": "RAVENESPORTS.jpg",
    			"group": "Group B",
    			"players": [
    				{
    					"logo": "",
    					"name": "Kavibharathi",
    					"inGameName": "RE.DEADSHOT",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Ajith Kumar",
    					"inGameName": "RE.AJITH",
    					"role": "Supporter"
    				},
    				{
    					"logo": "",
    					"name": "Jogyesh",
    					"inGameName": "RE.JOGESH",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "Prasannagiri",
    					"inGameName": "RE.PRASANA",
    					"role": "Rusher"
    				}
    			]
    		},
    		{
    			"name": "Blind Esports",
    			"logo": "BLIND.jpg",
    			"group": "Group B",
    			"players": [
    				{
    					"logo": "",
    					"name": "Nivesh Kabadwala",
    					"inGameName": "BLD-N1VESH",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Dandu Jayasimha",
    					"inGameName": "BLD-BABLU",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Ekansh Ginotra",
    					"inGameName": "BLD-G1NOTRA",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Abhay Kujur",
    					"inGameName": "BLD-ABHAY",
    					"role": "Sniper"
    				}
    			]
    		},
    		{
    			"name": "Team D Esport",
    			"logo": "TEAMDESPORTS.jpg",
    			"group": "Group B",
    			"players": [
    				{
    					"logo": "",
    					"name": "Mukul Chaudhary",
    					"inGameName": "D-BLACKSHOUT ",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Amit",
    					"inGameName": "D-RNS",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Amit",
    					"inGameName": "D-AMITWALIA",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Devyanshu Singh",
    					"inGameName": "D-SHINH",
    					"role": "Assaulter"
    				}
    			]
    		},
    		{
    			"name": "IND Elite",
    			"logo": "INDELITE.jpg",
    			"group": "Group C",
    			"players": [
    				{
    					"logo": "",
    					"name": "Sameer Ahmad Allaye",
    					"inGameName": "Sam",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Jatin Taneja",
    					"inGameName": "Taneja",
    					"role": "Flanker"
    				},
    				{
    					"logo": "",
    					"name": "Putta Rohit",
    					"inGameName": "BABY",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Srijit Paul",
    					"inGameName": "Predator",
    					"role": "Sniper"
    				}
    			]
    		},
    		{
    			"name": "Total Gaming Esports",
    			"logo": "Totalgaming.jpg",
    			"group": "Group C",
    			"players": [
    				{
    					"logo": "",
    					"name": "Vora HitKumar",
    					"inGameName": "TG-MAFIABALA",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Ajay Sharma",
    					"inGameName": "TG-FozyAjay",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Narai Yadav",
    					"inGameName": "TG-Delete",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Daksh Garg",
    					"inGameName": "TG- MAFIA�",
    					"role": "Sniper"
    				}
    			]
    		},
    		{
    			"name": "Blood Bashers",
    			"logo": "BloodbashersS.jpg",
    			"group": "Group C",
    			"players": [
    				{
    					"logo": "",
    					"name": "Rahul Kumar Sahu",
    					"inGameName": "? E?????!!",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Likhith K",
    					"inGameName": "TSG-LIKH",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "Harsh Pandey",
    					"inGameName": "SRV-AMAN",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Shubraj",
    					"inGameName": "SUBHU-S21",
    					"role": "Assaulter"
    				}
    			]
    		},
    		{
    			"name": "Chemin Esports",
    			"logo": "CHEMINESPORTS.jpg",
    			"group": "Group C",
    			"players": [
    				{
    					"logo": "",
    					"name": "Honey Aggarwal",
    					"inGameName": "CES-Adam",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Koushik Malik",
    					"inGameName": "CES-Koushik7",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "Mayank Singh Rana",
    					"inGameName": "CES-Ashustar",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Bhavik Khandekar",
    					"inGameName": "CES-Dev Bhai",
    					"role": "Assaulter"
    				}
    			]
    		},
    		{
    			"name": "LVL Iconic",
    			"logo": "LVLICONIC.jpg",
    			"group": "Group C",
    			"players": [
    				{
    					"logo": "",
    					"name": "Deepanshu Shandil",
    					"inGameName": "IC-MARTIN",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Sunil Kumar",
    					"inGameName": "IC-ANGRY",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Roni Thakur",
    					"inGameName": "IC-ROUNINEGI",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Aluddin Varsi",
    					"inGameName": "IC-ALADDIN",
    					"role": "IGL"
    				}
    			]
    		},
    		{
    			"name": "TSG Army",
    			"logo": "TSGARMY.jpg",
    			"group": "Group C",
    			"players": [
    				{
    					"logo": "",
    					"name": "Bhavesh Lakhwani",
    					"inGameName": "TSG LEGEND  ",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Ritik",
    					"inGameName": "TSG RITIK ",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Ojasvi Kamra",
    					"inGameName": "TSG OJASVI",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "G. Vihaan Dutta",
    					"inGameName": "TSG VIHAAN",
    					"role": "Supporter"
    				}
    			]
    		},
    		{
    			"name": "TSM FTX",
    			"logo": "TSMFTX.jpg",
    			"group": "Group D",
    			"players": [
    				{
    					"logo": "",
    					"name": "Sagar Patel",
    					"inGameName": "Illuminati",
    					"role": "Support"
    				},
    				{
    					"logo": "",
    					"name": "Indranil Saha",
    					"inGameName": "Indro",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Jayesh Yadav",
    					"inGameName": "Mr.Jay",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Naitik Khoshto",
    					"inGameName": "Monk",
    					"role": "Sniper"
    				}
    			]
    		},
    		{
    			"name": "AFF Esports",
    			"logo": "AFFESPORTS.jpg",
    			"group": "Group D",
    			"players": [
    				{
    					"logo": "",
    					"name": "Arpit Tyagi",
    					"inGameName": "AFF-TYAGI",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Owais Bhati",
    					"inGameName": "AFF-MAFIA21.",
    					"role": "Support"
    				},
    				{
    					"logo": "",
    					"name": "Rahil Katoch",
    					"inGameName": "AFF-RAHIL.�",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Kanishk Verma",
    					"inGameName": "AFF-KANISHK.",
    					"role": "Assaulter"
    				}
    			]
    		},
    		{
    			"name": "Namesis",
    			"logo": "Nemesis.jpg",
    			"group": "Group D",
    			"players": [
    				{
    					"logo": "",
    					"name": "Sunil",
    					"inGameName": "NMS-MINDGMR",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Manu",
    					"inGameName": "NMS-MRGAMER",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Uzaif Ahmed",
    					"inGameName": "NMS-uzaif18",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Rohit Kumar",
    					"inGameName": "AG-RAJU!!!",
    					"role": "Sniper"
    				}
    			]
    		},
    		{
    			"name": "God Like",
    			"logo": "god_like.jpg",
    			"group": "Group D",
    			"players": [
    				{
    					"logo": "",
    					"name": "Ankit Shukla",
    					"inGameName": "GOD.TISTA",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Ashish Mishra",
    					"inGameName": "GOD.ASHISH08",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Mohd Alhan",
    					"inGameName": "DEV-ALHAN",
    					"role": "Assaulter"
    				},
    				{
    					"logo": "",
    					"name": "Nikhil makhijareg",
    					"inGameName": "EA-Nikhil-13",
    					"role": "rusher"
    				}
    			]
    		},
    		{
    			"name": "Enigma Gaming",
    			"logo": "ENIGMAGAMING.jpg",
    			"group": "Group D",
    			"players": [
    				{
    					"logo": "",
    					"name": "Arindam Biswas",
    					"inGameName": "EG-ARIN007",
    					"role": "IGL"
    				},
    				{
    					"logo": "",
    					"name": "Kishan Ramesh�",
    					"inGameName": "EG-KRGOWDRU",
    					"role": "Rusher"
    				},
    				{
    					"logo": "",
    					"name": "Ansh Babbar",
    					"inGameName": "EG-Ansh",
    					"role": "Sniper"
    				},
    				{
    					"logo": "",
    					"name": "Promit Banerjee",
    					"inGameName": "EG-PROMIT",
    					"role": "Assaulter"
    				}
    			]
    		},
    		{
    			"name": "UG MANIA",
    			"logo": "TBD",
    			"group": "Group D",
    			"players": [
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				},
    				{
    					"logo": "TBD",
    					"name": "TBD",
    					"inGameName": "TBD",
    					"role": "TBD"
    				}
    			]
    		}
    	];

    	let selectedGroup = "Group A";
    	let selectedTeam;

    	const selectTeam = () => {
    		$$invalidate(2, selectedTeam = teams.filter(t => t.group == selectedGroup)[0].name);
    		console.log(selectedTeam);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<TeamsAndStandings> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => $$invalidate(0, selectedGroup = "Group A");
    	const click_handler_1 = e => $$invalidate(0, selectedGroup = "Group B");
    	const click_handler_2 = e => $$invalidate(0, selectedGroup = "Group C");
    	const click_handler_3 = e => $$invalidate(0, selectedGroup = "Group D");
    	const func = t => t.group == selectedGroup;

    	const click_handler_4 = (team, e) => {
    		$$invalidate(2, selectedTeam = team.name);
    	};

    	function div7_elementresize_handler() {
    		clientWidth = this.clientWidth;
    		$$invalidate(1, clientWidth);
    	}

    	const scroll_handler = e => {
    		let scrollValue = e.target.scrollLeft;
    		$$invalidate(1, clientWidth);
    		progress.set(1.4 * scrollValue / clientWidth * 100);
    	};

    	const func_1 = t => t.name == selectedTeam;

    	$$self.$capture_state = () => ({
    		each: each$1,
    		PointsTable,
    		Insider,
    		tweened,
    		cubicOut,
    		clientWidth,
    		progress,
    		teams,
    		selectedGroup,
    		selectedTeam,
    		selectTeam,
    		$progress
    	});

    	$$self.$inject_state = $$props => {
    		if ('clientWidth' in $$props) $$invalidate(1, clientWidth = $$props.clientWidth);
    		if ('teams' in $$props) $$invalidate(5, teams = $$props.teams);
    		if ('selectedGroup' in $$props) $$invalidate(0, selectedGroup = $$props.selectedGroup);
    		if ('selectedTeam' in $$props) $$invalidate(2, selectedTeam = $$props.selectedTeam);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selectedGroup*/ 1) {
    			(selectTeam());
    		}
    	};

    	return [
    		selectedGroup,
    		clientWidth,
    		selectedTeam,
    		$progress,
    		progress,
    		teams,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		func,
    		click_handler_4,
    		div7_elementresize_handler,
    		scroll_handler,
    		func_1
    	];
    }

    class TeamsAndStandings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TeamsAndStandings",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.41.0 */
    const file = "src/App.svelte";

    // (49:1) {#if isLive}
    function create_if_block(ctx) {
    	let script0;
    	let t1;
    	let script1;
    	let script1_src_value;

    	const block = {
    		c: function create() {
    			script0 = element("script");
    			script0.textContent = "window.fwSettings={\n\t\t\t'widget_id':82000001234\n\t\t\t};\n\t\t\t!function(){if(\"function\"!=typeof window.FreshworksWidget){var n=function(){n.q.push(arguments)};n.q=[],window.FreshworksWidget=n}}()";
    			t1 = space();
    			script1 = element("script");
    			add_location(script0, file, 49, 2, 2281);
    			attr_dev(script1, "type", "text/javascript");
    			if (!src_url_equal(script1.src, script1_src_value = "https://ind-widget.freshworks.com/widgets/82000001234.js")) attr_dev(script1, "src", script1_src_value);
    			script1.async = true;
    			script1.defer = true;
    			add_location(script1, file, 55, 2, 2498);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, script0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, script1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(script0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(script1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(49:1) {#if isLive}",
    		ctx
    	});

    	return block;
    }

    // (133:3) <DefaultLayout>
    function create_default_slot_23(ctx) {
    	let privacypolicy;
    	let current;
    	privacypolicy = new PrivacyPolicy({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(privacypolicy.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(privacypolicy, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(privacypolicy.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(privacypolicy.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(privacypolicy, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(133:3) <DefaultLayout>",
    		ctx
    	});

    	return block;
    }

    // (132:2) <Route path="/privacypolicy">
    function create_default_slot_22(ctx) {
    	let defaultlayout;
    	let current;

    	defaultlayout = new Default({
    			props: {
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(defaultlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(defaultlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const defaultlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				defaultlayout_changes.$$scope = { dirty, ctx };
    			}

    			defaultlayout.$set(defaultlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(defaultlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(defaultlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(defaultlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(132:2) <Route path=\\\"/privacypolicy\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:3) <DefaultLayout>
    function create_default_slot_21(ctx) {
    	let termsofuse;
    	let current;
    	termsofuse = new TermsOfUse({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(termsofuse.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(termsofuse, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(termsofuse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(termsofuse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(termsofuse, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(138:3) <DefaultLayout>",
    		ctx
    	});

    	return block;
    }

    // (137:2) <Route path="/termsofuse">
    function create_default_slot_20(ctx) {
    	let defaultlayout;
    	let current;

    	defaultlayout = new Default({
    			props: {
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(defaultlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(defaultlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const defaultlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				defaultlayout_changes.$$scope = { dirty, ctx };
    			}

    			defaultlayout.$set(defaultlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(defaultlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(defaultlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(defaultlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(137:2) <Route path=\\\"/termsofuse\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:3) <DefaultLayout>
    function create_default_slot_19(ctx) {
    	let cookies;
    	let current;
    	cookies = new Cookies({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(cookies.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cookies, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cookies.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cookies.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cookies, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(143:3) <DefaultLayout>",
    		ctx
    	});

    	return block;
    }

    // (142:2) <Route path="/cookies">
    function create_default_slot_18(ctx) {
    	let defaultlayout;
    	let current;

    	defaultlayout = new Default({
    			props: {
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(defaultlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(defaultlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const defaultlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				defaultlayout_changes.$$scope = { dirty, ctx };
    			}

    			defaultlayout.$set(defaultlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(defaultlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(defaultlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(defaultlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(142:2) <Route path=\\\"/cookies\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:3) <MainLayout>
    function create_default_slot_17(ctx) {
    	let home;
    	let current;
    	home = new Home({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(153:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (152:2) <Route path="/" exact>
    function create_default_slot_16(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(152:2) <Route path=\\\"/\\\" exact>",
    		ctx
    	});

    	return block;
    }

    // (158:3) <MainLayout>
    function create_default_slot_15(ctx) {
    	let home;
    	let current;
    	home = new Home({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(158:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (157:2) <Route path="/?:params" exact>
    function create_default_slot_14(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(157:2) <Route path=\\\"/?:params\\\" exact>",
    		ctx
    	});

    	return block;
    }

    // (163:3) <MainLayout>
    function create_default_slot_13(ctx) {
    	let home;
    	let current;
    	home = new Home({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(163:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (162:2) <Route path="/contest">
    function create_default_slot_12(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(162:2) <Route path=\\\"/contest\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:3) <MainLayout>
    function create_default_slot_11(ctx) {
    	let home;
    	let current;
    	home = new Home({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(168:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (167:2) <Route path="/contest?:params">
    function create_default_slot_10(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(167:2) <Route path=\\\"/contest?:params\\\">",
    		ctx
    	});

    	return block;
    }

    // (179:3) <MainLayout>
    function create_default_slot_9(ctx) {
    	let formatdetails;
    	let current;
    	formatdetails = new Format_details({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(formatdetails.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(formatdetails, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formatdetails.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formatdetails.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formatdetails, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(179:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (178:2) <Route path="/format">
    function create_default_slot_8(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(178:2) <Route path=\\\"/format\\\">",
    		ctx
    	});

    	return block;
    }

    // (184:3) <MainLayout>
    function create_default_slot_7(ctx) {
    	let teamsandstandings;
    	let current;
    	teamsandstandings = new TeamsAndStandings({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(teamsandstandings.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(teamsandstandings, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(teamsandstandings.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(teamsandstandings.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(teamsandstandings, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(184:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (183:2) <Route path="/teamsandstandings">
    function create_default_slot_6(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(183:2) <Route path=\\\"/teamsandstandings\\\">",
    		ctx
    	});

    	return block;
    }

    // (189:3) <MainLayout>
    function create_default_slot_5(ctx) {
    	let schedule;
    	let current;
    	schedule = new Schedule$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(schedule.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(schedule, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(schedule.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(schedule.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(schedule, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(189:3) <MainLayout>",
    		ctx
    	});

    	return block;
    }

    // (188:2) <Route path="/schedule">
    function create_default_slot_4(ctx) {
    	let mainlayout;
    	let current;

    	mainlayout = new Main({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mainlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mainlayout, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mainlayout_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				mainlayout_changes.$$scope = { dirty, ctx };
    			}

    			mainlayout.$set(mainlayout_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mainlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(188:2) <Route path=\\\"/schedule\\\">",
    		ctx
    	});

    	return block;
    }

    // (194:3) <Inner>
    function create_default_slot_3(ctx) {
    	let videos;
    	let current;
    	videos = new Videos({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(videos.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videos, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videos.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videos.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videos, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(194:3) <Inner>",
    		ctx
    	});

    	return block;
    }

    // (193:2) <Route path="/videos">
    function create_default_slot_2(ctx) {
    	let inner;
    	let current;

    	inner = new Inner({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(inner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(inner, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const inner_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				inner_changes.$$scope = { dirty, ctx };
    			}

    			inner.$set(inner_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(inner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(193:2) <Route path=\\\"/videos\\\">",
    		ctx
    	});

    	return block;
    }

    // (217:1) <Fallback>
    function create_default_slot_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("NotFound");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(217:1) <Fallback>",
    		ctx
    	});

    	return block;
    }

    // (59:0) <Router>
    function create_default_slot(ctx) {
    	let route0;
    	let t0;
    	let route1;
    	let t1;
    	let route2;
    	let t2;
    	let route3;
    	let t3;
    	let route4;
    	let t4;
    	let route5;
    	let t5;
    	let route6;
    	let t6;
    	let route7;
    	let t7;
    	let route8;
    	let t8;
    	let route9;
    	let t9;
    	let route10;
    	let t10;
    	let fallback;
    	let current;

    	route0 = new Route({
    			props: {
    				path: "/privacypolicy",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route1 = new Route({
    			props: {
    				path: "/termsofuse",
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: "/cookies",
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: "/",
    				exact: true,
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route4 = new Route({
    			props: {
    				path: "/?:params",
    				exact: true,
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route5 = new Route({
    			props: {
    				path: "/contest",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route6 = new Route({
    			props: {
    				path: "/contest?:params",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route7 = new Route({
    			props: {
    				path: "/format",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route8 = new Route({
    			props: {
    				path: "/teamsandstandings",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route9 = new Route({
    			props: {
    				path: "/schedule",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route10 = new Route({
    			props: {
    				path: "/videos",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	fallback = new Fallback({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route0.$$.fragment);
    			t0 = space();
    			create_component(route1.$$.fragment);
    			t1 = space();
    			create_component(route2.$$.fragment);
    			t2 = space();
    			create_component(route3.$$.fragment);
    			t3 = space();
    			create_component(route4.$$.fragment);
    			t4 = space();
    			create_component(route5.$$.fragment);
    			t5 = space();
    			create_component(route6.$$.fragment);
    			t6 = space();
    			create_component(route7.$$.fragment);
    			t7 = space();
    			create_component(route8.$$.fragment);
    			t8 = space();
    			create_component(route9.$$.fragment);
    			t9 = space();
    			create_component(route10.$$.fragment);
    			t10 = space();
    			create_component(fallback.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(route1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(route2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(route3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(route4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(route5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(route6, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(route7, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(route8, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(route9, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(route10, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(fallback, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route0_changes.$$scope = { dirty, ctx };
    			}

    			route0.$set(route0_changes);
    			const route1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route1_changes.$$scope = { dirty, ctx };
    			}

    			route1.$set(route1_changes);
    			const route2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route2_changes.$$scope = { dirty, ctx };
    			}

    			route2.$set(route2_changes);
    			const route3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route3_changes.$$scope = { dirty, ctx };
    			}

    			route3.$set(route3_changes);
    			const route4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route4_changes.$$scope = { dirty, ctx };
    			}

    			route4.$set(route4_changes);
    			const route5_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route5_changes.$$scope = { dirty, ctx };
    			}

    			route5.$set(route5_changes);
    			const route6_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route6_changes.$$scope = { dirty, ctx };
    			}

    			route6.$set(route6_changes);
    			const route7_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route7_changes.$$scope = { dirty, ctx };
    			}

    			route7.$set(route7_changes);
    			const route8_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route8_changes.$$scope = { dirty, ctx };
    			}

    			route8.$set(route8_changes);
    			const route9_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route9_changes.$$scope = { dirty, ctx };
    			}

    			route9.$set(route9_changes);
    			const route10_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route10_changes.$$scope = { dirty, ctx };
    			}

    			route10.$set(route10_changes);
    			const fallback_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				fallback_changes.$$scope = { dirty, ctx };
    			}

    			fallback.$set(fallback_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(route6.$$.fragment, local);
    			transition_in(route7.$$.fragment, local);
    			transition_in(route8.$$.fragment, local);
    			transition_in(route9.$$.fragment, local);
    			transition_in(route10.$$.fragment, local);
    			transition_in(fallback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(route6.$$.fragment, local);
    			transition_out(route7.$$.fragment, local);
    			transition_out(route8.$$.fragment, local);
    			transition_out(route9.$$.fragment, local);
    			transition_out(route10.$$.fragment, local);
    			transition_out(fallback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(route1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(route2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(route3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(route4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(route5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(route6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(route7, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(route8, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(route9, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(route10, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(fallback, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(59:0) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let if_block_anchor;
    	let t0;
    	let router;
    	let t1;
    	let modalrenderer;
    	let current;
    	let if_block = create_if_block(ctx);

    	router = new BrowserRouter({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modalrenderer = new ModalRenderer({ $$inline: true });

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			t0 = space();
    			create_component(router.$$.fragment);
    			t1 = space();
    			create_component(modalrenderer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(document.head, null);
    			append_dev(document.head, if_block_anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(router, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(modalrenderer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			transition_in(modalrenderer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			transition_out(modalrenderer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			detach_dev(if_block_anchor);
    			if (detaching) detach_dev(t0);
    			destroy_component(router, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(modalrenderer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const isLive = true; //window.localStorage.getItem('debug');

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const user = User.getUser();

    	if (window.location.search == '?RN_DEBUG=true') {
    		window.localStorage.setItem('debug', 'true');
    	} else if (window.location.search == '?RN_DEBUG=false') {
    		window.localStorage.removeItem('debug');
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router: BrowserRouter,
    		Route,
    		Redirect,
    		Fallback,
    		getHistory,
    		Layout,
    		onMount,
    		DefaultLayout: Default,
    		MainLayout: Main,
    		Inner,
    		BlankLayout: Blank,
    		HomePage2Layout: Homepage2,
    		LoginPage: Login,
    		Home,
    		HomePage2,
    		LeaderBoard: Leaderboard,
    		Schedule: Schedule$1,
    		Videos,
    		Faqs: Faq,
    		FormatDetails: Format_details,
    		UserDashboard: Dashboard,
    		UserDashboardZerpPlayer: Dashboard_day_zero_player,
    		PrivacyPolicy,
    		Cookies,
    		TermsOfUse,
    		DayZeroLeader: Dashboard_day_zero_leader,
    		Location,
    		DeviceDetails: Device_Details,
    		Support,
    		InGameQualifiers: In_game_qualifiers,
    		UserDashboardPlayoff: User_dashboard_playoff,
    		ModalRenderer,
    		User,
    		SaveInvite,
    		DevTool,
    		CompleteRegistration,
    		Stats,
    		Standings: TeamsAndStandings,
    		TeamsAndStandings,
    		user,
    		isLive
    	});

    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
      target: document.body,
      props: {
        name: 'world'
      }
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
